version
1
;
typedef
I64
vdb
:
row_id_range
[
2
]
;
typeset
integer_set
{
I8
,
U8
,
I16
,
U16
,
I32
,
U32
,
I64
,
U64
}
;
typeset
float_set
{
F32
,
F64
}
;
typeset
numeric_set
{
integer_set
,
float_set
}
;
typeset
text_set
{
utf8
,
utf16
,
utf32
,
ascii
}
;
typeset
text8_set
{
utf8
,
ascii
}
;
typeset
transpose_set
{
B8
,
B16
,
B32
,
B64
}
;
fmtdef
merged_fmt
;
fmtdef
transposed_fmt
;
fmtdef
delta_averaged_fmt
;
const
U8
ALIGN_LEFT
=
0
;
const
U8
ALIGN_RIGHT
=
1
;
function
any
cast
#1.0
(
any
in
)
=
vdb
:
cast
;
function
<
type
T
>
T
bit_or
#1
<
U8
align
>
(
T
A
,
T
B
)
=
vdb
:
bit_or
;
function
<
type
T
>
T
trim
#1
<
U8
align
,
T
val
>
(
T
A
)
=
vdb
:
trim
;
function
any
redimension
#1.0
(
any
in
)
=
vdb
:
redimension
;
function
I64
row_id
#1.0
(
)
=
vdb
:
row_id
;
function
U32
row_len
#1.0
(
any
in
)
=
vdb
:
row_len
;
function
U32
fixed_row_len
#1.0
(
any
in
)
=
vdb
:
fixed_row_len
;
validate
function
<
type
T
>
void
compare
#1.0
<
*
U32
sig_bits
>
(
T
src
,
T
cmp
)
=
vdb
:
compare
;
validate
function
<
type
T
>
void
no_compare
#1.0
(
T
src
,
T
cmp
)
=
vdb
:
no_compare
;
function
<
type
T
>
T
range_validate
#1.0
<
T
lower
,
T
upper
>
(
T
in
)
=
vdb
:
range_validate
;
function
<
type
T
>
T
select
#1.0
(
T
first
,
T
second
,
...
)
=
vdb
:
select
;
function
transposed_fmt
transpose
#1
(
transpose_set
in
)
=
vdb
:
transpose
;
function
transpose_set
detranspose
#1
(
transposed_fmt
in
)
=
vdb
:
detranspose
;
function
delta_averaged_fmt
delta_average
#1
(
any
in
)
=
vdb
:
delta_average
;
function
any
undelta_average
#1
(
delta_averaged_fmt
in
)
=
vdb
:
undelta_average
;
function
merged_fmt
merge
#1.0
(
any
in
,
...
)
=
vdb
:
merge
;
function
any
split
#1.0
<
U32
idx
>
(
merged_fmt
in
)
=
vdb
:
split
;
function
<
type
T
>
T
meta
:
read
#1.0
<
ascii
node
,
*
bool
deterministic
>
(
)
;
function
<
type
T
>
T
meta
:
value
#1.0
<
ascii
node
,
*
bool
deterministic
>
(
)
;
function
<
type
T
>
T
meta
:
write
#1.0
<
ascii
node
>
(
T
in
)
;
function
ascii
meta
:
attr
:
read
#1.0
<
ascii
node
,
ascii
attr
,
*
bool
deterministic
>
(
)
;
function
ascii
meta
:
attr
:
write
#1.0
<
ascii
node
,
ascii
attr
>
(
ascii
in
)
;
function
text8_set
parameter
:
read
#1.0
<
ascii
name
,
*
bool
deterministic
>
(
)
;
function
text8_set
environment
:
read
#1.0
<
ascii
name
>
(
)
;
const
U8
CASE_SENSITIVE
=
0
;
const
U8
CASE_INSENSITIVE_LOWER
=
1
;
const
U8
CASE_INSENSITIVE_UPPER
=
2
;
function
text8_set
idx
:
text
:
project
#1.1
<
ascii
index_name
,
*
U8
case_sensitivity
>
(
*
text8_set
substitute
)
;
function
text8_set
idx
:
text
:
insert
#1.1
<
ascii
index_name
,
*
U8
case_sensitivity
>
(
text8_set
key
)
;
function
vdb
:
row_id_range
idx
:
text
:
lookup
#1.1
<
ascii
index_name
,
ascii
query_by_name
,
*
U8
case_sensitivity
>
(
)
;
version
1
;
include
'insdc/sra.vschema';
include
'ncbi/sra.vschema';
include
'ncbi/clip.vschema';
include
'ncbi/spotname.vschema';
extern
function
NCBI
:
SRA
:
spot_name_token
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
#1
(
ascii
name
)
;
table
NCBI
:
SRA
:
GenericFastq
:
sequence
#1
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.4
,
NCBI
:
SRA
:
tbl
:
clip
#1.0.2
{
ascii
platform_name
=
<
ascii
>
echo
<
"UNDEFINED"
>
(
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_UNDEFINED
>
(
)
;
NCBI
:
SRA
:
spot_name_token
out_spot_name_tok
=
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
(
_out_name
)
;
NCBI
:
SRA
:
spot_name_token
in_spot_name_tok
=
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
(
NAME
)
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_ADAPTER_LEFT
=
CLIP_ADAPTER_LEFT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_ADAPTER_RIGHT
=
CLIP_ADAPTER_RIGHT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_QUALITY_LEFT
=
CLIP_QUALITY_LEFT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_QUALITY_RIGHT
=
CLIP_QUALITY_RIGHT
;
}
database
NCBI
:
SRA
:
GenericFastq
:
db
#1
{
table
NCBI
:
SRA
:
GenericFastq
:
sequence
#1.0
SEQUENCE
;
}
;
table
NCBI
:
SRA
:
GenericFastq
:
sequence_no_name
#1
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.4
,
NCBI
:
SRA
:
tbl
:
clip
#1.0.2
{
ascii
platform_name
=
<
ascii
>
echo
<
"UNDEFINED"
>
(
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_UNDEFINED
>
(
)
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_ADAPTER_LEFT
=
CLIP_ADAPTER_LEFT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_ADAPTER_RIGHT
=
CLIP_ADAPTER_RIGHT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_QUALITY_LEFT
=
CLIP_QUALITY_LEFT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_QUALITY_RIGHT
=
CLIP_QUALITY_RIGHT
;
}
database
NCBI
:
SRA
:
GenericFastqNoNames
:
db
#1
{
table
NCBI
:
SRA
:
GenericFastq
:
sequence_no_name
#1.0
SEQUENCE
;
}
;
table
NCBI
:
SRA
:
GenericFastq
:
sequence_log_odds
#1
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
log_odds_quality
#2.1.0
,
NCBI
:
SRA
:
tbl
:
clip
#1.0.2
{
ascii
platform_name
=
<
ascii
>
echo
<
"UNDEFINED"
>
(
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_UNDEFINED
>
(
)
;
NCBI
:
SRA
:
spot_name_token
out_spot_name_tok
=
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
(
_out_name
)
;
NCBI
:
SRA
:
spot_name_token
in_spot_name_tok
=
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
(
NAME
)
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_ADAPTER_LEFT
=
CLIP_ADAPTER_LEFT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_ADAPTER_RIGHT
=
CLIP_ADAPTER_RIGHT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_QUALITY_LEFT
=
CLIP_QUALITY_LEFT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_QUALITY_RIGHT
=
CLIP_QUALITY_RIGHT
;
}
database
NCBI
:
SRA
:
GenericFastqLogOdds
:
db
#1
{
table
NCBI
:
SRA
:
GenericFastq
:
sequence_log_odds
#1.0
SEQUENCE
;
}
;
table
NCBI
:
SRA
:
GenericFastq
:
sequence_nanopore
#1
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.4
{
ascii
platform_name
=
<
ascii
>
echo
<
"OXFORD_NANOPORE"
>
(
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_OXFORD_NANOPORE
>
(
)
;
NCBI
:
SRA
:
spot_name_token
out_spot_name_tok
=
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
(
_out_name
)
;
NCBI
:
SRA
:
spot_name_token
in_spot_name_tok
=
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
(
NAME
)
;
extern
column
<
U32
>
izip_encoding
#1
CHANNEL
;
extern
column
<
U32
>
izip_encoding
#1
READ_NUMBER
;
}
table
NCBI
:
SRA
:
GenericFastq
:
consensus_nanopore
#1
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.4
{
ascii
platform_name
=
<
ascii
>
echo
<
"OXFORD_NANOPORE"
>
(
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_OXFORD_NANOPORE
>
(
)
;
NCBI
:
SRA
:
spot_name_token
out_spot_name_tok
=
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
(
_out_name
)
;
NCBI
:
SRA
:
spot_name_token
in_spot_name_tok
=
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
(
NAME
)
;
extern
column
<
U32
>
izip_encoding
#1
CHANNEL
;
extern
column
<
U32
>
izip_encoding
#1
READ_NUMBER
;
}
database
NCBI
:
SRA
:
GenericFastqNanopore
:
db
#1
{
table
NCBI
:
SRA
:
GenericFastq
:
sequence_nanopore
#1.0
SEQUENCE
;
table
NCBI
:
SRA
:
GenericFastq
:
consensus_nanopore
#1.0
CONSENSUS
;
}
;
database
NCBI
:
SRA
:
GenericFastqNanoporeConsensusOnly
:
db
#1
{
table
NCBI
:
SRA
:
GenericFastq
:
consensus_nanopore
#1.0
CONSENSUS
;
}
;
table
NCBI
:
SRA
:
GenericFastq
:
absolid
#1
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
color_space
#2.1.0
,
NCBI
:
tbl
:
phred_quality
#2.0.4
,
NCBI
:
SRA
:
tbl
:
clip
#1.0.2
{
ascii
platform_name
=
<
ascii
>
echo
<
"UNDEFINED"
>
(
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_UNDEFINED
>
(
)
;
NCBI
:
SRA
:
spot_name_token
out_spot_name_tok
=
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
(
_out_name
)
;
NCBI
:
SRA
:
spot_name_token
in_spot_name_tok
=
NCBI
:
SRA
:
GenericFastq
:
tokenize_spot_name
(
NAME
)
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_ADAPTER_LEFT
=
CLIP_ADAPTER_LEFT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_ADAPTER_RIGHT
=
CLIP_ADAPTER_RIGHT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_QUALITY_LEFT
=
CLIP_QUALITY_LEFT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_QUALITY_RIGHT
=
CLIP_QUALITY_RIGHT
;
}
database
NCBI
:
SRA
:
GenericFastqAbsolid
:
db
#1
{
table
NCBI
:
SRA
:
GenericFastq
:
absolid
#1.0
SEQUENCE
;
}
;
version
1
;
include
'ncbi/sra.vschema';
include
'ncbi/spotname.vschema';
include
'ncbi/clip.vschema';
typeset
NCBI
:
SRA
:
_454_
:
drdparam_set
{
ascii
,
U8
,
INSDC
:
2
na
:
packed
}
;
extern
function
U32
[
3
]
NCBI
:
SRA
:
_454_
:
dynamic_read_desc
#1
<
*
U32
edit_distance
>
(
NCBI
:
SRA
:
_454_
:
drdparam_set
spot
,
NCBI
:
SRA
:
_454_
:
drdparam_set
key
*
NCBI
:
SRA
:
_454_
:
drdparam_set
linker
)
;
const
U32
NCBI
:
SRA
:
_454_
:
dyn_read_type
=
0
;
const
U32
NCBI
:
SRA
:
_454_
:
dyn_read_start
=
1
;
const
U32
NCBI
:
SRA
:
_454_
:
dyn_read_len
=
2
;
extern
function
NCBI
:
SRA
:
spot_name_token
NCBI
:
SRA
:
_454_
:
tokenize_spot_name
#1
(
ascii
name
)
;
table
NCBI
:
SRA
:
_454_
:
common
#1.0.4
=
INSDC
:
SRA
:
tbl
:
sra
#1.0.3
,
NCBI
:
SRA
:
tbl
:
clip
#1.0.2
{
ascii
platform_name
=
<
ascii
>
echo
<
"454"
>
(
)
;
column
INSDC
:
dna
:
text
FLOW_CHARS
=
out_flow_chars
;
INSDC
:
dna
:
text
in_flow_chars
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'acgtn.', 'ACGTNN' > ( FLOW_CHARS );
column
INSDC
:
dna
:
text
KEY_SEQUENCE
=
out_key_sequence
;
INSDC
:
dna
:
text
in_key_sequence
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'acgtn.', 'ACGTNN' > ( KEY_SEQUENCE );
column
INSDC
:
dna
:
text
LINKER_SEQUENCE
=
out_linker_sequence
;
INSDC
:
dna
:
text
in_linker_sequence
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'acgtn.', 'ACGTNN' > ( LINKER_SEQUENCE );
INSDC
:
x2na
:
bin
out_flow_bin
=
<
INSDC
:
dna
:
text
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
CHARSET
,
INSDC
:
x2na
:
map
:
BINSET
>
(
out_flow_chars
)
;
INSDC
:
x2na
:
bin
out_key_bin
=
<
INSDC
:
dna
:
text
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
CHARSET
,
INSDC
:
x2na
:
map
:
BINSET
>
(
out_key_sequence
)
;
INSDC
:
x2na
:
bin
out_linker_bin
=
<
INSDC
:
dna
:
text
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
CHARSET
,
INSDC
:
x2na
:
map
:
BINSET
>
(
out_linker_sequence
)
;
column
NCBI
:
isamp1
SIGNAL
=
out_signal
;
NCBI
:
isamp1
out_signal
=
.
SIGNAL
;
}
;
physical
INSDC
:
coord
:
one
NCBI
:
SRA
:
_454_
:
encoding
:
CLIP
#2
{
decode
{
return
(
INSDC
:
coord
:
one
)
iunzip
(
@
)
;
}
encode
{
return
izip
(
@
)
;
}
}
physical
NCBI
:
isamp1
NCBI
:
SRA
:
_454_
:
encoding
:
SIGNAL
#2
{
decode
{
return
(
NCBI
:
isamp1
)
iunzip
(
@
)
;
}
encode
{
return
izip
(
@
)
;
}
}
physical
INSDC
:
position
:
one
NCBI
:
SRA
:
_454_
:
encoding
:
POSITION
#2
{
decode
{
I32
pos_1st_deriv
=
iunzip
(
@
)
;
return
(
INSDC
:
position
:
one
)
<
I32
>
integral
(
pos_1st_deriv
)
;
}
encode
{
I32
pos_1st_deriv
=
<
I32
>
deriv
(
@
)
;
return
izip
(
pos_1st_deriv
)
;
}
}
table
NCBI
:
SRA
:
_454_
:
tbl
:
v2
#1.0.7
=
NCBI
:
SRA
:
tbl
:
sra_nopos
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.3
,
NCBI
:
SRA
:
_454_
:
common
#1.0.4
{
readonly
column
INSDC
:
coord
:
val
REGION
=
(
INSDC
:
coord
:
val
)
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
T
>
(
_out_name
,
out_spot_name_tok
)
;
NCBI
:
SRA
:
spot_name_token
out_spot_name_tok
=
NCBI
:
SRA
:
_454_
:
tokenize_spot_name
(
_out_name
)
;
NCBI
:
SRA
:
spot_name_token
in_spot_name_tok
=
NCBI
:
SRA
:
_454_
:
tokenize_spot_name
(
NAME
)
;
INSDC
:
dna
:
text
out_flow_chars
=
.
FLOW_CHARS
|
<
INSDC
:
dna
:
text
>
echo
<
'TACG' > ( .SIGNAL )
|
<
INSDC
:
dna
:
text
>
echo
<
'TACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACG' > ();
physical
column
<
INSDC
:
dna
:
text
>
zip_encoding
.
FLOW_CHARS
=
in_flow_chars
;
INSDC
:
dna
:
text
out_key_sequence
=
.
KEY_SEQUENCE
|
<
INSDC
:
dna
:
text
>
echo
<
'TCAG' > ();
physical
column
<
INSDC
:
dna
:
text
>
zip_encoding
.
KEY_SEQUENCE
=
in_key_sequence
;
INSDC
:
dna
:
text
out_linker_sequence
=
.
LINKER_SEQUENCE
;
physical
column
<
INSDC
:
dna
:
text
>
zip_encoding
.
LINKER_SEQUENCE
=
in_linker_sequence
;
INSDC
:
position
:
one
out_position
=
.
POSITION
;
physical
column
NCBI
:
SRA
:
_454_
:
encoding
:
POSITION
#2
.
POSITION
=
POSITION
;
physical
column
NCBI
:
SRA
:
_454_
:
encoding
:
CLIP
#2
.
CLIP_ADAPTER_LEFT
=
CLIP_ADAPTER_LEFT
;
physical
column
NCBI
:
SRA
:
_454_
:
encoding
:
CLIP
#2
.
CLIP_ADAPTER_RIGHT
=
CLIP_ADAPTER_RIGHT
;
physical
column
NCBI
:
SRA
:
_454_
:
encoding
:
CLIP
#2
.
CLIP_QUALITY_LEFT
=
CLIP_QUALITY_LEFT
;
physical
column
NCBI
:
SRA
:
_454_
:
encoding
:
CLIP
#2
.
CLIP_QUALITY_RIGHT
=
CLIP_QUALITY_RIGHT
;
physical
column
NCBI
:
SRA
:
_454_
:
encoding
:
SIGNAL
#2
.
SIGNAL
=
SIGNAL
;
}
;
version
1
;
include
'insdc/sra.vschema';
include
'ncbi/sra.vschema';
table
NCBI
:
SRA
:
Nanopore
:
consensus
#1
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.3
{
extern
column
<
U32
>
izip_encoding
#1
CHANNEL
;
extern
column
<
U32
>
izip_encoding
#1
READ_NUMBER
;
extern
column
bool_encoding
#1
HIGH_QUALITY
;
ascii
platform_name
=
<
ascii
>
echo
<
"OXFORD_NANOPORE"
>
(
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_OXFORD_NANOPORE
>
(
)
;
}
table
NCBI
:
SRA
:
Nanopore
:
sequence
#1
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.3
{
extern
column
<
U32
>
izip_encoding
#1
CHANNEL
;
extern
column
<
U32
>
izip_encoding
#1
READ_NUMBER
;
ascii
platform_name
=
<
ascii
>
echo
<
"OXFORD_NANOPORE"
>
(
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_OXFORD_NANOPORE
>
(
)
;
}
database
NCBI
:
SRA
:
Nanopore
:
db
#1
{
table
NCBI
:
SRA
:
Nanopore
:
sequence
#1.0
SEQUENCE
;
table
NCBI
:
SRA
:
Nanopore
:
consensus
#1.0
CONSENSUS
;
}
;
version
1
;
include
'ncbi/sra.vschema';
include
'ncbi/spotname.vschema';
typedef
INSDC
:
quality
:
log_odds
NCBI
:
qual4
[
4
]
;
typedef
NCBI
:
qual4
NCBI
:
SRA
:
rotated_qual4
,
NCBI
:
SRA
:
swapped_qual4
;
extern
function
NCBI
:
SRA
:
spot_name_token
NCBI
:
SRA
:
Illumina
:
tokenize_spot_name
#1
(
ascii
name
)
;
table
NCBI
:
SRA
:
Illumina
:
qual4_nocol
#1.0.1
=
INSDC
:
tbl
:
sequence
#1.0.1
,
NCBI
:
tbl
:
log_odds_quality_nocol
#1.0.1
{
readonly
column
NCBI
:
qual4
QUALITY
=
out_qual4
;
NCBI
:
qual4
out_qual4
=
<
NCBI
:
qual4
>
NCBI
:
SRA
:
swap
(
out_qual4_swapped
,
read_unpack
)
|
<
NCBI
:
qual4
>
NCBI
:
SRA
:
rotate
<
false
>
(
out_qual4_rotated
,
read_unpack
)
;
INSDC
:
quality
:
log_odds
out_qual1_ch0
=
<
INSDC
:
quality
:
log_odds
>
cut
<
0
>
(
out_qual4_swapped
)
|
<
INSDC
:
quality
:
log_odds
>
cut
<
0
>
(
out_qual4_rotated
)
;
INSDC
:
quality
:
log_odds
out_qual1_clip
=
<
INSDC
:
quality
:
log_odds
>
clip
<
-
5
,
127
>
(
out_qual1_ch0
)
;
U32
out_qual4_32
=
redimension
(
out_qual4_swapped
)
|
redimension
(
out_qual4_rotated
)
;
INSDC
:
quality
:
log_odds
out_qual1_fives
=
<
U32
,
INSDC
:
quality
:
log_odds
>
map
<
0xFBFBFBFB
,
-
6
>
(
out_qual4_32
,
out_qual1_clip
)
;
INSDC
:
quality
:
log_odds
out_qual1_n
=
<
U8
,
INSDC
:
quality
:
log_odds
>
map
<
[
1
,
2
,
3
]
,
[
0
,
0
,
0
]
>
(
read_unpack
,
out_qual1_fives
)
;
INSDC
:
quality
:
log_odds
out_qual_log_odds
=
<
INSDC
:
quality
:
log_odds
,
INSDC
:
quality
:
log_odds
>
map
<
-
6
,
-
6
>
(
out_qual1_n
,
out_qual1_clip
)
;
}
;
typedef
B8
NCBI
:
SRA
:
encoded_qual4
;
extern
function
NCBI
:
SRA
:
swapped_qual4
NCBI
:
SRA
:
qual4_decode
#1
(
NCBI
:
SRA
:
encoded_qual4
in
)
;
extern
function
NCBI
:
SRA
:
encoded_qual4
NCBI
:
SRA
:
qual4_encode
#1
(
NCBI
:
SRA
:
swapped_qual4
in
)
;
physical
NCBI
:
SRA
:
swapped_qual4
NCBI
:
SRA
:
qual4_encoding
#1
{
encode
{
NCBI
:
SRA
:
encoded_qual4
encoded
=
NCBI
:
SRA
:
qual4_encode
(
@
)
;
return
zip
<
Z_RLE
,
Z_BEST_SPEED
>
(
encoded
)
;
}
decode
{
NCBI
:
SRA
:
encoded_qual4
unzipped
=
unzip
(
@
)
;
return
NCBI
:
SRA
:
qual4_decode
(
unzipped
)
;
}
}
table
NCBI
:
SRA
:
Illumina
:
qual4
#1.0.1
=
NCBI
:
SRA
:
Illumina
:
qual4_nocol
#1.0.1
{
NCBI
:
SRA
:
swapped_qual4
out_qual4_swapped
=
.
QUALITY
;
}
;
table
NCBI
:
SRA
:
Illumina
:
qual4
#2.1.0
=
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
log_odds_quality_nocol
#2.1.0
{
extern
column
NCBI
:
qual4
QUALITY
=
out_qual4
;
NCBI
:
SRA
:
swapped_qual4
in_qual4
=
(
NCBI
:
SRA
:
swapped_qual4
)
<
NCBI
:
qual4
>
NCBI
:
SRA
:
swap
(
QUALITY
,
in_x2na_bin
)
|
(
NCBI
:
SRA
:
swapped_qual4
)
<
NCBI
:
qual4
>
NCBI
:
SRA
:
swap
(
QUALITY
,
in_2na_bin
)
;
NCBI
:
qual4
out_qual4
=
<
NCBI
:
SRA
:
swapped_qual4
>
NCBI
:
SRA
:
swap
(
.
QUALITY
,
out_x2na_bin
)
;
physical
column
NCBI
:
SRA
:
qual4_encoding
.
QUALITY
=
in_qual4
;
NCBI
:
qual4
in_stats_qual
=
in_qual4
;
INSDC
:
quality
:
log_odds
in_qual_log_odds
=
<
INSDC
:
quality
:
log_odds
>
cut
<
0
>
(
in_qual4
)
;
INSDC
:
quality
:
log_odds
out_qual_log_odds
=
<
INSDC
:
quality
:
log_odds
>
cut
<
0
>
(
.
QUALITY
)
;
}
;
table
NCBI
:
SRA
:
Illumina
:
common
#1.0.3
=
INSDC
:
SRA
:
tbl
:
sra
#1.0.3
{
ascii
platform_name
=
<
ascii
>
echo
<
"ILLUMINA"
>
(
)
;
INSDC
:
coord
:
zero
bio_start
=
NCBI
:
SRA
:
bio_start
(
out_read_start
,
out_read_type
)
;
INSDC
:
coord
:
zero
trim_start
=
bio_start
;
U32
trim_left
=
(
U32
)
trim_start
;
INSDC
:
coord
:
len
trim_len
=
(
INSDC
:
coord
:
len
)
<
U32
>
diff
(
spot_len
,
trim_left
)
;
readonly
column
INSDC
:
coord
:
val
LANE
=
out_lane_coord
;
readonly
column
INSDC
:
coord
:
val
TILE
=
out_tile_coord
;
}
;
physical
NCBI
:
SRA
:
swapped_fsamp4
NCBI
:
SRA
:
Illumina
:
encoding
:
SIGNAL
#2
{
decode
{
return
NCBI
:
SRA
:
fsamp4
:
decode
#2
(
@
)
;
}
encode
{
return
NCBI
:
SRA
:
fsamp4
:
encode
#2
<
14
,
10
>
(
@
)
;
}
}
physical
NCBI
:
fsamp4
NCBI
:
SRA
:
Illumina
:
encoding
:
NOISE
#2
{
decode
{
F32
dcmp
=
funzip
(
@
)
;
return
redimension
(
dcmp
)
;
}
encode
{
F32
ncmp
=
redimension
(
@
)
;
return
fzip
<
10
>
(
ncmp
)
;
}
}
physical
NCBI
:
SRA
:
swapped_fsamp4
NCBI
:
SRA
:
Illumina
:
encoding
:
INTENSITY
#2
{
decode
{
return
NCBI
:
SRA
:
fsamp4
:
decode
#2
(
@
)
;
}
encode
{
return
NCBI
:
SRA
:
fsamp4
:
encode
#2
<
14
,
10
>
(
@
)
;
}
}
table
NCBI
:
SRA
:
Illumina
:
tbl
:
v2
#1.0.4
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
SRA
:
Illumina
:
common
#1.0.3
{
INSDC
:
coord
:
val
out_lane_coord
=
(
INSDC
:
coord
:
val
)
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
L
>
(
_out_name
,
out_spot_name_tok
)
;
INSDC
:
coord
:
val
out_tile_coord
=
(
INSDC
:
coord
:
val
)
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
T
>
(
_out_name
,
out_spot_name_tok
)
;
NCBI
:
SRA
:
spot_name_token
out_spot_name_tok
=
NCBI
:
SRA
:
Illumina
:
tokenize_spot_name
(
_out_name
)
;
NCBI
:
SRA
:
spot_name_token
in_spot_name_tok
=
NCBI
:
SRA
:
Illumina
:
tokenize_spot_name
(
NAME
)
;
extern
column
NCBI
:
fsamp4
SIGNAL
{
read
=
out_signal
;
validate
=
<
NCBI
:
fsamp4
>
no_compare
#1
(
in_signal
,
out_signal
)
;
}
NCBI
:
fsamp4
in_signal
=
SIGNAL
;
NCBI
:
fsamp4
out_signal
=
<
NCBI
:
SRA
:
swapped_fsamp4
>
NCBI
:
SRA
:
swap
(
.
SIGNAL
,
out_x2na_bin
)
;
physical
column
NCBI
:
SRA
:
Illumina
:
encoding
:
SIGNAL
#2
.
SIGNAL
=
(
NCBI
:
SRA
:
swapped_fsamp4
)
<
NCBI
:
fsamp4
>
NCBI
:
SRA
:
swap
(
in_signal
,
in_x2na_bin
)
|
(
NCBI
:
SRA
:
swapped_fsamp4
)
<
NCBI
:
fsamp4
>
NCBI
:
SRA
:
swap
(
in_signal
,
in_2na_bin
)
;
extern
column
NCBI
:
fsamp4
NOISE
{
read
=
out_noise
;
validate
=
<
NCBI
:
fsamp4
>
no_compare
#1
(
in_noise
,
out_noise
)
;
}
NCBI
:
fsamp4
in_noise
=
NOISE
;
NCBI
:
fsamp4
out_noise
=
.
NOISE
;
physical
column
NCBI
:
SRA
:
Illumina
:
encoding
:
NOISE
#2
.
NOISE
=
in_noise
;
extern
column
NCBI
:
fsamp4
INTENSITY
{
read
=
out_intensity
;
validate
=
<
NCBI
:
fsamp4
>
no_compare
#1
(
in_intensity
,
out_intensity
)
;
}
NCBI
:
fsamp4
in_intensity
=
INTENSITY
;
NCBI
:
fsamp4
out_intensity
=
<
NCBI
:
fsamp4
>
NCBI
:
SRA
:
denormalize
(
out_norm_intensity
,
out_x2na_bin
)
;
NCBI
:
fsamp4
out_norm_intensity
=
(
NCBI
:
fsamp4
)
<
NCBI
:
SRA
:
swapped_fsamp4
>
NCBI
:
SRA
:
swap
(
.
INTENSITY
,
out_x2na_bin
)
;
NCBI
:
fsamp4
in_norm_intensity
=
<
NCBI
:
fsamp4
>
NCBI
:
SRA
:
normalize
(
in_intensity
,
in_x2na_bin
)
|
<
NCBI
:
fsamp4
>
NCBI
:
SRA
:
normalize
(
in_intensity
,
in_2na_bin
)
;
physical
column
NCBI
:
SRA
:
Illumina
:
encoding
:
INTENSITY
#2
.
INTENSITY
=
(
NCBI
:
SRA
:
swapped_fsamp4
)
<
NCBI
:
fsamp4
>
NCBI
:
SRA
:
swap
(
in_norm_intensity
,
in_x2na_bin
)
|
(
NCBI
:
SRA
:
swapped_fsamp4
)
<
NCBI
:
fsamp4
>
NCBI
:
SRA
:
swap
(
in_norm_intensity
,
in_2na_bin
)
;
}
;
table
NCBI
:
SRA
:
Illumina
:
tbl
:
q4
:
v2
#1.1.0
=
NCBI
:
SRA
:
Illumina
:
tbl
:
v2
#1.0.4
,
NCBI
:
SRA
:
Illumina
:
qual4
#2.1.0
{
}
;
table
NCBI
:
SRA
:
Illumina
:
tbl
:
q1
:
v2
#1.1
=
NCBI
:
SRA
:
Illumina
:
tbl
:
v2
#1.0.4
,
NCBI
:
tbl
:
log_odds_quality
#2.1.0
{
}
;
table
NCBI
:
SRA
:
Illumina
:
tbl
:
phred
:
v2
#1.0.4
=
NCBI
:
SRA
:
Illumina
:
tbl
:
v2
#1.0.4
,
NCBI
:
tbl
:
phred_quality
#2.0.3
{
}
;
version
1
;
include
'vdb/vdb.vschema';
typedef
U8
INSDC
:
phred
;
typedef
ascii
INSDC
:
event
:
text
;
const
INSDC
:
event
:
text
INSDC
:
event
:
CHARSET
=
"ACGT0123B+-"
;
const
INSDC
:
event
:
text
INSDC
:
event
:
ACCEPTSET
=
"ACGTacgt0123B+-"
;
extern
function
<
U32
dim
>
U32
NCBI
:
SRA
:
sort_order
#1.0
(
F32
[
dim
]
likelihoods
)
;
extern
function
<
U32
dim
>
F32
NCBI
:
SRA
:
reorder
#1.0
(
U32
sort_order
,
F32
[
dim
]
likelihoods
)
;
extern
function
<
U32
dim
>
F32
NCBI
:
SRA
:
restore_order
#1.0
(
U32
sort_order
,
F32
[
dim
]
likelihoods
)
;
extern
function
<
U32
sdim
,
U32
rdim
>
INSDC
:
phred
[
rdim
]
NCBI
:
SRA
:
likelihood_to_phred
#1.0
(
F32
like_scale
,
F32
[
sdim
]
likelihoods
)
;
extern
function
<
U32
sdim
,
U32
rdim
>
F32
[
rdim
]
NCBI
:
SRA
:
phred_to_likelihood
#1.0
(
F32
like_scale
,
F32
[
sdim
]
phred
)
;
table
NCBI
:
SRA
:
tbl
:
pevents
#1.0
{
extern
column
INSDC
:
event
:
text
PEVENTS
=
.
PEVENTS
;
physical
column
<
INSDC
:
event
:
text
>
zip_encoding
#1.0
.
PEVENTS
=
PEVENTS
;
extern
default
column
F32
[
4
]
LIKELIHOODS
=
likelihoods
;
extern
readonly
column
INSDC
:
phred
[
4
]
LIKELIHOODS
=
phred
;
U32
sort_encode
=
NCBI
:
SRA
:
sort_order
<
4
>
(
LIKELIHOODS
)
;
physical
column
<
U32
>
zip_encoding
#1.0
<
Z_RLE
>
.
SORT_ORDER
=
sort_encode
;
F32
reorder
=
NCBI
:
SRA
:
reorder
<
4
>
(
sort_encode
,
LIKELIHOODS
)
;
F32
like_scale
=
vdb
:
fixed_vec_sum
<
F32
,
4
>
(
reorder
)
;
physical
column
<
F32
>
fzip_encoding
#1.0
<
4
>
.
SCALE
=
like_scale
;
INSDC
:
phred
cut_phred
=
NCBI
:
SRA
:
likelihood_to_phred
#1.0
<
4
,
3
>
(
like_scale
,
reorder
)
;
physical
column
<
INSDC
:
phred
>
zip_encoding
#1.0
<
5
>
.
PHRED
=
cut_phred
;
extern
readonly
column
F32
LIKELIHOOD_NORM
=
.
SCALE
;
extern
readonly
column
INSDC
:
phred
[
4
]
PHRED
=
phred
;
}
;
version
1
;
include
'insdc/sra.vschema';
include
'ncbi/sra.vschema';
table
NCBI
:
SRA
:
PacBio
:
common
#1.0.3
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
{
}
table
NCBI
:
SRA
:
PacBio
:
smrt
:
fastq
#1.0.3
=
NCBI
:
SRA
:
PacBio
:
common
#1.0.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.3
{
ascii
platform_name
=
<
ascii
>
echo
<
"PACBIO_SMRT"
>
(
)
;
INSDC
:
coord
:
zero
bio_start
=
NCBI
:
SRA
:
bio_start
(
out_read_start
,
out_read_type
)
;
INSDC
:
coord
:
zero
trim_start
=
bio_start
;
U32
trim_left
=
(
U32
)
trim_start
;
INSDC
:
coord
:
len
trim_len
=
(
INSDC
:
coord
:
len
)
<
U32
>
diff
(
spot_len
,
trim_left
)
;
}
table
NCBI
:
SRA
:
PacBio
:
smrt
:
indelsubst
#1
{
column
<
U8
>
zip_encoding
INSERTION_QV
;
column
<
U8
>
zip_encoding
DELETION_QV
;
column
<
INSDC
:
dna
:
text
>
zip_encoding
DELETION_TAG
;
column
<
U8
>
zip_encoding
SUBSTITUTION_QV
;
column
<
INSDC
:
dna
:
text
>
zip_encoding
SUBSTITUTION_TAG
;
}
;
typedef
U8
PacBio
:
hole
:
status
;
const
PacBio
:
hole
:
status
PacBio
:
hole
:
SEQUENCING
=
0
;
const
PacBio
:
hole
:
status
PacBio
:
hole
:
ANTIHOLE
=
1
;
const
PacBio
:
hole
:
status
PacBio
:
hole
:
FIDUCIAL
=
2
;
const
PacBio
:
hole
:
status
PacBio
:
hole
:
SUSPECT
=
3
;
const
PacBio
:
hole
:
status
PacBio
:
hole
:
ANTIMIRROR
=
4
;
const
PacBio
:
hole
:
status
PacBio
:
hole
:
FDZMW
=
5
;
const
PacBio
:
hole
:
status
PacBio
:
hole
:
FBZMW
=
6
;
const
PacBio
:
hole
:
status
PacBio
:
hole
:
ANTIBEAMLET
=
7
;
const
PacBio
:
hole
:
status
PacBio
:
hole
:
OUTSIDEFOV
=
8
;
table
NCBI
:
SRA
:
PacBio
:
smrt
:
basecalls
#1.0.2
=
INSDC
:
SRA
:
tbl
:
spotcoord
#1
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.3
,
NCBI
:
SRA
:
PacBio
:
smrt
:
indelsubst
#1
{
ascii
platform_name
=
<
ascii
>
echo
<
"PACBIO_SMRT"
>
(
)
;
readonly
column
INSDC
:
dna
:
text
BASECALL
=
out_dna_text
;
readonly
column
INSDC
:
quality
:
phred
QUALITY_VALUE
=
out_qual_phred
;
column
<
U32
>
izip_encoding
HOLE_NUMBER
;
column
<
PacBio
:
hole
:
status
>
zip_encoding
HOLE_STATUS
;
column
<
ascii
>
zip_encoding
HOLE_STATUS_VALUE
;
column
<
INSDC
:
coord
:
len
>
izip_encoding
HOLE_STATUS_VALUE_LEN
;
column
I16
[
2
]
HOLE_XY
=
<
I16
>
paste
(
x_clip_I16
,
y_clip_I16
)
;
I16
x_clip_I16
=
cast
(
out_x_coord
)
;
I16
y_clip_I16
=
cast
(
out_y_coord
)
;
I16
in_x16_coord
=
<
I16
>
cut
<
0
>
(
HOLE_XY
)
;
I16
in_y16_coord
=
<
I16
>
cut
<
1
>
(
HOLE_XY
)
;
INSDC
:
coord
:
val
in_x_coord
=
cast
(
in_x16_coord
)
;
INSDC
:
coord
:
val
in_y_coord
=
cast
(
in_y16_coord
)
;
readonly
column
INSDC
:
coord
:
len
NUM_EVENT
=
base_space_spot_len
;
}
;
table
NCBI
:
SRA
:
PacBio
:
smrt
:
sequence
#1.0.2
=
NCBI
:
SRA
:
PacBio
:
smrt
:
basecalls
#1.0.2
,
NCBI
:
SRA
:
tbl
:
sra_nopos
#2.1.3
{
column
<
U16
>
izip_encoding
PRE_BASE_FRAMES
;
column
<
U16
>
izip_encoding
WIDTH_IN_FRAMES
;
default
column
INSDC
:
position
:
zero
PULSE_INDEX
=
.
PULSE_INDEX
;
readonly
column
INSDC
:
position
:
one
PULSE_INDEX
=
out_position
;
INSDC
:
position
:
one
out_position
=
(
INSDC
:
position
:
one
)
<
INSDC
:
position
:
zero
>
sum
<
1
>
(
.
PULSE_INDEX
)
;
column
NCBI
:
SRA
:
pos16
PULSE_INDEX
=
cast
(
.
PULSE_INDEX
)
;
NCBI
:
SRA
:
pos16
in_pulse_index16
=
PULSE_INDEX
;
INSDC
:
position
:
zero
in_pulse_index32
=
PULSE_INDEX
|
cast
(
in_pulse_index16
)
;
physical
column
<
INSDC
:
position
:
zero
>
izip_encoding
.
PULSE_INDEX
=
in_pulse_index32
;
extern
column
<
INSDC
:
coord
:
zero
>
izip_encoding
CLIP_QUALITY_LEFT
;
extern
column
<
INSDC
:
coord
:
one
>
izip_encoding
CLIP_QUALITY_RIGHT
;
INSDC
:
coord
:
zero
trim_start
=
.
CLIP_QUALITY_LEFT
|
NCBI
:
SRA
:
bio_start
(
out_read_start
,
out_read_type
)
;
U32
trim_right
=
(
U32
)
.
CLIP_QUALITY_RIGHT
|
spot_len
;
U32
trim_left
=
(
U32
)
trim_start
;
INSDC
:
coord
:
len
trim_len
=
(
INSDC
:
coord
:
len
)
<
U32
>
diff
(
trim_right
,
trim_left
)
;
}
;
table
NCBI
:
SRA
:
PacBio
:
smrt
:
cons
#1.0.2
=
NCBI
:
SRA
:
PacBio
:
smrt
:
basecalls
#1.0.2
,
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
{
column
<
I32
>
izip_encoding
NUM_PASSES
;
INSDC
:
coord
:
zero
trim_start
=
NCBI
:
SRA
:
bio_start
(
out_read_start
,
out_read_type
)
;
U32
trim_left
=
(
U32
)
trim_start
;
INSDC
:
coord
:
len
trim_len
=
(
INSDC
:
coord
:
len
)
<
U32
>
diff
(
spot_len
,
trim_left
)
;
}
;
physical
F32
[
4
]
NCBI
:
SRA
:
PacBio
:
smrt
:
F32_4ch_encoding
#1.0
<
U32
mantissa
>
{
decode
{
fzip_fmt
cmp0
=
split
<
0
>
(
@
)
;
fzip_fmt
cmp1
=
split
<
1
>
(
@
)
;
fzip_fmt
cmp2
=
split
<
2
>
(
@
)
;
fzip_fmt
cmp3
=
split
<
3
>
(
@
)
;
F32
ch0
=
funzip
(
cmp0
)
;
F32
ch1
=
funzip
(
cmp1
)
;
F32
ch2
=
funzip
(
cmp2
)
;
F32
ch3
=
funzip
(
cmp3
)
;
return
<
F32
>
paste
(
ch0
,
ch1
,
ch2
,
ch3
)
;
}
encode
{
F32
ch0
=
<
F32
>
cut
<
0
>
(
@
)
;
F32
ch1
=
<
F32
>
cut
<
1
>
(
@
)
;
F32
ch2
=
<
F32
>
cut
<
2
>
(
@
)
;
F32
ch3
=
<
F32
>
cut
<
3
>
(
@
)
;
fzip_fmt
cmp0
=
fzip
<
mantissa
>
(
ch0
)
;
fzip_fmt
cmp1
=
fzip
<
mantissa
>
(
ch1
)
;
fzip_fmt
cmp2
=
fzip
<
mantissa
>
(
ch2
)
;
fzip_fmt
cmp3
=
fzip
<
mantissa
>
(
ch3
)
;
return
merge
(
cmp0
,
cmp1
,
cmp2
,
cmp3
)
;
}
}
table
NCBI
:
SRA
:
PacBio
:
smrt
:
zmw_metrics
#1
{
column
NCBI
:
SRA
:
PacBio
:
smrt
:
F32_4ch_encoding
<
24
>
BASE_FRACTION
;
column
<
F32
>
fzip_encoding
<
24
>
BASE_IPD
;
column
<
F32
>
fzip_encoding
<
24
>
BASE_RATE
;
column
<
F32
>
fzip_encoding
<
24
>
BASE_WIDTH
;
column
NCBI
:
SRA
:
PacBio
:
smrt
:
F32_4ch_encoding
<
24
>
CHAN_BASE_QV
;
column
NCBI
:
SRA
:
PacBio
:
smrt
:
F32_4ch_encoding
<
24
>
CHAN_DEL_QV
;
column
NCBI
:
SRA
:
PacBio
:
smrt
:
F32_4ch_encoding
<
24
>
CHAN_INS_QV
;
column
NCBI
:
SRA
:
PacBio
:
smrt
:
F32_4ch_encoding
<
24
>
CHAN_SUB_QV
;
column
<
F32
>
fzip_encoding
<
24
>
LOCAL_BASE_RATE
;
column
<
F32
>
fzip_encoding
<
24
>
DARK_BASE_RATE
;
column
<
F32
>
fzip_encoding
<
24
>
HQ_RGN_START_TIME
;
column
<
F32
>
fzip_encoding
<
24
>
HQ_RGN_END_TIME
;
column
NCBI
:
SRA
:
PacBio
:
smrt
:
F32_4ch_encoding
<
24
>
HQ_RGN_SNR
;
column
<
I8
>
zip_encoding
PRODUCTIVITY
;
column
<
F32
>
fzip_encoding
<
24
>
READ_SCORE
;
column
<
F32
>
fzip_encoding
<
24
>
READ_BASE_QV
;
column
<
F32
>
fzip_encoding
<
24
>
READ_DEL_QV
;
column
<
F32
>
fzip_encoding
<
24
>
READ_INS_QV
;
column
<
F32
>
fzip_encoding
<
24
>
READ_SUB_QV
;
}
;
table
NCBI
:
SRA
:
PacBio
:
smrt
:
passes
#1
{
column
<
U8
>
zip_encoding
ADAPTER_HIT_BEFORE
;
column
<
U8
>
zip_encoding
ADAPTER_HIT_AFTER
;
column
<
U8
>
zip_encoding
PASS_DIRECTION
;
column
<
I32
>
izip_encoding
PASS_NUM_BASES
;
column
<
I32
>
izip_encoding
PASS_START_BASE
;
}
;
database
NCBI
:
SRA
:
PacBio
:
smrt
:
db
#1.0.1
{
table
NCBI
:
SRA
:
PacBio
:
smrt
:
sequence
#1.0
SEQUENCE
;
table
NCBI
:
SRA
:
PacBio
:
smrt
:
cons
#1.0
CONSENSUS
;
table
NCBI
:
SRA
:
PacBio
:
smrt
:
passes
#1.0
PASSES
;
table
NCBI
:
SRA
:
PacBio
:
smrt
:
zmw_metrics
#1.0
ZMW_METRICS
;
}
;
version
1
;
include
'ncbi/sra.vschema';
include
'ncbi/spotname.vschema';
extern
function
NCBI
:
SRA
:
spot_name_token
NCBI
:
SRA
:
ABI
:
tokenize_spot_name
#1
(
ascii
name
)
;
table
NCBI
:
SRA
:
ABI
:
common
#1.0.3
=
INSDC
:
SRA
:
tbl
:
sra
#1.0.3
{
ascii
platform_name
=
<
ascii
>
echo
<
"ABSOLID"
>
(
)
;
INSDC
:
coord
:
zero
bio_start
=
NCBI
:
SRA
:
bio_start
(
out_read_start
,
out_read_type
)
;
INSDC
:
coord
:
zero
trim_start
=
bio_start
;
U32
trim_left
=
(
U32
)
trim_start
;
INSDC
:
coord
:
len
trim_len
=
(
INSDC
:
coord
:
len
)
<
U32
>
diff
(
spot_len
,
trim_left
)
;
column
INSDC
:
coord
:
val
PANEL
=
out_panel_coord
;
column
NCBI
:
fsamp4
SIGNAL
=
out_signal
;
NCBI
:
fsamp4
out_signal
=
(
NCBI
:
fsamp4
)
<
NCBI
:
SRA
:
swapped_fsamp4
>
NCBI
:
SRA
:
swap
(
out_signal_swapped
,
out_x2cs_bin
)
;
}
;
physical
NCBI
:
SRA
:
swapped_fsamp4
NCBI
:
SRA
:
ABI
:
encoding
:
SIGNAL
#2
{
decode
{
return
NCBI
:
SRA
:
fsamp4
:
decode
#2
(
@
)
;
}
encode
{
return
NCBI
:
SRA
:
fsamp4
:
encode
#2
<
14
,
10
>
(
@
)
;
}
}
table
NCBI
:
SRA
:
ABI
:
tbl
:
v2
#1.0.4
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
color_space
#2.1.0
,
NCBI
:
tbl
:
phred_quality
#2.0.4
,
NCBI
:
SRA
:
ABI
:
common
#1.0.3
{
INSDC
:
coord
:
val
out_panel_coord
=
(
INSDC
:
coord
:
val
)
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
T
>
(
_out_name
,
out_spot_name_tok
)
;
NCBI
:
SRA
:
spot_name_token
out_spot_name_tok
=
NCBI
:
SRA
:
ABI
:
tokenize_spot_name
(
_out_name
)
;
NCBI
:
SRA
:
spot_name_token
in_spot_name_tok
=
NCBI
:
SRA
:
ABI
:
tokenize_spot_name
(
NAME
)
;
extern
column
NCBI
:
fsamp1
FTC
{
read
=
out_ftc
;
validate
=
<
F32
>
no_compare
#1
(
in_ftc
,
out_ftc
)
;
}
NCBI
:
fsamp1
in_ftc
=
FTC
;
NCBI
:
fsamp1
out_ftc
=
(
NCBI
:
fsamp1
)
<
F32
>
cut
<
0
>
(
out_signal
)
;
extern
column
NCBI
:
fsamp1
FAM
{
read
=
out_fam
;
validate
=
<
F32
>
no_compare
#1
(
in_fam
,
out_fam
)
;
}
NCBI
:
fsamp1
in_fam
=
FAM
;
NCBI
:
fsamp1
out_fam
=
(
NCBI
:
fsamp1
)
<
F32
>
cut
<
0
>
(
out_signal
)
;
extern
column
NCBI
:
fsamp1
CY3
{
read
=
out_cy3
;
validate
=
<
F32
>
no_compare
#1
(
in_cy3
,
out_cy3
)
;
}
NCBI
:
fsamp1
in_cy3
=
CY3
;
NCBI
:
fsamp1
out_cy3
=
(
NCBI
:
fsamp1
)
<
F32
>
cut
<
1
>
(
out_signal
)
;
extern
column
NCBI
:
fsamp1
TXR
{
read
=
out_txr
;
validate
=
<
F32
>
no_compare
#1
(
in_txr
,
out_txr
)
;
}
NCBI
:
fsamp1
in_txr
=
TXR
;
NCBI
:
fsamp1
out_txr
=
(
NCBI
:
fsamp1
)
<
F32
>
cut
<
2
>
(
out_signal
)
;
extern
column
NCBI
:
fsamp1
CY5
{
read
=
out_cy5
;
validate
=
<
F32
>
no_compare
#1
(
in_cy5
,
out_cy5
)
;
}
NCBI
:
fsamp1
in_cy5
=
CY5
;
NCBI
:
fsamp1
out_cy5
=
(
NCBI
:
fsamp1
)
<
F32
>
cut
<
3
>
(
out_signal
)
;
NCBI
:
fsamp4
in_signal
=
SIGNAL
|
(
NCBI
:
fsamp4
)
<
F32
>
paste
(
in_ftc
,
in_cy3
,
in_txr
,
in_cy5
)
|
(
NCBI
:
fsamp4
)
<
F32
>
paste
(
in_fam
,
in_cy3
,
in_txr
,
in_cy5
)
;
NCBI
:
SRA
:
swapped_fsamp4
out_signal_swapped
=
.
SIGNAL
;
physical
column
NCBI
:
SRA
:
ABI
:
encoding
:
SIGNAL
#2
.
SIGNAL
=
(
NCBI
:
SRA
:
swapped_fsamp4
)
<
NCBI
:
fsamp4
>
NCBI
:
SRA
:
swap
(
in_signal
,
in_x2cs_bin
)
|
(
NCBI
:
SRA
:
swapped_fsamp4
)
<
NCBI
:
fsamp4
>
NCBI
:
SRA
:
swap
(
in_signal
,
in_2cs_bin
)
;
}
;
version
1
;
include
'ncbi/sra.vschema';
include
'ncbi/spotname.vschema';
include
'ncbi/clip.vschema';
extern
function
NCBI
:
SRA
:
spot_name_token
NCBI
:
SRA
:
IonTorrent
:
tokenize_spot_name
#1
(
ascii
name
)
;
physical
INSDC
:
position
:
one
NCBI
:
SRA
:
IonTorrent
:
encoding
:
POSITION
#1
{
decode
{
I32
pos_1st_deriv
=
iunzip
(
@
)
;
return
(
INSDC
:
position
:
one
)
<
I32
>
integral
(
pos_1st_deriv
)
;
}
encode
{
I32
pos_1st_deriv
=
<
I32
>
deriv
(
@
)
;
return
izip
(
pos_1st_deriv
)
;
}
}
table
NCBI
:
SRA
:
IonTorrent
:
tbl
:
v2
#1.0.3
=
INSDC
:
SRA
:
tbl
:
sra
#1.0.3
,
NCBI
:
SRA
:
tbl
:
sra_nopos
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.3
,
NCBI
:
SRA
:
tbl
:
clip
#1.0.2
{
ascii
platform_name
=
<
ascii
>
echo
<
"ION_TORRENT"
>
(
)
;
NCBI
:
SRA
:
spot_name_token
out_spot_name_tok
=
NCBI
:
SRA
:
IonTorrent
:
tokenize_spot_name
(
_out_name
)
;
NCBI
:
SRA
:
spot_name_token
in_spot_name_tok
=
NCBI
:
SRA
:
IonTorrent
:
tokenize_spot_name
(
NAME
)
;
column
<
INSDC
:
dna
:
text
>
zip_encoding
FLOW_CHARS
;
column
<
INSDC
:
dna
:
text
>
zip_encoding
KEY_SEQUENCE
;
INSDC
:
position
:
one
out_position
=
.
POSITION
;
physical
column
NCBI
:
SRA
:
IonTorrent
:
encoding
:
POSITION
.
POSITION
=
POSITION
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_ADAPTER_LEFT
=
CLIP_ADAPTER_LEFT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_ADAPTER_RIGHT
=
CLIP_ADAPTER_RIGHT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_QUALITY_LEFT
=
CLIP_QUALITY_LEFT
;
physical
column
<
INSDC
:
coord
:
one
>
izip_encoding
.
CLIP_QUALITY_RIGHT
=
CLIP_QUALITY_RIGHT
;
column
<
NCBI
:
isamp1
>
izip_encoding
SIGNAL
;
}
;
version
1
;
include
'ncbi/sra.vschema';
include
'ncbi/spotname.vschema';
extern
function
NCBI
:
SRA
:
spot_name_token
NCBI
:
SRA
:
Helicos
:
tokenize_spot_name
#1
(
ascii
name
)
;
table
NCBI
:
SRA
:
Helicos
:
tbl
:
v2
#1.0.4
=
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.3
{
ascii
platform_name
=
<
ascii
>
echo
<
"HELICOS"
>
(
)
;
readonly
column
INSDC
:
coord
:
val
CHANNEL
=
(
INSDC
:
coord
:
val
)
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
L
>
(
_out_name
,
out_spot_name_tok
)
;
readonly
column
INSDC
:
coord
:
val
FIELD
=
(
INSDC
:
coord
:
val
)
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
T
>
(
_out_name
,
out_spot_name_tok
)
;
NCBI
:
SRA
:
spot_name_token
out_spot_name_tok
=
NCBI
:
SRA
:
Helicos
:
tokenize_spot_name
(
_out_name
)
;
readonly
column
INSDC
:
coord
:
val
CAMERA
=
out_x_coord
;
readonly
column
INSDC
:
coord
:
val
POS
=
out_y_coord
;
NCBI
:
SRA
:
spot_name_token
in_spot_name_tok
=
NCBI
:
SRA
:
Helicos
:
tokenize_spot_name
(
NAME
)
;
INSDC
:
coord
:
zero
trim_start
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
coord
:
len
trim_len
=
spot_len
;
}
;
version
1
;
include
'vdb/vdb.vschema';
include
'insdc/sra.vschema';
alias
text
:
token
NCBI
:
SRA
:
spot_name_token
;
const
U16
NCBI
:
SRA
:
name_token
:
unrecognized
=
1
;
const
U16
NCBI
:
SRA
:
name_token
:
recognized
=
2
;
const
U16
NCBI
:
SRA
:
name_token
:
Q
=
3
;
const
U16
NCBI
:
SRA
:
name_token
:
X
=
4
;
const
U16
NCBI
:
SRA
:
name_token
:
Y
=
5
;
const
U16
NCBI
:
SRA
:
name_token
:
T
=
6
;
const
U16
NCBI
:
SRA
:
name_token
:
L
=
7
;
const
U16
NCBI
:
SRA
:
name_token
:
signed
:
X
=
8
;
const
U16
NCBI
:
SRA
:
name_token
:
signed
:
Y
=
9
;
const
U16
NCBI
:
SRA
:
name_token
:
signed
:
T
=
10
;
const
U16
NCBI
:
SRA
:
name_token
:
signed
:
L
=
11
;
const
U16
NCBI
:
SRA
:
name_token
:
octal
:
X
=
12
;
const
U16
NCBI
:
SRA
:
name_token
:
octal
:
Y
=
13
;
const
U16
NCBI
:
SRA
:
name_token
:
octal
:
T
=
14
;
const
U16
NCBI
:
SRA
:
name_token
:
octal
:
L
=
15
;
const
U16
NCBI
:
SRA
:
name_token
:
hex
:
upper
:
X
=
16
;
const
U16
NCBI
:
SRA
:
name_token
:
hex
:
upper
:
Y
=
17
;
const
U16
NCBI
:
SRA
:
name_token
:
hex
:
upper
:
T
=
18
;
const
U16
NCBI
:
SRA
:
name_token
:
hex
:
upper
:
L
=
19
;
const
U16
NCBI
:
SRA
:
name_token
:
hex
:
lower
:
X
=
20
;
const
U16
NCBI
:
SRA
:
name_token
:
hex
:
lower
:
Y
=
21
;
const
U16
NCBI
:
SRA
:
name_token
:
hex
:
lower
:
T
=
22
;
const
U16
NCBI
:
SRA
:
name_token
:
hex
:
lower
:
L
=
23
;
const
ascii
NCBI
:
SRA
:
name_symbol
:
Q
=
'$Q';
const
ascii
NCBI
:
SRA
:
name_symbol
:
X
=
'$X';
const
ascii
NCBI
:
SRA
:
name_symbol
:
Y
=
'$Y';
const
ascii
NCBI
:
SRA
:
name_symbol
:
T
=
'$T';
const
ascii
NCBI
:
SRA
:
name_symbol
:
L
=
'$L';
const
ascii
NCBI
:
SRA
:
name_symbol
:
octal
:
X
=
'$a';
const
ascii
NCBI
:
SRA
:
name_symbol
:
octal
:
Y
=
'$b';
const
ascii
NCBI
:
SRA
:
name_symbol
:
octal
:
T
=
'$c';
const
ascii
NCBI
:
SRA
:
name_symbol
:
octal
:
L
=
'$d';
const
ascii
NCBI
:
SRA
:
name_symbol
:
hex
:
upper
:
X
=
'$e';
const
ascii
NCBI
:
SRA
:
name_symbol
:
hex
:
upper
:
Y
=
'$f';
const
ascii
NCBI
:
SRA
:
name_symbol
:
hex
:
upper
:
T
=
'$g';
const
ascii
NCBI
:
SRA
:
name_symbol
:
hex
:
upper
:
L
=
'$h';
const
ascii
NCBI
:
SRA
:
name_symbol
:
hex
:
lower
:
X
=
'$x';
const
ascii
NCBI
:
SRA
:
name_symbol
:
hex
:
lower
:
Y
=
'$y';
const
ascii
NCBI
:
SRA
:
name_symbol
:
hex
:
lower
:
T
=
'$t';
const
ascii
NCBI
:
SRA
:
name_symbol
:
hex
:
lower
:
L
=
'$l';
function
ascii
NCBI
:
SRA
:
extract_spot_name
#1
(
ascii
name
,
NCBI
:
SRA
:
spot_name_token
tok
)
;
function
ascii
NCBI
:
SRA
:
extract_name_fmt
#1
<
ascii
idx
>
(
ascii
name
,
NCBI
:
SRA
:
spot_name_token
tok
)
;
function
INSDC
:
coord
:
val
NCBI
:
SRA
:
extract_name_coord
#1
<
U16
coord
>
(
ascii
name
,
NCBI
:
SRA
:
spot_name_token
tok
)
;
function
INSDC
:
SRA
:
spot_ids_found
NCBI
:
SRA
:
lookup
#1.0
<
ascii
index_name
,
ascii
query_by_name
,
U8
name_fmt_version
>
(
*
ascii
name_prefix
)
;
table
NCBI
:
SRA
:
tbl
:
spotcoord
#1
=
INSDC
:
SRA
:
tbl
:
spotcoord
#1
{
INSDC
:
coord
:
val
out_x_coord
=
.
X
;
INSDC
:
coord
:
val
out_y_coord
=
.
Y
;
INSDC
:
coord
:
val
out_t_coord
=
.
T
;
INSDC
:
coord
:
val
out_l_coord
=
.
L
;
physical
column
<
INSDC
:
coord
:
val
>
izip_encoding
.
X
=
in_x_coord
|
in_name_x_coord
;
physical
column
<
INSDC
:
coord
:
val
>
izip_encoding
.
Y
=
in_y_coord
|
in_name_y_coord
;
physical
column
<
INSDC
:
coord
:
val
>
izip_encoding
.
T
=
in_t_coord
|
in_name_t_coord
;
physical
column
<
INSDC
:
coord
:
val
>
izip_encoding
.
L
=
in_l_coord
|
in_name_l_coord
;
}
;
table
NCBI
:
SRA
:
tbl
:
skeyname
#1.0.1
=
INSDC
:
SRA
:
tbl
:
spotname
#1.0.1
{
ascii
out_skey
=
(
ascii
)
idx
:
text
:
project
#1.0
<
'skey' > ();
ascii
out_spot_name
=
rewritten_spot_name
|
out_skey
;
INSDC
:
SRA
:
spot_ids_found
spot_ids_found
=
(
INSDC
:
SRA
:
spot_ids_found
)
NCBI
:
SRA
:
lookup
#1
<
'skey' , 'QUERY_BY_NAME', 1 > ( out_slx_prefix ) 
|
(
INSDC
:
SRA
:
spot_ids_found
)
NCBI
:
SRA
:
lookup
#1
<
'skey' , 'QUERY_BY_NAME', 0 > ();
}
;
table
NCBI
:
SRA
:
tbl
:
skeyname_nocol
#2.0.1
=
INSDC
:
SRA
:
tbl
:
spotname
#1.0.1
{
ascii
out_name_fmt
=
(
ascii
)
idx
:
text
:
project
#1.0
<
'skey' > ();
INSDC
:
SRA
:
spot_ids_found
spot_ids_found
=
(
INSDC
:
SRA
:
spot_ids_found
)
NCBI
:
SRA
:
lookup
#1
<
'skey' , 'QUERY_BY_NAME', 2 > ( out_slx_prefix ) 
|
(
INSDC
:
SRA
:
spot_ids_found
)
NCBI
:
SRA
:
lookup
#1
<
'skey' , 'QUERY_BY_NAME', 2 > ();
INSDC
:
coord
:
val
out_x_coord
=
cast
(
.
X
)
;
INSDC
:
coord
:
val
out_y_coord
=
cast
(
.
Y
)
;
}
;
table
NCBI
:
SRA
:
tbl
:
skeyname
#2.0.1
=
NCBI
:
SRA
:
tbl
:
skeyname_nocol
#2.0.1
{
physical
column
<
INSDC
:
coord
:
val
>
izip_encoding
#1
.
X
=
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
X
>
(
NAME
,
in_spot_name_tok
)
;
physical
column
<
INSDC
:
coord
:
val
>
izip_encoding
.
Y
=
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
Y
>
(
NAME
,
in_spot_name_tok
)
;
}
;
table
NCBI
:
SRA
:
tbl
:
skeyname
#3.0.1
=
INSDC
:
SRA
:
tbl
:
spotname
#1.0.1
,
NCBI
:
SRA
:
tbl
:
spotcoord
#1
{
ascii
out_spot_name
=
.
SPOT_NAME
;
ascii
out_name_fmt
=
(
ascii
)
idx
:
text
:
project
#1.0
<
'skey' > ( .NAME_FMT );
INSDC
:
SRA
:
spot_ids_found
spot_ids_found
=
(
INSDC
:
SRA
:
spot_ids_found
)
NCBI
:
SRA
:
lookup
#1
<
'skey' , 'QUERY_BY_NAME', 2 > ();
physical
column
<
ascii
>
zip_encoding
.
SPOT_NAME
=
NCBI
:
SRA
:
extract_spot_name
(
NAME
,
in_spot_name_tok
)
;
physical
column
<
ascii
>
zip_encoding
.
NAME_FMT
=
NCBI
:
SRA
:
extract_name_fmt
<
'skey' > ( NAME, in_spot_name_tok );
INSDC
:
coord
:
val
in_name_x_coord
=
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
X
>
(
NAME
,
in_spot_name_tok
)
;
INSDC
:
coord
:
val
in_name_y_coord
=
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
Y
>
(
NAME
,
in_spot_name_tok
)
;
INSDC
:
coord
:
val
in_name_t_coord
=
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
T
>
(
NAME
,
in_spot_name_tok
)
;
INSDC
:
coord
:
val
in_name_l_coord
=
NCBI
:
SRA
:
extract_name_coord
<
NCBI
:
SRA
:
name_token
:
L
>
(
NAME
,
in_spot_name_tok
)
;
}
;
version
1
;
include
'vdb/vdb.vschema';
include
'insdc/insdc.vschema';
typedef
INSDC
:
quality
:
phred
NCBI
:
quality
:
n_encoded
:
phred
;
typedef
INSDC
:
quality
:
log_odds
NCBI
:
quality
:
n_encoded
:
log_odds
;
alias
INSDC
:
dna
:
text
INSDC
:
fasta
;
alias
INSDC
:
4
na
:
packed
INSDC
:
dna
:
4
na
;
alias
INSDC
:
2
na
:
packed
INSDC
:
dna
:
2
na
;
alias
INSDC
:
2
na
:
packed
NCBI
:
2
na
;
alias
INSDC
:
2
cs
:
packed
INSDC
:
color
:
2
cs
;
alias
INSDC
:
2
cs
:
packed
NCBI
:
2
cs
;
alias
INSDC
:
quality
:
phred
NCBI
:
qual1
;
alias
NCBI
:
quality
:
n_encoded
:
phred
NCBI
:
SRA
:
enc_qual1
;
typedef
I16
NCBI
:
isamp1
;
typedef
F32
NCBI
:
fsamp1
,
NCBI
:
fsamp4
[
4
]
;
typedef
B8
NCBI
:
asn
:
binary
;
typedef
ascii
NCBI
:
asn
:
text
;
typedef
U64
NCBI
:
gi
;
typedef
U32
NCBI
:
taxid
;
typedef
U32
NCBI
:
gb_state
;
fmtdef
merged_t
;
fmtdef
fp_encoded_t
;
fmtdef
rl_encoded_t
;
fmtdef
NCBI
:
zlib_encoded_t
;
fmtdef
NCBI
:
fp_encoded_t
;
extern
function
merged_t
NCBI
:
merge
#1.0
(
any
in
,
...
)
;
extern
function
any
NCBI
:
split
#1.0
<
U32
idx
>
(
merged_t
in
)
=
vdb
:
split
;
extern
function
any
NCBI
:
cut
#1.0
<
U32
idx
,
...
>
(
any
in
)
=
vdb
:
cut
;
extern
function
any
NCBI
:
paste
#1.0
(
any
in
,
...
)
=
vdb
:
paste
;
extern
function
any
NCBI
:
pack
#1.0
<
U32
from
,
U32
to
>
(
any
in
)
;
extern
function
any
NCBI
:
unpack
#1.0
<
U32
from
,
U32
to
>
(
any
in
)
;
extern
function
any
NCBI
:
fp_decode
#1.0
(
fp_encoded_t
in
)
;
extern
function
any
NCBI
:
fp_extend
#1.0
<
U32
bits
>
(
NCBI
:
fp_encoded_t
in
)
;
extern
function
rl_encoded_t
NCBI
:
run_length_encode
#1.0
(
any
in
)
=
vdb
:
rlencode
;
extern
function
any
NCBI
:
run_length_decode
#1.0
(
rl_encoded_t
in
)
=
vdb
:
rldecode
;
extern
function
NCBI
:
zlib_encoded_t
NCBI
:
zlib
#1.0
<
*
I32
strategy
,
I32
level
>
(
any
in
)
=
vdb
:
zip
;
extern
function
any
NCBI
:
unzip
#1.0
(
NCBI
:
zlib_encoded_t
in
)
;
schema
function
NCBI
:
zlib_encoded_t
NCBI
:
zlib_huffman_compress
#1.0
(
any
in
)
{
return
NCBI
:
zlib
<
Z_RLE
>
(
in
)
;
}
schema
function
NCBI
:
zlib_encoded_t
NCBI
:
zlib_compress
#1.0
(
any
in
)
{
return
NCBI
:
zlib
<
Z_DEFAULT_STRATEGY
>
(
in
)
;
}
alias
NCBI
:
unzip
NCBI
:
zlib_decompress
;
version
1
;
include
'vdb/vdb.vschema';
typedef
utf8
NCBI
:
SeqGraph
:
sid
;
typedef
utf8
NCBI
:
SeqGraph
:
name
;
typedef
U32
NCBI
:
SeqGraph
:
len
;
typedef
U32
NCBI
:
SeqGraph
:
scale
;
typedef
I64
NCBI
:
SeqGraph
:
value
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
start
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_q0
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_q10
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_q50
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_q90
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_q100
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_zoom_q0
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_zoom_q10
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_zoom_q50
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_zoom_q90
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_zoom_q100
;
typedef
NCBI
:
SeqGraph
:
value
NCBI
:
SeqGraph
:
gr_num_switches
;
table
NCBI
:
SeqGraph
:
tbl
:
seqgraph
#1.0
{
extern
column
NCBI
:
SeqGraph
:
sid
SID
=
(
NCBI
:
SeqGraph
:
sid
)
idx
:
text
:
project
#1.0
<
'sid' > ( .SID );
physical
column
<
NCBI
:
SeqGraph
:
sid
>
zip_encoding
.
SID
=
(
NCBI
:
SeqGraph
:
sid
)
idx
:
text
:
insert
#1.0
<
'sid' > ( SID );
extern
column
NCBI
:
SeqGraph
:
name
NAME
=
(
NCBI
:
SeqGraph
:
name
)
idx
:
text
:
project
#1.0
<
'name' > ( .NAME );
physical
column
<
NCBI
:
SeqGraph
:
name
>
zip_encoding
.
NAME
=
(
NCBI
:
SeqGraph
:
name
)
idx
:
text
:
insert
#1.0
<
'name' > ( NAME );
extern
column
<
NCBI
:
SeqGraph
:
start
>
izip_encoding
START
;
extern
column
<
NCBI
:
SeqGraph
:
len
>
izip_encoding
LEN
;
extern
column
<
NCBI
:
SeqGraph
:
scale
>
izip_encoding
SCALE
;
extern
column
<
NCBI
:
SeqGraph
:
value
>
izip_encoding
GRAPH
;
extern
column
<
NCBI
:
SeqGraph
:
gr_q0
>
izip_encoding
GR_Q0
;
extern
column
<
NCBI
:
SeqGraph
:
gr_q10
>
izip_encoding
GR_Q10
;
extern
column
<
NCBI
:
SeqGraph
:
gr_q50
>
izip_encoding
GR_Q50
;
extern
column
<
NCBI
:
SeqGraph
:
gr_q90
>
izip_encoding
GR_Q90
;
extern
column
<
NCBI
:
SeqGraph
:
gr_q100
>
izip_encoding
GR_Q100
;
extern
column
<
NCBI
:
SeqGraph
:
gr_zoom_q0
>
izip_encoding
GR_ZOOM_Q0
;
extern
column
<
NCBI
:
SeqGraph
:
gr_zoom_q10
>
izip_encoding
GR_ZOOM_Q10
;
extern
column
<
NCBI
:
SeqGraph
:
gr_zoom_q50
>
izip_encoding
GR_ZOOM_Q50
;
extern
column
<
NCBI
:
SeqGraph
:
gr_zoom_q90
>
izip_encoding
GR_ZOOM_Q90
;
extern
column
<
NCBI
:
SeqGraph
:
gr_zoom_q100
>
izip_encoding
GR_ZOOM_Q100
;
extern
column
<
NCBI
:
SeqGraph
:
gr_num_switches
>
izip_encoding
NUM_SWITCHES
;
}
;
database
NCBI
:
SeqGraph
:
database
:
kmergraph
#1.0
{
table
NCBI
:
SeqGraph
:
tbl
:
seqgraph
#1.0
LEFT
;
table
NCBI
:
SeqGraph
:
tbl
:
seqgraph
#1.0
RIGHT
;
table
NCBI
:
SeqGraph
:
tbl
:
seqgraph
#1.0
SUM
;
}
version
1
;
include
'insdc/sra.vschema';
typeset
NCBI
:
SRA
:
stats
:
qual_type
{
INSDC
:
quality
:
phred
,
INSDC
:
quality
:
log_odds
,
INSDC
:
quality
:
log_odds
[
4
]
}
;
extern
function
U8
NCBI
:
SRA
:
stats_trigger
#1
(
U8
read_bin
,
U32
read_len
,
INSDC
:
SRA
:
xread_type
read_type
*
ascii
spot_group
)
;
extern
function
U8
NCBI
:
SRA
:
cmp_stats_trigger
#1
(
B8
cmp_read_bin
,
NCBI
:
SRA
:
stats
:
qual_type
qual_bin
,
U32
read_len
,
INSDC
:
SRA
:
xread_type
read_type
*
ascii
spot_group
)
;
extern
function
U8
NCBI
:
SRA
:
cmpf_stats_trigger
#1
(
B8
cmp_read_bin
,
U32
spot_len
,
U32
read_len
,
INSDC
:
SRA
:
xread_type
read_type
*
ascii
spot_group
)
;
extern
function
U8
NCBI
:
SRA
:
phred_stats_trigger
#1
(
INSDC
:
quality
:
phred
qual_bin
)
;
table
NCBI
:
SRA
:
tbl
:
stats
#1.2.0
=
INSDC
:
SRA
:
tbl
:
stats
#1.1
,
INSDC
:
SRA
:
tbl
:
sra
#1.0.3
{
INSDC
:
SRA
:
spotid_t
min_spot_id
=
<
INSDC
:
SRA
:
spotid_t
>
meta
:
value
<
"STATS/TABLE/SPOT_MIN"
>
(
)
;
INSDC
:
SRA
:
spotid_t
max_spot_id
=
<
INSDC
:
SRA
:
spotid_t
>
meta
:
value
<
"STATS/TABLE/SPOT_MAX"
>
(
)
;
U64
spot_count
=
<
U64
>
meta
:
value
<
"STATS/TABLE/SPOT_COUNT"
>
(
)
;
U64
base_count
=
<
U64
>
meta
:
value
<
"STATS/TABLE/BASE_COUNT"
>
(
)
;
U64
bio_base_count
=
<
U64
>
meta
:
value
<
"STATS/TABLE/BIO_BASE_COUNT"
>
(
)
;
U64
cmp_base_count
=
<
U64
>
meta
:
value
<
"STATS/TABLE/CMP_BASE_COUNT"
>
(
)
|
base_count
;
trigger
meta_stats
=
NCBI
:
SRA
:
stats_trigger
(
in_stats_bin
,
in_read_len
,
in_read_type
,
in_spot_group
)
|
NCBI
:
SRA
:
stats_trigger
(
in_stats_bin
,
in_read_len
,
in_read_type
)
|
NCBI
:
SRA
:
cmp_stats_trigger
(
in_cmp_stats_bin
,
in_stats_qual
,
in_read_len
,
in_read_type
,
in_spot_group
)
|
NCBI
:
SRA
:
cmp_stats_trigger
(
in_cmp_stats_bin
,
in_stats_qual
,
in_read_len
,
in_read_type
)
|
NCBI
:
SRA
:
cmpf_stats_trigger
(
in_cmp_stats_bin
,
in_spot_len
,
in_read_len
,
in_read_type
,
in_spot_group
)
|
NCBI
:
SRA
:
cmpf_stats_trigger
(
in_cmp_stats_bin
,
in_spot_len
,
in_read_len
,
in_read_type
)
;
trigger
qual_stats
=
NCBI
:
SRA
:
phred_stats_trigger
#1
(
in_qual_phred
)
;
}
;
version
1
;
include
'vdb/vdb.vschema';
include
'ncbi/ncbi.vschema';
include
'ncbi/seq.vschema';
include
'ncbi/spotname.vschema';
include
'ncbi/stats.vschema';
typedef
I16
NCBI
:
WGS
:
component_props
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
component
:
WGS
=
0
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
component
:
ActiveFinishing
=
1
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
component
:
DraftHTG
=
2
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
component
:
FinishedHTG
=
3
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
component
:
WholeGenomeFinishing
=
4
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
component
:
OtherSequence
=
5
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
component
:
PreDraft
=
6
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
strand
:
plus
=
16
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
strand
:
minus
=
32
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
gap
:
known
=
-
1
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
gap
:
unknown
=
-
2
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
gap
:
scaffold
=
-
4
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
gap
:
contig
=
-
8
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
gap
:
centromere
=
-
12
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
gap
:
short_arm
=
-
16
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
gap
:
heterochromatin
=
-
20
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
gap
:
telomere
=
-
24
;
const
NCBI
:
WGS
:
component_props
NCBI
:
WGS
:
gap
:
repeat
=
-
28
;
typedef
I32
NCBI
:
WGS
:
gap_linkage
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage
:
linked
=
1
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage_evidence
:
paired_ends
=
2
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage_evidence
:
align_genus
=
4
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage_evidence
:
align_xgenus
=
8
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage_evidence
:
align_trnscpt
=
16
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage_evidence
:
within_clone
=
32
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage_evidence
:
clone_contig
=
64
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage_evidence
:
map
=
128
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage_evidence
:
strobe
=
256
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage_evidence
:
unspecified
=
512
;
const
NCBI
:
WGS
:
gap_linkage
NCBI
:
WGS
:
gap
:
linkage_evidence
:
pcr
=
1024
;
extern
function
text
:
token
NCBI
:
WGS
:
tokenize_nuc_accession
#1
(
ascii
acc
)
;
extern
function
text
:
token
NCBI
:
WGS
:
tokenize_prot_accession
#1
(
ascii
acc
)
;
const
U16
NCBI
:
WGS
:
acc_token
:
unrecognized
=
1
;
const
U16
NCBI
:
WGS
:
acc_token
:
prefix
=
2
;
const
U16
NCBI
:
WGS
:
acc_token
:
contig
=
3
;
extern
function
INSDC
:
4
na
:
bin
NCBI
:
WGS
:
build_scaffold_read
#1
(
INSDC
:
coord
:
one
component_start
,
INSDC
:
coord
:
len
component_len
,
NCBI
:
WGS
:
component_props
component_props
,
I64
component_id
)
;
extern
function
INSDC
:
quality
:
phred
NCBI
:
WGS
:
build_scaffold_qual
#1
(
INSDC
:
coord
:
one
component_start
,
INSDC
:
coord
:
len
component_len
,
NCBI
:
WGS
:
component_props
component_props
,
I64
component_id
)
;
extern
function
INSDC
:
SRA
:
xread_type
NCBI
:
WGS
:
build_read_type
#1
(
NCBI
:
WGS
:
component_props
component_props
)
;
table
NCBI
:
WGS
:
tbl
:
nucleotide
#1.1
=
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.4
,
NCBI
:
SRA
:
tbl
:
stats
#1.2.0
{
extern
column
ascii
ACCESSION
=
out_accession
;
extern
column
U32
ACC_VERSION
=
.
ACC_VERSION
|
<
U32
>
echo
<
1
>
(
)
;
ascii
in_accession
=
ACCESSION
;
text
:
token
in_acc_token
=
NCBI
:
WGS
:
tokenize_nuc_accession
(
in_accession
)
;
ascii
in_acc_prefix
=
extract_token
<
0
>
(
in_accession
,
in_acc_token
)
;
ascii
in_contig_text
=
extract_token
<
1
>
(
in_accession
,
in_acc_token
)
;
U32
in_contig_len
=
row_len
(
in_contig_text
)
;
U64
in_contig_bin
=
strtonum
(
in_contig_text
)
;
physical
column
<
ascii
>
zip_encoding
.
ACC_PREFIX
=
in_acc_prefix
;
physical
column
<
U32
>
izip_encoding
.
ACC_CONTIG_LEN
=
in_contig_len
;
physical
column
<
U64
>
izip_encoding
.
ACC_CONTIG
=
in_contig_bin
;
physical
column
<
U32
>
izip_encoding
.
ACC_VERSION
=
ACC_VERSION
;
ascii
out_acc_prefix
=
.
ACC_PREFIX
|
<
ascii
>
meta
:
read
<
'ACC_PREFIX', true > ()
;
U32
out_acc_contig_len
=
.
ACC_CONTIG_LEN
|
<
U32
>
meta
:
value
<
'ACC_CONTIG_LEN', true > ()
;
U64
out_acc_contig
=
.
ACC_CONTIG
|
(
U64
)
row_id
(
)
;
ascii
out_accession
=
sprintf
<
"%s%0*u"
>
(
out_acc_prefix
,
out_acc_contig_len
,
out_acc_contig
)
;
readonly
column
ascii
ACC_PREFIX
=
.
ACC_PREFIX
|
<
ascii
>
meta
:
read
<
'ACC_PREFIX', true > ()
;
readonly
column
U32
ACC_CONTIG_LEN
=
.
ACC_CONTIG_LEN
|
<
U32
>
meta
:
value
<
'ACC_CONTIG_LEN', true > ()
;
extern
column
utf8
CONTIG_NAME
=
idx
:
text
:
project
#1.0
<
'contig_name' > ( .CONTIG_NAME );
physical
column
<
utf8
>
zip_encoding
.
CONTIG_NAME
=
idx
:
text
:
insert
#1.0
<
'contig_name' > ( CONTIG_NAME );
ascii
out_contig_name
=
cast
(
CONTIG_NAME
)
;
readonly
column
vdb
:
row_id_range
CONTIG_NAME_ROW_RANGE
=
idx
:
text
:
lookup
#1.0
<
'contig_name', 'NAME_QUERY' > ();
extern
column
<
ascii
>
zip_encoding
EXTRA_SEQIDS
;
extern
column
<
ascii
>
zip_encoding
TITLE
;
extern
column
<
NCBI
:
gi
>
izip_encoding
GI
;
extern
column
<
NCBI
:
taxid
>
izip_encoding
TAXID
;
extern
column
<
NCBI
:
gb_state
>
izip_encoding
GB_STATE
;
extern
column
<
NCBI
:
asn
:
binary
>
zip_encoding
DESCR
;
extern
column
<
NCBI
:
asn
:
binary
>
zip_encoding
ANNOT
;
extern
column
<
INSDC
:
coord
:
zero
>
izip_encoding
GAP_START
;
extern
column
<
INSDC
:
coord
:
len
>
izip_encoding
GAP_LEN
;
extern
column
<
NCBI
:
WGS
:
component_props
>
zip_encoding
GAP_PROPS
;
extern
column
<
NCBI
:
WGS
:
gap_linkage
>
zip_encoding
GAP_LINKAGE
;
ascii
out_seqid_gi
=
sprintf
<
"gi|%u"
>
(
.
GI
)
;
ascii
out_seqid_gb
=
sprintf
<
"gb|%s.%u|"
>
(
out_accession
,
ACC_VERSION
)
|
sprintf
<
"gb|%s.1|"
>
(
out_accession
)
;
ascii
out_seqid_gnl
=
sprintf
<
"gnl|WGS:%s|%s"
>
(
.
ACC_PREFIX
,
out_contig_name
)
|
<
ascii
>
echo
<
'' > ();
ascii
out_seqid_name
=
sprintf
<
"%s|%s"
>
(
out_seqid_gi
,
out_seqid_gb
)
|
sprintf
<
"%s"
>
(
out_seqid_gb
)
;
ascii
out_spot_name
=
sprintf
<
"%s %s"
>
(
out_seqid_name
,
.
TITLE
)
;
readonly
column
ascii
SEQ_ID
=
out_seqid_name
;
readonly
column
ascii
SEQ_ID_GNL
=
out_seqid_gnl
;
INSDC
:
coord
:
len
out_read_len
=
(
INSDC
:
coord
:
len
)
row_len
(
out_2na_bin
)
;
INSDC
:
coord
:
len
trim_len
=
(
INSDC
:
coord
:
len
)
row_len
(
out_2na_bin
)
;
INSDC
:
coord
:
zero
out_read_start
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
coord
:
zero
trim_start
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
SRA
:
read_filter
out_rd_filter
=
<
INSDC
:
SRA
:
read_filter
>
echo
<
SRA_READ_FILTER_PASS
>
(
)
;
INSDC
:
SRA
:
xread_type
out_read_type
=
<
INSDC
:
SRA
:
xread_type
>
echo
<
SRA_READ_TYPE_BIOLOGICAL
>
(
)
;
INSDC
:
SRA
:
xread_type
_alt_in_read_type
=
<
INSDC
:
SRA
:
xread_type
>
echo
<
SRA_READ_TYPE_BIOLOGICAL
>
(
)
;
INSDC
:
coord
:
len
_alt_in_read_len
=
(
INSDC
:
coord
:
len
)
row_len
(
in_2na_bin
)
;
ascii
out_label
=
<
ascii
>
echo
<
"contig"
>
(
)
;
INSDC
:
coord
:
len
out_label_len
=
<
INSDC
:
coord
:
len
>
echo
<
6
>
(
)
;
INSDC
:
coord
:
zero
out_label_start
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_UNDEFINED
>
(
)
;
}
;
table
NCBI
:
WGS
:
tbl
:
protein
#1
=
NCBI
:
tbl
:
protein
#1.0.0
{
extern
column
ascii
ACCESSION
=
out_accession
;
ascii
in_accession
=
ACCESSION
;
text
:
token
in_acc_token
=
NCBI
:
WGS
:
tokenize_prot_accession
(
in_accession
)
;
ascii
in_acc_prefix
=
extract_token
<
0
>
(
in_accession
,
in_acc_token
)
;
ascii
in_contig_text
=
extract_token
<
1
>
(
in_accession
,
in_acc_token
)
;
U32
in_contig_len
=
row_len
(
in_contig_text
)
;
I64
in_contig_bin
=
strtonum
(
in_contig_text
)
;
physical
column
<
ascii
>
zip_encoding
.
ACC_PREFIX
=
in_acc_prefix
;
physical
column
<
U32
>
izip_encoding
.
ACC_CONTIG_LEN
=
in_contig_len
;
physical
column
<
U64
>
izip_encoding
.
ACC_CONTIG
=
in_contig_bin
;
ascii
out_acc_prefix
=
.
ACC_PREFIX
|
<
ascii
>
meta
:
read
<
'ACC_PREFIX', true > ()
;
U32
out_acc_contig_len
=
.
ACC_CONTIG_LEN
|
<
U32
>
meta
:
value
<
'ACC_CONTIG_LEN', true > ()
;
U64
out_acc_contig
=
.
ACC_CONTIG
|
(
U64
)
row_id
(
)
;
ascii
out_accession
=
sprintf
<
"%s%0*u"
>
(
out_acc_prefix
,
out_acc_contig_len
,
out_acc_contig
)
;
extern
column
<
ascii
>
zip_encoding
TITLE
;
extern
column
<
NCBI
:
gi
>
izip_encoding
GI
;
extern
column
<
NCBI
:
gb_state
>
izip_encoding
GB_STATE
;
extern
column
<
NCBI
:
asn
:
binary
>
zip_encoding
DESCR
;
extern
column
<
NCBI
:
asn
:
binary
>
zip_encoding
ANNOT
;
ascii
out_seqid_name
=
sprintf
<
"TBD"
>
(
.
ACC_PREFIX
,
out_accession
)
;
ascii
out_spot_name
=
sprintf
<
"%s %s"
>
(
out_seqid_name
,
.
TITLE
)
;
}
;
table
NCBI
:
WGS
:
tbl
:
gi_idx
#1
{
extern
column
<
I64
>
izip_encoding
NUC_ROW_ID
;
extern
column
<
I64
>
izip_encoding
PROT_ROW_ID
;
}
;
table
NCBI
:
WGS
:
tbl
:
scaffold
#1
{
extern
column
utf8
SCAFFOLD_NAME
=
out_scaffold_name
;
extern
column
ascii
SCAFFOLD_NAME
=
cast
(
out_scaffold_name
)
;
utf8
out_scaffold_name
=
idx
:
text
:
project
#1.0
<
'scaffold_name' > ( .SCAFFOLD_NAME );
physical
column
<
utf8
>
zip_encoding
.
SCAFFOLD_NAME
=
idx
:
text
:
insert
#1.0
<
'scaffold_name' > ( SCAFFOLD_NAME );
extern
column
<
INSDC
:
coord
:
one
>
izip_encoding
COMPONENT_START
;
extern
column
<
INSDC
:
coord
:
len
>
izip_encoding
COMPONENT_LEN
;
extern
column
<
NCBI
:
WGS
:
component_props
>
zip_encoding
COMPONENT_PROPS
;
extern
column
<
I64
>
izip_encoding
COMPONENT_ID
;
extern
column
<
NCBI
:
WGS
:
gap_linkage
>
zip_encoding
COMPONENT_LINKAGE
;
}
table
NCBI
:
WGS
:
view
:
scaffold
#1
=
NCBI
:
WGS
:
tbl
:
scaffold
#1
{
readonly
column
ascii
ACCESSION
=
out_accession
;
I64
scaffold_row_id
=
row_id
(
)
;
I64
acc_row_id
=
<
I64
>
echo
<
1
>
(
)
;
ascii
acc_prefix
=
<
ascii
>
simple_sub_select
<
'SEQUENCE', 'ACC_PREFIX' > ( acc_row_id );
U32
acc_contig_len
=
<
U32
>
simple_sub_select
<
'SEQUENCE', 'ACC_CONTIG_LEN' > ( acc_row_id );
ascii
out_accession
=
sprintf
<
"%sS%0*d"
>
(
acc_prefix
,
acc_contig_len
,
scaffold_row_id
)
;
INSDC
:
4
na
:
bin
out_4na_bin
=
NCBI
:
WGS
:
build_scaffold_read
(
.
COMPONENT_START
,
.
COMPONENT_LEN
,
.
COMPONENT_PROPS
,
.
COMPONENT_ID
)
;
default
readonly
column
INSDC
:
dna
:
text
READ
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_4na_bin
)
;
readonly
column
INSDC
:
4
na
:
bin
READ
=
out_4na_bin
;
readonly
column
INSDC
:
4
na
:
packed
READ
=
pack
(
out_4na_bin
)
;
readonly
column
INSDC
:
x2na
:
bin
READ
=
out_x2na_bin
;
INSDC
:
x2na
:
bin
out_x2na_bin
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
4
,
0
,
1
,
4
,
2
,
4
,
4
,
4
,
3
,
4
,
4
,
4
,
4
,
4
,
4
,
4
]
>
(
out_4na_bin
)
;
readonly
column
INSDC
:
2
na
:
bin
READ
=
out_2na_bin
;
INSDC
:
2
na
:
bin
out_2na_bin
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
2
na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
[
0
,
1
,
2
,
3
,
0
]
>
(
out_x2na_bin
)
;
readonly
column
INSDC
:
2
na
:
packed
READ
=
pack
(
out_2na_bin
)
;
default
readonly
column
INSDC
:
color
:
text
CSREAD
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
color
:
text
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
INSDC
:
x2cs
:
map
:
CHARSET
>
(
out_x2cs_bin
)
;
readonly
column
INSDC
:
x2cs
:
bin
CSREAD
=
out_x2cs_bin
;
INSDC
:
x2cs
:
bin
out_x2cs_bin
=
NCBI
:
color_from_dna
(
out_x2na_bin
,
out_read_start
,
.
COMPONENT_LEN
,
out_cs_key
,
out_color_matrix
)
;
readonly
column
INSDC
:
2
cs
:
bin
CSREAD
=
out_2cs_bin
;
INSDC
:
2
cs
:
bin
out_2cs_bin
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
2
cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
[
0
,
1
,
2
,
3
,
0
]
>
(
out_x2cs_bin
)
;
readonly
column
INSDC
:
2
cs
:
packed
CSREAD
=
pack
(
out_2cs_bin
)
;
readonly
column
bool
CS_NATIVE
=
<
bool
>
echo
<
false
>
(
)
;
readonly
column
INSDC
:
dna
:
text
CS_KEY
=
out_cs_key
;
INSDC
:
dna
:
text
out_cs_key
=
<
INSDC
:
dna
:
text
>
echo
<
'T' > ( .COMPONENT_LEN );
readonly
column
U8
COLOR_MATRIX
=
out_color_matrix
;
U8
out_color_matrix
=
<
U8
>
echo
<
INSDC
:
color
:
default_matrix
>
(
)
;
INSDC
:
quality
:
phred
out_qual_phred
=
NCBI
:
WGS
:
build_scaffold_qual
(
.
COMPONENT_START
,
.
COMPONENT_LEN
,
.
COMPONENT_PROPS
,
.
COMPONENT_ID
)
;
default
readonly
column
INSDC
:
quality
:
phred
QUALITY
=
out_qual_phred
;
readonly
column
INSDC
:
quality
:
text
:
phred_33
QUALITY
=
(
INSDC
:
quality
:
text
:
phred_33
)
<
B8
>
sum
<
33
>
(
out_qual_phred
)
;
readonly
column
INSDC
:
quality
:
text
:
phred_64
QUALITY
=
(
INSDC
:
quality
:
text
:
phred_64
)
<
B8
>
sum
<
64
>
(
out_qual_phred
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_UNDEFINED
>
(
)
;
readonly
column
INSDC
:
SRA
:
platform_id
PLATFORM
=
out_platform
;
INSDC
:
SRA
:
spotid_t
out_spot_id
=
cast
(
scaffold_row_id
)
;
readonly
column
INSDC
:
SRA
:
spotid_t
SPOT_ID
=
out_spot_id
;
readonly
column
ascii
NAME
=
out_scaffold_name
;
readonly
column
INSDC
:
coord
:
len
SPOT_LEN
=
out_spot_len
;
INSDC
:
coord
:
len
out_spot_len
=
<
INSDC
:
coord
:
len
>
vec_sum
(
.
COMPONENT_LEN
)
;
readonly
column
INSDC
:
coord
:
zero
TRIM_START
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
readonly
column
INSDC
:
coord
:
len
TRIM_LEN
=
out_spot_len
;
readonly
column
INSDC
:
coord
:
zero
READ_START
=
out_read_start
;
INSDC
:
coord
:
zero
out_read_start
=
(
INSDC
:
coord
:
zero
)
<
U32
>
integral
(
.
COMPONENT_LEN
)
;
readonly
column
INSDC
:
coord
:
len
READ_LEN
=
.
COMPONENT_LEN
;
readonly
column
INSDC
:
SRA
:
xread_type
READ_TYPE
=
out_read_type
;
INSDC
:
SRA
:
xread_type
out_read_type
=
NCBI
:
WGS
:
build_read_type
(
.
COMPONENT_PROPS
)
;
}
database
NCBI
:
WGS
:
db
:
contig
#1.1
{
table
NCBI
:
WGS
:
tbl
:
nucleotide
SEQUENCE
;
table
NCBI
:
WGS
:
tbl
:
protein
PROTEIN
;
table
NCBI
:
WGS
:
tbl
:
gi_idx
GI_IDX
;
table
NCBI
:
WGS
:
view
:
scaffold
SCAFFOLD
;
}
;
version
1
;
include
'vdb/vdb.vschema';
include
'insdc/insdc.vschema';
include
'ncbi/ncbi.vschema';
typedef
U8
NCBI
:
var
:
inst
:
type
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
unknown
=
0
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
identity
=
1
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
inv
=
2
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
snv
=
3
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
mnp
=
4
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
delins
=
5
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
del
=
6
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
ins
=
7
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
microsatellite
=
8
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
transposon
=
9
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
cnv
=
10
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
direct_copy
=
11
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
rev_direct_copy
=
12
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
inverted_copy
=
13
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
everted_copy
=
14
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
translocation
=
15
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
prot_missense
=
16
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
prot_nonsense
=
17
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
prot_neutral
=
18
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
prot_silent
=
19
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
prot_other
=
20
;
const
NCBI
:
var
:
inst
:
type
NCBI
:
var
:
inst
:
value
:
other
=
255
;
typedef
U8
NCBI
:
var
:
source
:
type
;
const
NCBI
:
var
:
source
:
type
NCBI
:
var
:
source
:
value
:
dbSNP
=
1
;
const
NCBI
:
var
:
source
:
type
NCBI
:
var
:
source
:
value
:
dbVar
=
2
;
const
NCBI
:
var
:
source
:
type
NCBI
:
var
:
source
:
value
:
ClinVar
=
3
;
const
NCBI
:
var
:
source
:
type
NCBI
:
var
:
source
:
value
:
other
=
10
;
extern
function
text
:
token
NCBI
:
var
:
tokenize_var_id
#1
(
ascii
var_id
)
;
table
NCBI
:
var
:
tbl
:
varloc
#1
{
extern
column
ascii
VAR_ID
=
out_var_id
;
ascii
in_var_id
=
VAR_ID
;
text
:
token
in_var_id_tok
=
NCBI
:
var
:
tokenize_var_id
(
in_var_id
)
;
ascii
in_var_id_prefix
=
extract_token
<
0
>
(
in_var_id
,
in_var_id_tok
)
;
ascii
in_var_id_suffix_text
=
extract_token
<
1
>
(
in_var_id
,
in_var_id_tok
)
;
U32
in_var_id_suffix
=
strtonum
(
in_var_id_suffix_text
)
;
physical
column
<
ascii
>
zip_encoding
.
VAR_ID_PREFIX
=
in_var_id_prefix
;
physical
column
<
U32
>
izip_encoding
.
VAR_ID_SUFFIX_LEN
=
row_len
(
in_var_id_suffix_text
)
;
physical
column
<
U32
>
izip_encoding
.
VAR_ID_SUFFIX
=
in_var_id_suffix
;
U32
out_var_id_suffix
=
.
VAR_ID_SUFFIX
;
U32
out_var_id_suffix_len
=
.
VAR_ID_SUFFIX_LEN
;
ascii
out_var_id_prefix
=
.
VAR_ID_PREFIX
;
ascii
out_var_id
=
sprintf
<
"%s%0*u"
>
(
out_var_id_prefix
,
out_var_id_suffix_len
,
out_var_id_suffix
)
;
extern
column
ascii
PARENT_VAR_ID
=
out_parent_var_id
;
ascii
in_parent_var_id
=
PARENT_VAR_ID
;
text
:
token
in_parent_var_id_tok
=
NCBI
:
var
:
tokenize_var_id
(
in_parent_var_id
)
;
ascii
in_parent_var_id_prefix
=
extract_token
<
0
>
(
in_parent_var_id
,
in_parent_var_id_tok
)
;
ascii
in_parent_var_id_suffix_text
=
extract_token
<
1
>
(
in_parent_var_id
,
in_parent_var_id_tok
)
;
U32
in_parent_var_id_suffix
=
strtonum
(
in_parent_var_id_suffix_text
)
;
physical
column
<
ascii
>
zip_encoding
.
PARENT_VAR_ID_PREFIX
=
in_parent_var_id_prefix
;
physical
column
<
U32
>
izip_encoding
.
PARENT_VAR_ID_SUFFIX_LEN
=
row_len
(
in_parent_var_id_suffix_text
)
;
physical
column
<
U32
>
izip_encoding
.
PARENT_VAR_ID_SUFFIX
=
in_parent_var_id_suffix
;
U32
out_parent_var_id_suffix
=
.
PARENT_VAR_ID_SUFFIX
;
U32
out_parent_var_id_suffix_len
=
.
PARENT_VAR_ID_SUFFIX_LEN
;
ascii
out_parent_var_id_prefix
=
.
PARENT_VAR_ID_PREFIX
;
ascii
out_parent_var_id
=
sprintf
<
"%s%.*u"
>
(
out_parent_var_id_prefix
,
out_parent_var_id_suffix_len
,
out_parent_var_id_suffix
)
;
extern
column
<
NCBI
:
var
:
inst
:
type
>
zip_encoding
VAR_TYPE
;
extern
column
<
NCBI
:
var
:
source
:
type
>
zip_encoding
VAR_SOURCE
;
extern
column
<
NCBI
:
gi
>
izip_encoding
GI
;
extern
column
<
INSDC
:
coord
:
zero
>
izip_encoding
POS_FROM
;
INSDC
:
coord
:
zero
in_pos_from
=
POS_FROM
;
INSDC
:
coord
:
zero
out_pos_from
=
.
POS_FROM
;
extern
column
INSDC
:
coord
:
zero
POS_TO
=
out_pos_to
;
INSDC
:
coord
:
zero
in_pos_to
=
POS_TO
;
INSDC
:
coord
:
len
in_pos_len
=
(
INSDC
:
coord
:
len
)
<
I32
>
diff
<
-
1
>
(
in_pos_to
,
in_pos_from
)
;
physical
column
<
INSDC
:
coord
:
len
>
izip_encoding
.
POS_LEN
=
in_pos_len
;
INSDC
:
coord
:
zero
out_pos_len
=
(
INSDC
:
coord
:
zero
)
.
POS_LEN
;
INSDC
:
coord
:
zero
out_pos_to
=
<
INSDC
:
coord
:
zero
>
sum
<
-
1
>
(
out_pos_from
,
out_pos_len
)
;
extern
column
<
I32
>
izip_encoding
ENTREZ_ID
;
extern
column
<
I32
>
izip_encoding
SCORE
;
}
;
table
NCBI
:
var
:
tbl
:
hitmap
#1
{
extern
column
U32
MAX_SEQ_LEN
;
extern
column
bool_encoding
HITS
;
}
;
database
NCBI
:
var
:
db
:
varloc
#1
{
table
NCBI
:
var
:
tbl
:
varloc
VARLOC
;
table
NCBI
:
var
:
tbl
:
hitmap
HITMAP
;
}
;
version
1
;
include
'vdb/vdb.vschema';
include
'ncbi/ncbi.vschema';
include
'insdc/sra.vschema';
table
NCBI
:
tbl
:
n_encoding
#1
{
U8
n_encoding_dummy
=
read_unpack
|
read_ndecode
;
}
;
table
NCBI
:
tbl
:
seqloc
#1.0
{
extern
column
<
ascii
>
zip_encoding
SEQ_ID
;
extern
default
column
<
INSDC
:
coord
:
one
>
izip_encoding
SEQ_START
;
readonly
column
INSDC
:
coord
:
zero
SEQ_START
=
(
INSDC
:
coord
:
zero
)
<
INSDC
:
coord
:
one
>
diff
<
1
>
(
.
SEQ_START
)
;
extern
column
<
INSDC
:
coord
:
len
>
izip_encoding
SEQ_LEN
;
}
;
extern
function
INSDC
:
x2cs
:
bin
NCBI
:
color_from_dna
#1
(
INSDC
:
x2na
:
bin
bin_x2na
,
INSDC
:
coord
:
zero
read_start
,
INSDC
:
coord
:
len
read_len
,
INSDC
:
dna
:
text
cs_key
,
U8
color_matrix
)
;
table
NCBI
:
tbl
:
dcmp_base_space
#1
{
INSDC
:
dna
:
text
dcmp_virtual_productions
=
out_dcmp_4na_bin
|
out_dcmp_x2na_bin
|
out_dcmp_2na_bin
|
out_dcmp_2na_packed
;
}
table
NCBI
:
tbl
:
base_space_common
#1.0.3
=
INSDC
:
tbl
:
sequence
#1.0.1
,
INSDC
:
SRA
:
tbl
:
spotdesc
#1.0.2
,
INSDC
:
SRA
:
tbl
:
stats
#1.1.0
,
NCBI
:
tbl
:
dcmp_base_space
#1.0.0
{
bool
cs_native
=
<
bool
>
echo
<
false
>
(
)
;
INSDC
:
dna
:
text
out_cs_key
=
.
CS_KEY
|
<
INSDC
:
dna
:
text
>
echo
<
'T' > ( out_read_type )
|
<
INSDC
:
dna
:
text
>
echo
<
'T' > ( out_read_len )
|
<
INSDC
:
dna
:
text
>
echo
<
'T' > ();
INSDC
:
2
cs
:
bin
out_2cs_bin
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
2
cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
[
0
,
1
,
2
,
3
,
0
]
>
(
out_x2cs_bin
)
;
INSDC
:
2
na
:
bin
out_2na_bin
=
out_dcmp_2na_bin
|
(
INSDC
:
2
na
:
bin
)
unpack
(
out_2na_packed
)
;
INSDC
:
x2cs
:
bin
out_x2cs_bin
=
NCBI
:
color_from_dna
(
out_x2na_bin
,
out_read_start
,
out_read_len
,
out_cs_key
,
out_color_matrix
)
;
INSDC
:
2
cs
:
packed
out_2cs_packed
=
(
INSDC
:
2
cs
:
packed
)
pack
(
out_2cs_bin
)
;
INSDC
:
4
na
:
packed
out_4na_packed
=
(
INSDC
:
4
na
:
packed
)
pack
(
out_4na_bin
)
;
INSDC
:
color
:
text
out_color_text
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
color
:
text
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
INSDC
:
x2cs
:
map
:
CHARSET
>
(
out_x2cs_bin
)
;
U8
out_color_matrix
=
<
U8
>
echo
<
INSDC
:
color
:
default_matrix
>
(
)
;
INSDC
:
coord
:
len
base_space_spot_len
=
(
INSDC
:
coord
:
len
)
row_len
(
out_2na_packed
)
;
INSDC
:
coord
:
len
base_space_fixed_spot_len
=
(
INSDC
:
coord
:
len
)
fixed_row_len
(
out_2na_packed
)
;
}
;
table
NCBI
:
tbl
:
base_space_nocol
#1.0.3
=
NCBI
:
tbl
:
base_space_common
#1.0.3
,
NCBI
:
tbl
:
n_encoding
#1
{
INSDC
:
dna
:
text
out_dna_text
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
INSDC
:
x2na
:
map
:
CHARSET
>
(
out_x2na_bin
)
;
INSDC
:
4
na
:
bin
out_4na_bin
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
[
1
,
2
,
4
,
8
,
15
]
>
(
out_x2na_bin
)
;
INSDC
:
x2na
:
bin
out_x2na_bin
=
(
INSDC
:
x2na
:
bin
)
read_ndecode
;
U8
read_unpack
=
out_2na_bin
;
}
;
table
NCBI
:
tbl
:
base_space
#1.0.3
=
NCBI
:
tbl
:
base_space_nocol
#1.0.3
{
INSDC
:
2
na
:
packed
out_2na_packed
=
.
READ
;
}
;
table
NCBI
:
tbl
:
base_space
#2.0.3
=
NCBI
:
tbl
:
base_space_common
#1.0.3
,
NCBI
:
tbl
:
dcmp_base_space
#1
{
INSDC
:
dna
:
text
in_dna_text
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'.acmgrsvtwyhkdbn','NACMGRSVTWYHKDBN' > ( READ );
INSDC
:
4
na
:
bin
in_4na_bin
=
<
INSDC
:
4
na
:
bin
>
range_validate
<
0
,
15
>
(
READ
)
|
(
INSDC
:
4
na
:
bin
)
unpack
(
in_4na_packed
)
|
<
INSDC
:
dna
:
text
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
CHARSET
,
INSDC
:
4
na
:
map
:
BINSET
>
(
in_dna_text
)
|
<
INSDC
:
x2na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
[
1
,
2
,
4
,
8
,
15
]
>
(
in_x2na_bin
)
;
INSDC
:
4
na
:
packed
in_4na_packed
=
READ
;
INSDC
:
x2na
:
bin
in_x2na_bin
=
<
INSDC
:
x2na
:
bin
>
range_validate
<
0
,
4
>
(
READ
)
|
<
INSDC
:
4
na
:
bin
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
4
,
0
,
1
,
4
,
2
,
4
,
4
,
4
,
3
,
4
,
4
,
4
,
4
,
4
,
4
,
4
]
>
(
in_4na_bin
)
;
INSDC
:
2
na
:
bin
in_2na_bin
=
<
INSDC
:
2
na
:
bin
>
range_validate
<
0
,
3
>
(
READ
)
|
(
INSDC
:
2
na
:
bin
)
unpack
(
in_2na_packed
)
|
INSDC
:
SEQ
:
rand_4na_2na
(
in_4na_bin
)
;
INSDC
:
2
na
:
packed
in_2na_packed
=
READ
;
INSDC
:
4
na
:
bin
in_alt_4na_bin
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
15
,
0
,
0
,
3
,
0
,
5
,
6
,
7
,
0
,
9
,
10
,
11
,
12
,
13
,
14
,
15
]
>
(
in_4na_bin
)
;
U8
in_stats_bin
=
in_2na_bin
;
physical
column
INSDC
:
2
na
:
packed
.
READ
=
in_2na_packed
|
(
INSDC
:
2
na
:
packed
)
pack
(
in_2na_bin
)
;
physical
column
<
INSDC
:
4
na
:
bin
>
zip_encoding
.
ALTREAD
=
<
INSDC
:
4
na
:
bin
>
trim
<
0
,
0
>
(
in_alt_4na_bin
)
;
INSDC
:
2
na
:
packed
out_2na_packed
=
.
READ
|
out_dcmp_2na_packed
;
INSDC
:
x2na
:
bin
out_x2na_bin
=
out_dcmp_x2na_bin
|
<
INSDC
:
4
na
:
bin
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
4
,
0
,
1
,
4
,
2
,
4
,
4
,
4
,
3
,
4
,
4
,
4
,
4
,
4
,
4
,
4
]
>
(
out_4na_bin
)
;
INSDC
:
4
na
:
bin
out_2na_4na_bin
=
<
INSDC
:
2
na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
2
na
:
map
:
BINSET
,
[
1
,
2
,
4
,
8
]
>
(
out_2na_bin
)
;
INSDC
:
4
na
:
bin
out_4na_bin
=
<
INSDC
:
4
na
:
bin
>
bit_or
<
ALIGN_RIGHT
>
(
out_2na_4na_bin
,
.
ALTREAD
)
|
out_dcmp_4na_bin
|
out_2na_4na_bin
;
INSDC
:
dna
:
text
out_dna_text
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_4na_bin
)
;
}
;
extern
function
INSDC
:
x2na
:
bin
NCBI
:
dna_from_color
#1
(
INSDC
:
x2cs
:
bin
color_bin
,
INSDC
:
coord
:
zero
read_start
,
INSDC
:
coord
:
len
read_len
,
INSDC
:
dna
:
text
cs_key
,
U8
color_matrix
)
;
table
NCBI
:
tbl
:
dcmp_color_space
#1
{
INSDC
:
dna
:
text
dcmp_virtual_productions
=
out_dcmp_x2cs_bin
|
out_dcmp_2cs_bin
|
out_dcmp_2cs_packed
;
}
table
NCBI
:
tbl
:
color_space_common
#1.0.3
=
INSDC
:
tbl
:
sequence
#1.0.1
,
INSDC
:
SRA
:
tbl
:
spotdesc
#1.0.2
,
INSDC
:
SRA
:
tbl
:
stats
#1.1.0
,
NCBI
:
tbl
:
dcmp_color_space
#1.0.0
{
bool
cs_native
=
<
bool
>
echo
<
true
>
(
)
;
INSDC
:
2
cs
:
bin
out_2cs_bin
=
out_dcmp_2cs_bin
|
(
INSDC
:
2
cs
:
bin
)
unpack
(
out_2cs_packed
)
;
INSDC
:
2
na
:
bin
out_2na_bin
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
2
na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
[
0
,
1
,
2
,
3
,
0
]
>
(
out_x2na_bin
)
;
INSDC
:
4
na
:
bin
out_4na_bin
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
[
1
,
2
,
4
,
8
,
15
]
>
(
out_x2na_bin
)
;
INSDC
:
dna
:
text
out_dna_text
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
INSDC
:
x2na
:
map
:
CHARSET
>
(
out_x2na_bin
)
;
INSDC
:
x2na
:
bin
out_x2na_bin
=
NCBI
:
dna_from_color
(
out_x2cs_bin
,
out_read_start
,
out_read_len
,
out_cs_key
,
out_color_matrix
)
;
INSDC
:
2
na
:
packed
out_2na_packed
=
(
INSDC
:
2
na
:
packed
)
pack
(
out_2na_bin
)
;
INSDC
:
4
na
:
packed
out_4na_packed
=
(
INSDC
:
4
na
:
packed
)
pack
(
out_4na_bin
)
;
INSDC
:
color
:
text
out_color_text
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
color
:
text
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
INSDC
:
x2cs
:
map
:
CHARSET
>
(
out_x2cs_bin
)
;
INSDC
:
coord
:
len
color_space_spot_len
=
(
INSDC
:
coord
:
len
)
row_len
(
out_2cs_packed
)
;
INSDC
:
coord
:
len
color_space_fixed_spot_len
=
(
INSDC
:
coord
:
len
)
fixed_row_len
(
out_2cs_packed
)
;
}
;
table
NCBI
:
tbl
:
color_space_nocol
#1.0.3
=
NCBI
:
tbl
:
color_space_common
#1.0.3
,
NCBI
:
tbl
:
n_encoding
#1
{
U8
out_color_matrix
=
<
U8
>
meta
:
read
<
"COLOR_MATRIX"
>
(
)
|
<
U8
>
echo
<
INSDC
:
color
:
default_matrix
>
(
)
;
INSDC
:
x2cs
:
bin
out_x2cs_bin
=
(
INSDC
:
x2cs
:
bin
)
read_ndecode
;
U8
read_unpack
=
out_2cs_bin
;
}
;
table
NCBI
:
tbl
:
color_space
#1.0.3
=
NCBI
:
tbl
:
color_space_nocol
#1.0.3
{
INSDC
:
dna
:
text
out_cs_key
=
.
CS_KEY
;
INSDC
:
2
cs
:
packed
out_2cs_packed
=
.
CSREAD
;
}
;
table
NCBI
:
tbl
:
color_space
#2.1
=
NCBI
:
tbl
:
color_space_common
#1.0.3
,
NCBI
:
tbl
:
dcmp_color_space
#1.0.0
{
INSDC
:
color
:
text
in_color_text
=
CSREAD
;
INSDC
:
x2cs
:
bin
in_x2cs_bin
=
<
INSDC
:
x2cs
:
bin
>
range_validate
<
0
,
4
>
(
CSREAD
)
|
<
INSDC
:
color
:
text
,
INSDC
:
x2cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
CHARSET
,
INSDC
:
x2cs
:
map
:
BINSET
>
(
in_color_text
)
;
INSDC
:
2
cs
:
bin
in_2cs_bin
=
<
INSDC
:
2
cs
:
bin
>
range_validate
<
0
,
3
>
(
CSREAD
)
|
(
INSDC
:
2
cs
:
bin
)
unpack
(
in_2cs_packed
)
|
<
INSDC
:
x2cs
:
bin
,
INSDC
:
2
cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
[
0
,
1
,
2
,
3
,
0
]
>
(
in_x2cs_bin
)
;
INSDC
:
2
cs
:
packed
in_2cs_packed
=
CSREAD
;
INSDC
:
x2cs
:
bin
in_alt_x2cs_bin
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
x2cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
[
0
,
0
,
0
,
0
,
4
]
>
(
in_x2cs_bin
)
;
INSDC
:
dna
:
text
in_cs_key
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'acgt', 'ACGT' > ( CS_KEY );
U8
in_color_matrix
=
<
U8
>
range_validate
<
0
,
4
>
(
COLOR_MATRIX
)
;
U8
in_stats_bin
=
in_2cs_bin
;
physical
column
INSDC
:
2
cs
:
packed
.
CSREAD
=
in_2cs_packed
|
(
INSDC
:
2
cs
:
packed
)
pack
(
in_2cs_bin
)
;
physical
column
<
INSDC
:
x2cs
:
bin
>
zip_encoding
.
ALTCSREAD
=
<
INSDC
:
x2cs
:
bin
>
trim
<
0
,
0
>
(
in_alt_x2cs_bin
)
;
physical
column
<
INSDC
:
dna
:
text
>
zip_encoding
.
CS_KEY
=
in_cs_key
;
physical
column
<
U8
>
zip_encoding
.
COLOR_MATRIX
=
in_color_matrix
;
INSDC
:
2
cs
:
packed
out_2cs_packed
=
.
CSREAD
|
out_dcmp_2cs_packed
;
INSDC
:
x2cs
:
bin
out_x2cs_bin
=
(
INSDC
:
x2cs
:
bin
)
<
U8
>
bit_or
<
ALIGN_RIGHT
>
(
out_2cs_bin
,
.
ALTCSREAD
)
|
out_dcmp_x2cs_bin
|
(
INSDC
:
x2cs
:
bin
)
out_2cs_bin
;
INSDC
:
dna
:
text
out_cs_key
=
.
CS_KEY
;
U8
out_color_matrix
=
.
COLOR_MATRIX
|
<
U8
>
echo
<
INSDC
:
color
:
default_matrix
>
(
)
;
}
;
table
NCBI
:
tbl
:
protein
#1
=
INSDC
:
tbl
:
protein
{
INSDC
:
protein
:
text
in_protein_text
=
<
INSDC
:
protein
:
text
,
INSDC
:
protein
:
text
>
map
<
'abcdefghijklmnopqrstvwxyzu','ABCDEFGHIJKLMNOPQRSTVWXYZU' > ( PROTEIN );
INSDC
:
aa
:
bin
in_aa_bin
=
<
INSDC
:
aa
:
bin
>
range_validate
<
1
,
27
>
(
PROTEIN
)
|
<
INSDC
:
protein
:
text
,
INSDC
:
aa
:
bin
>
map
<
INSDC
:
aa
:
map
:
CHARSET
,
INSDC
:
aa
:
map
:
BINSET
>
(
in_protein_text
)
;
physical
column
<
INSDC
:
aa
:
bin
>
zip_encoding
.
PROTEIN
=
in_aa_bin
;
INSDC
:
aa
:
bin
out_aa_bin
=
.
PROTEIN
;
INSDC
:
protein
:
text
out_protein_text
=
<
INSDC
:
aa
:
bin
,
INSDC
:
protein
:
text
>
map
<
INSDC
:
aa
:
map
:
BINSET
,
INSDC
:
aa
:
map
:
CHARSET
>
(
out_aa_bin
)
;
}
;
table
NCBI
:
tbl
:
phred_quality_nocol
#1.0.1
=
INSDC
:
tbl
:
sequence
#1.0.1
,
NCBI
:
tbl
:
n_encoding
#1
{
U8
read_ndecode
=
<
INSDC
:
quality
:
phred
,
U8
>
map
<
0
,
4
>
(
out_qual_phred
,
read_unpack
)
;
}
;
table
NCBI
:
tbl
:
phred_quality
#1.0.1
=
NCBI
:
tbl
:
phred_quality_nocol
#1.0.1
{
NCBI
:
quality
:
n_encoded
:
phred
out_qual_phred
=
.
QUALITY
;
}
;
table
NCBI
:
tbl
:
phred_quality
#2.0.4
=
INSDC
:
tbl
:
sequence
#1.0.1
{
INSDC
:
quality
:
phred
out_qual_phred
=
.
QUALITY
;
INSDC
:
quality
:
text
:
phred_33
in_qual_text_phred_33
=
QUALITY
;
INSDC
:
quality
:
text
:
phred_64
in_qual_text_phred_64
=
QUALITY
;
INSDC
:
quality
:
phred
in_qual_phred
=
QUALITY
|
(
INSDC
:
quality
:
phred
)
<
B8
>
diff
<
33
>
(
in_qual_text_phred_33
)
|
(
INSDC
:
quality
:
phred
)
<
B8
>
diff
<
64
>
(
in_qual_text_phred_64
)
;
physical
column
<
INSDC
:
quality
:
phred
>
zip_encoding
.
QUALITY
=
in_qual_phred
;
INSDC
:
quality
:
phred
in_stats_qual
=
in_qual_phred
;
}
;
const
INSDC
:
quality
:
log_odds
NCBI
:
quality
:
from
:
log_odds
=
[
-
6
,
-
5
,
-
4
,
-
3
,
-
2
,
-
1
,
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
,
10
,
11
,
12
,
13
,
14
,
15
,
16
,
17
,
18
,
19
,
20
,
21
,
22
,
23
,
24
,
25
,
26
,
27
,
28
,
29
,
30
,
31
,
32
,
33
,
34
,
35
,
36
,
37
,
38
,
39
,
40
]
;
const
INSDC
:
quality
:
phred
NCBI
:
quality
:
to
:
phred
=
[
0
,
1
,
1
,
2
,
2
,
3
,
3
,
4
,
4
,
5
,
5
,
6
,
7
,
8
,
9
,
10
,
10
,
11
,
12
,
13
,
14
,
15
,
16
,
17
,
18
,
19
,
20
,
21
,
22
,
23
,
24
,
25
,
26
,
27
,
28
,
29
,
30
,
31
,
32
,
33
,
34
,
35
,
36
,
37
,
38
,
39
,
40
]
;
function
INSDC
:
quality
:
phred
NCBI
:
log_odds_to_phred
#1
(
INSDC
:
quality
:
log_odds
qual_log_odds
)
{
INSDC
:
quality
:
log_odds
log_odds_clip
=
<
INSDC
:
quality
:
log_odds
>
clip
<
-
6
,
40
>
(
qual_log_odds
)
;
return
<
INSDC
:
quality
:
log_odds
,
INSDC
:
quality
:
phred
>
map
<
NCBI
:
quality
:
from
:
log_odds
,
NCBI
:
quality
:
to
:
phred
>
(
log_odds_clip
)
;
}
table
NCBI
:
tbl
:
log_odds_quality_nocol
#1.0.1
=
INSDC
:
tbl
:
sequence
#1.0.1
,
NCBI
:
tbl
:
n_encoding
#1
{
U8
read_ndecode
=
<
INSDC
:
quality
:
log_odds
,
U8
>
map
<
-
6
,
4
>
(
out_qual_log_odds
,
read_unpack
)
;
extern
column
INSDC
:
quality
:
log_odds
QUALITY
=
out_qual_log_odds
;
INSDC
:
quality
:
phred
out_qual_phred
=
out_qual2_phred
|
NCBI
:
log_odds_to_phred
(
out_qual_log_odds
)
;
}
;
table
NCBI
:
tbl
:
log_odds_quality
#1.0.1
=
NCBI
:
tbl
:
log_odds_quality_nocol
#1.0.1
{
NCBI
:
quality
:
n_encoded
:
log_odds
out_qual_log_odds
=
.
QUALITY
;
}
;
table
NCBI
:
tbl
:
log_odds_quality_nocol
#2.1.0
=
INSDC
:
tbl
:
sequence
#1.0.1
{
extern
column
INSDC
:
quality
:
log_odds
QUALITY
=
out_qual_log_odds
;
INSDC
:
quality
:
phred
in_qual_phred
=
NCBI
:
log_odds_to_phred
(
in_qual_log_odds
)
;
INSDC
:
quality
:
phred
out_qual_phred
=
NCBI
:
log_odds_to_phred
(
out_qual_log_odds
)
;
}
;
table
NCBI
:
tbl
:
log_odds_quality
#2.1.0
=
NCBI
:
tbl
:
log_odds_quality_nocol
#2.1.0
{
INSDC
:
quality
:
log_odds
out_qual_log_odds
=
.
QUALITY
;
extern
column
INSDC
:
quality
:
text
:
log_odds_64
QUALITY
=
out_qual_text_log_odds_64
|
(
INSDC
:
quality
:
text
:
log_odds_64
)
<
B8
>
sum
<
64
>
(
out_qual_log_odds
)
;
INSDC
:
quality
:
text
:
log_odds_64
in_qual_text_log_odds_64
=
QUALITY
;
INSDC
:
quality
:
log_odds
in_qual_log_odds
=
QUALITY
|
(
INSDC
:
quality
:
log_odds
)
<
B8
>
diff
<
64
>
(
in_qual_text_log_odds_64
)
;
physical
column
<
INSDC
:
quality
:
log_odds
>
zip_encoding
.
QUALITY
=
in_qual_log_odds
;
INSDC
:
quality
:
log_odds
in_stats_qual
=
in_qual_log_odds
;
}
;
version
1
;
include
'ncbi/sra.vschema';
include
'ncbi/spotname.vschema';
table
NCBI
:
SRA
:
tbl
:
clip
#1.0.2
=
INSDC
:
SRA
:
tbl
:
spotdesc
#1.0.2
{
column
INSDC
:
coord
:
one
CLIP_ADAPTER_LEFT
=
out_clip_adapt_left
;
column
INSDC
:
coord
:
one
CLIP_ADAPTER_RIGHT
=
out_clip_adapt_right
;
INSDC
:
coord
:
one
out_clip_adapt_left
=
cast
(
.
CLIP_ADAPTER_LEFT
)
;
INSDC
:
coord
:
one
out_clip_adapt_right
=
cast
(
.
CLIP_ADAPTER_RIGHT
)
;
column
INSDC
:
coord
:
one
CLIP_QUALITY_LEFT
=
out_clip_qual_left
;
column
INSDC
:
coord
:
one
CLIP_QUALITY_RIGHT
=
out_clip_qual_right
;
INSDC
:
coord
:
one
out_clip_qual_left
=
cast
(
.
CLIP_QUALITY_LEFT
)
|
<
INSDC
:
coord
:
one
>
echo
<
1
>
(
)
;
INSDC
:
coord
:
one
out_clip_qual_right
=
cast
(
.
CLIP_QUALITY_RIGHT
)
|
cast
(
spot_len
)
;
readonly
column
U16
CLIP_ADAPTER_LEFT
=
.
CLIP_ADAPTER_LEFT
|
cast
(
out_clip_adapt_left
)
;
readonly
column
U16
CLIP_ADAPTER_RIGHT
=
.
CLIP_ADAPTER_RIGHT
|
cast
(
out_clip_adapt_right
)
;
readonly
column
U16
CLIP_QUALITY_LEFT
=
cast
(
out_clip_qual_left
)
;
readonly
column
U16
CLIP_QUALITY_RIGHT
=
cast
(
out_clip_qual_right
)
;
INSDC
:
coord
:
one
spot_right
=
(
INSDC
:
coord
:
one
)
spot_len
;
INSDC
:
coord
:
one
lim_clip_adapt_left
=
<
INSDC
:
coord
:
one
>
clip
<
1
,
0x7FFFFFFF
>
(
out_clip_adapt_left
)
;
INSDC
:
coord
:
one
max_clip_adapt_right
=
<
INSDC
:
coord
:
one
,
INSDC
:
coord
:
one
>
map
<
0
,
0x7FFFFFFF
>
(
out_clip_adapt_right
)
;
INSDC
:
coord
:
one
lim_clip_adapt_right
=
<
INSDC
:
coord
:
one
>
min
(
spot_right
,
max_clip_adapt_right
)
;
INSDC
:
coord
:
one
lim_clip_qual_left
=
<
INSDC
:
coord
:
one
>
clip
<
1
,
0x7FFFFFFF
>
(
out_clip_qual_left
)
;
INSDC
:
coord
:
one
max_clip_qual_right
=
<
INSDC
:
coord
:
one
,
INSDC
:
coord
:
one
>
map
<
0
,
0x7FFFFFFF
>
(
out_clip_qual_right
)
;
INSDC
:
coord
:
one
lim_clip_qual_right
=
<
INSDC
:
coord
:
one
>
min
(
spot_right
,
max_clip_qual_right
)
;
readonly
column
INSDC
:
coord
:
zero
CLIP_ADAPTER_LEFT
=
(
INSDC
:
coord
:
zero
)
<
I32
>
diff
<
1
>
(
lim_clip_adapt_left
)
;
readonly
column
INSDC
:
coord
:
zero
CLIP_ADAPTER_RIGHT
=
(
INSDC
:
coord
:
zero
)
<
I32
>
diff
<
1
>
(
lim_clip_adapt_right
)
;
readonly
column
INSDC
:
coord
:
zero
CLIP_QUALITY_LEFT
=
(
INSDC
:
coord
:
zero
)
<
I32
>
diff
<
1
>
(
lim_clip_qual_left
)
;
readonly
column
INSDC
:
coord
:
zero
CLIP_QUALITY_RIGHT
=
(
INSDC
:
coord
:
zero
)
<
I32
>
diff
<
1
>
(
lim_clip_qual_right
)
;
INSDC
:
coord
:
one
max_clip_left
=
<
INSDC
:
coord
:
one
>
max
(
lim_clip_adapt_left
,
lim_clip_qual_left
)
|
lim_clip_adapt_left
|
lim_clip_qual_left
;
INSDC
:
coord
:
zero
max_zclip_left
=
(
INSDC
:
coord
:
zero
)
<
I32
>
diff
<
1
>
(
max_clip_left
)
;
INSDC
:
coord
:
one
min_clip_right
=
<
INSDC
:
coord
:
one
>
min
(
lim_clip_adapt_right
,
lim_clip_qual_right
)
|
lim_clip_adapt_right
|
lim_clip_qual_right
;
INSDC
:
coord
:
zero
bio_start
=
NCBI
:
SRA
:
bio_start
(
out_read_start
,
out_read_type
)
;
INSDC
:
coord
:
zero
trim_start
=
<
INSDC
:
coord
:
zero
>
max
(
bio_start
,
max_zclip_left
)
|
bio_start
;
INSDC
:
coord
:
zero
bio_end
=
NCBI
:
SRA
:
bio_end
<
false
>
(
out_read_start
,
out_read_type
,
out_read_len
)
;
I32
trim_stop
=
<
I32
>
max
(
min_clip_right
,
trim_start
)
|
spot_right
;
INSDC
:
coord
:
len
trim_len
=
(
INSDC
:
coord
:
len
)
<
I32
>
diff
(
trim_stop
,
trim_start
)
;
}
;
version
1
;
include
'vdb/vdb.vschema';
table
NCBI
:
pnbr
:
table
:
qpig
#1
{
extern
column
<
U64
>
izip_encoding
OFFSET
;
extern
column
<
U64
>
izip_encoding
COUNT
;
}
;
table
NCBI
:
pnbr
:
table
:
hsp
#1
{
extern
column
<
U32
>
izip_encoding
SPIG
;
extern
column
<
I32
>
izip_encoding
MAX_SCORE
;
extern
column
<
B8
>
zip_encoding
SEGMENTS
;
}
;
database
NCBI
:
pnbr
:
db
:
pnbr
#1
{
table
NCBI
:
pnbr
:
table
:
qpig
#1
QPIG_REFERENCE
;
table
NCBI
:
pnbr
:
table
:
hsp
#1
HSP
;
}
;
version
1
;
include
'vdb/vdb.vschema';
include
'ncbi/seq.vschema';
include
'ncbi/spotname.vschema';
include
'insdc/sra.vschema';
include
'ncbi/stats.vschema';
typedef
U16
NCBI
:
SRA
:
Segment
[
2
]
;
typedef
B8
NCBI
:
SRA
:
SpotDesc
[
16
]
;
typedef
B8
NCBI
:
SRA
:
ReadDesc
[
80
]
;
alias
INSDC
:
SRA
:
platform_id
NCBI
:
SRA
:
platform_id
;
alias
INSDC
:
SRA
:
read_type
NCBI
:
SRA
:
read_type
;
alias
INSDC
:
SRA
:
read_filter
NCBI
:
SRA
:
read_filter
;
typedef
NCBI
:
fsamp4
NCBI
:
SRA
:
rotated_fsamp4
,
NCBI
:
SRA
:
swapped_fsamp4
;
typedef
U16
NCBI
:
SRA
:
pos16
;
extern
function
INSDC
:
coord
:
zero
NCBI
:
SRA
:
bio_start
#1
(
INSDC
:
coord
:
zero
read_start
,
INSDC
:
SRA
:
xread_type
read_type
)
;
extern
function
INSDC
:
coord
:
zero
NCBI
:
SRA
:
bio_end
#1
<
bool
inclusive
>
(
INSDC
:
coord
:
zero
read_start
,
INSDC
:
SRA
:
xread_type
read_type
,
INSDC
:
coord
:
len
read_len
)
;
extern
function
INSDC
:
coord
:
len
[
2
]
NCBI
:
SRA
:
fix_read_seg
#1
(
U16
[
2
]
rd_seg
,
INSDC
:
coord
:
len
spot_len
)
;
extern
function
NCBI
:
SRA
:
SpotDesc
NCBI
:
SRA
:
make_spot_desc
#1
(
INSDC
:
coord
:
len
spot_len
,
INSDC
:
coord
:
len
fixed_len
,
INSDC
:
coord
:
len
sig_len
,
INSDC
:
coord
:
zero
trim_start
,
INSDC
:
coord
:
len
trim_len
,
U8
num_reads
)
;
extern
function
NCBI
:
SRA
:
ReadDesc
NCBI
:
SRA
:
make_read_desc
#1
(
U8
num_reads
,
INSDC
:
coord
:
zero
read_start
,
INSDC
:
coord
:
len
read_len
,
INSDC
:
SRA
:
xread_type
read_type
,
INSDC
:
SRA
:
read_filter
read_filt
,
INSDC
:
dna
:
text
cs_key
,
INSDC
:
coord
:
zero
label_start
,
INSDC
:
coord
:
len
label_len
,
ascii
label
)
;
extern
function
<
type
T
>
T
NCBI
:
SRA
:
rotate
#1
<
bool
encoding
>
(
T
in
,
U8
called
)
;
extern
function
<
type
T
>
T
NCBI
:
SRA
:
swap
#1
(
T
in
,
U8
called
)
;
extern
function
<
type
T
>
T
NCBI
:
SRA
:
normalize
#1
(
T
intensity
,
U8
called
)
;
extern
function
<
type
T
>
T
NCBI
:
SRA
:
denormalize
#1
(
T
intensity
,
U8
called
)
;
extern
function
<
type
T
>
T
NCBI
:
SRA
:
make_position
#1
<
T
start
>
(
any
bases
)
;
function
NCBI
:
SRA
:
swapped_fsamp4
NCBI
:
SRA
:
fsamp4
:
decode
#2
(
merged_fmt
in
)
{
fzip_fmt
cmp0
=
split
<
0
>
(
in
)
;
fzip_fmt
cmp123
=
split
<
1
>
(
in
)
;
F32
ch0
=
funzip
(
cmp0
)
;
F32
ch123a
=
funzip
(
cmp123
)
;
F32
[
3
]
ch123
=
redimension
(
ch123a
)
;
return
(
NCBI
:
SRA
:
swapped_fsamp4
)
<
F32
>
paste
(
ch0
,
ch123
)
;
}
function
merged_fmt
NCBI
:
SRA
:
fsamp4
:
encode
#2
<
U32
called
,
U32
alt
>
(
NCBI
:
SRA
:
swapped_fsamp4
in
)
{
F32
ch0
=
<
F32
>
cut
<
0
>
(
in
)
;
F32
[
3
]
ch123
=
<
F32
>
cut
<
1
,
2
,
3
>
(
in
)
;
fzip_fmt
cmp0
=
fzip
<
called
>
(
ch0
)
;
F32
ch123a
=
redimension
(
ch123
)
;
fzip_fmt
cmp123
=
fzip
<
alt
>
(
ch123a
)
;
return
merge
(
cmp0
,
cmp123
)
;
}
table
NCBI
:
SRA
:
tbl
:
spotdesc_nocol
#1.0.2
=
INSDC
:
tbl
:
sequence
#1.0.1
,
INSDC
:
SRA
:
tbl
:
spotdesc
#1.0.2
{
readonly
column
NCBI
:
SRA
:
Segment
LABEL_SEG
=
out_label_seg
|
cast
(
out_label_seg32
)
|
cast
(
_out_label_seg32
)
;
U32
_out_label_startU32
=
(
U32
)
out_label_start
;
U32
[
2
]
_out_label_seg32
=
<
U32
>
paste
(
_out_label_startU32
,
out_label_len
)
;
readonly
column
NCBI
:
SRA
:
Segment
READ_SEG
=
out_read_seg
|
cast
(
out_read_seg32
)
|
cast
(
_out_read_seg32
)
;
U32
_out_read_startU32
=
(
U32
)
out_read_start
;
U32
[
2
]
_out_read_seg32
=
<
U32
>
paste
(
_out_read_startU32
,
out_read_len
)
;
readonly
column
NCBI
:
SRA
:
ReadDesc
READ_DESC
=
NCBI
:
SRA
:
make_read_desc
(
out_nreads
,
out_read_start
,
out_read_len
,
out_read_type
,
_out_rd_filter
,
out_cs_key
,
_out_label_start
,
_out_label_len
,
_out_label
)
;
INSDC
:
SRA
:
read_filter
_out_rd_filter
=
out_rd_filter
|
<
INSDC
:
SRA
:
read_filter
>
echo
<
SRA_READ_FILTER_PASS
>
(
out_read_start
)
;
ascii
_out_label
=
out_label
|
<
ascii
>
echo
<
'' > ();
INSDC
:
coord
:
zero
_out_label_start
=
out_label_start
|
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
out_read_start
)
;
INSDC
:
coord
:
len
_out_label_len
=
out_label_len
|
<
INSDC
:
coord
:
len
>
echo
<
0
>
(
out_read_start
)
;
readonly
column
NCBI
:
SRA
:
SpotDesc
SPOT_DESC
=
NCBI
:
SRA
:
make_spot_desc
(
spot_len
,
fixed_spot_len
,
signal_len
,
trim_start
,
trim_len
,
out_nreads
)
;
readonly
column
INSDC
:
coord
:
len
SIGNAL_LEN
=
signal_len
;
readonly
column
U16
SIGNAL_LEN
=
cast
(
signal_len
)
;
}
;
table
NCBI
:
SRA
:
tbl
:
spotdesc_nophys
#1.0.2
=
NCBI
:
SRA
:
tbl
:
spotdesc_nocol
#1.0.2
{
U8
out_nreads
=
.
NREADS
;
ascii
out_label
=
.
LABEL
;
INSDC
:
SRA
:
xread_type
out_read_type
=
.
READ_TYPE
;
INSDC
:
SRA
:
read_filter
out_rd_filter
=
.
RD_FILTER
;
INSDC
:
coord
:
zero
out_label_start
=
.
LABEL_START
|
(
INSDC
:
coord
:
zero
)
<
U32
>
cut
<
0
>
(
out_label_seg32
)
;
INSDC
:
coord
:
len
out_label_len
=
.
LABEL_LEN
|
(
INSDC
:
coord
:
len
)
<
U32
>
cut
<
1
>
(
out_label_seg32
)
;
U32
[
2
]
out_label_seg32
=
cast
(
.
LABEL_SEG
)
;
INSDC
:
coord
:
zero
out_read_start
=
.
READ_START
|
(
INSDC
:
coord
:
zero
)
<
U32
>
cut
<
0
>
(
out_read_seg32
)
;
INSDC
:
coord
:
len
out_read_len
=
.
READ_LEN
|
(
INSDC
:
coord
:
len
)
<
U32
>
cut
<
1
>
(
out_read_seg32
)
;
U32
[
2
]
out_read_seg32
=
NCBI
:
SRA
:
fix_read_seg
(
.
READ_SEG
,
spot_len
)
;
}
table
NCBI
:
SRA
:
tbl
:
spotdesc
#1.0.2
=
NCBI
:
SRA
:
tbl
:
spotdesc_nophys
#1.0.2
{
physical
column
<
U8
>
zip_encoding
.
NREADS
=
NREADS
;
physical
column
<
ascii
>
zip_encoding
.
LABEL
=
LABEL
;
physical
column
<
INSDC
:
coord
:
zero
>
izip_encoding
.
LABEL_START
=
LABEL_START
;
physical
column
<
INSDC
:
coord
:
len
>
izip_encoding
.
LABEL_LEN
=
LABEL_LEN
;
physical
column
<
INSDC
:
coord
:
zero
>
izip_encoding
.
READ_START
=
READ_START
;
physical
column
<
INSDC
:
coord
:
len
>
izip_encoding
.
READ_LEN
=
in_read_len
;
physical
column
<
INSDC
:
SRA
:
xread_type
>
zip_encoding
.
READ_TYPE
=
in_read_type
;
physical
column
<
INSDC
:
SRA
:
read_filter
>
zip_encoding
.
RD_FILTER
=
READ_FILTER
;
}
;
table
NCBI
:
SRA
:
tbl
:
pos
#1.0.1
=
INSDC
:
tbl
:
sequence
#1.0.1
{
INSDC
:
position
:
one
out_position
=
<
INSDC
:
position
:
one
>
NCBI
:
SRA
:
make_position
<
1
>
(
out_2na_packed
)
|
<
INSDC
:
position
:
one
>
NCBI
:
SRA
:
make_position
<
1
>
(
out_2cs_packed
)
;
NCBI
:
SRA
:
pos16
out_position16
=
<
NCBI
:
SRA
:
pos16
>
NCBI
:
SRA
:
make_position
<
1
>
(
out_2na_packed
)
|
<
NCBI
:
SRA
:
pos16
>
NCBI
:
SRA
:
make_position
<
1
>
(
out_2cs_packed
)
;
}
;
table
NCBI
:
SRA
:
tbl
:
sra_nopos
#1.0.3
=
INSDC
:
SRA
:
tbl
:
sra
#1.0.3
,
NCBI
:
SRA
:
tbl
:
spotdesc_nocol
#1.0.2
{
column
INSDC
:
position
:
one
POSITION
=
out_position
;
readonly
column
NCBI
:
SRA
:
pos16
POSITION
=
out_position16
;
readonly
column
INSDC
:
position
:
zero
POSITION
=
(
INSDC
:
position
:
zero
)
<
I32
>
diff
<
1
>
(
out_position
)
;
U64
base_count
=
<
U64
>
meta
:
value
<
"BASE_COUNT"
>
(
)
;
U64
spot_count
=
<
U64
>
meta
:
value
<
".seq/spot"
>
(
)
|
<
U64
>
meta
:
value
<
".seq"
>
(
)
;
}
;
table
NCBI
:
SRA
:
tbl
:
sra
#1.0.3
=
NCBI
:
SRA
:
tbl
:
sra_nopos
#1.0.3
,
NCBI
:
SRA
:
tbl
:
pos
#1.0.1
{
}
;
table
NCBI
:
SRA
:
tbl
:
sra_nopos
#2.1.3
=
INSDC
:
SRA
:
tbl
:
sra
#1.0.3
,
NCBI
:
SRA
:
tbl
:
skeyname
#3.0.1
,
NCBI
:
SRA
:
tbl
:
spotdesc
#1.0.2
,
NCBI
:
SRA
:
tbl
:
stats
#1.2.0
{
INSDC
:
SRA
:
platform_id
out_platform
=
.
PLATFORM
;
column
INSDC
:
position
:
one
POSITION
=
out_position
;
readonly
column
NCBI
:
SRA
:
pos16
POSITION
=
cast
(
_clip_position
)
;
INSDC
:
position
:
one
_clip_position
=
<
INSDC
:
position
:
one
>
clip
<
0
,
0xFFFF
>
(
out_position
)
;
readonly
column
INSDC
:
position
:
zero
POSITION
=
(
INSDC
:
position
:
zero
)
<
I32
>
diff
<
1
>
(
out_position
)
;
}
;
table
NCBI
:
SRA
:
tbl
:
sra
#2.1.3
=
INSDC
:
SRA
:
tbl
:
sra
#1.0.3
,
NCBI
:
SRA
:
tbl
:
skeyname
#3.0.1
,
NCBI
:
SRA
:
tbl
:
spotdesc
#1.0.2
,
NCBI
:
SRA
:
tbl
:
stats
#1.2.0
,
NCBI
:
SRA
:
tbl
:
pos
#1.0.1
{
readonly
column
INSDC
:
position
:
one
POSITION
=
out_position
;
readonly
column
NCBI
:
SRA
:
pos16
POSITION
=
out_position16
;
readonly
column
INSDC
:
position
:
zero
POSITION
=
(
INSDC
:
position
:
zero
)
<
I32
>
diff
<
1
>
(
out_position
)
;
}
;
version
1
;
include
'vdb/built-in.vschema';
typedef
U16
text
:
token
[
3
]
;
typeset
pack_set
{
B8
,
B16
,
B32
,
B64
,
integer_set
}
;
typeset
izip_set
{
integer_set
}
;
typeset
fzip_set
{
F32
}
;
fmtdef
izip_fmt
;
fmtdef
fzip_fmt
;
fmtdef
rle_fmt
;
fmtdef
zlib_fmt
;
fmtdef
bzip2_fmt
;
function
<
type
T
>
T
echo
#1.0
<
T
val
>
(
*
any
row_len
)
=
vdb
:
echo
;
function
<
type
T
>
T
exists
#1.0
<
*
T
cval
>
(
any
predicate
,
*
T
dval
)
=
vdb
:
exists
;
function
<
type
A
,
type
B
>
B
map
#1.0
<
A
from
,
B
to
>
(
A
in
,
*
B
src
)
=
vdb
:
map
;
function
<
type
T
>
T
clip
#1.0
<
T
lower
,
T
upper
>
(
T
in
)
=
vdb
:
clip
;
function
<
type
T
,
U32
dim
>
T
[
dim
]
vclip
#1.0
<
T
lower
,
T
upper
>
(
T
[
dim
]
in
)
=
vdb
:
clip
;
function
numeric_set
ceil
#1.0
(
float_set
in
)
=
vdb
:
ceil
;
function
numeric_set
floor
#1.0
(
float_set
in
)
=
vdb
:
floor
;
function
numeric_set
round
#1.0
(
float_set
in
)
=
vdb
:
round
;
function
numeric_set
trunc
#1.0
(
float_set
in
)
=
vdb
:
trunc
;
function
<
type
T
>
T
min
#1.0
(
T
a
,
T
b
)
=
vdb
:
min
;
function
<
type
T
>
T
max
#1.0
(
T
a
,
T
b
)
=
vdb
:
max
;
function
<
type
T
>
T
sum
#1.0
<
*
T
k
>
(
T
a
,
...
)
=
vdb
:
sum
;
function
<
type
T
>
T
diff
#1.0
<
*
T
k
>
(
T
a
*
T
b
)
=
vdb
:
diff
;
function
<
type
T
>
T
deriv
#1.0
(
T
in
)
=
vdb
:
deriv
;
function
<
type
T
>
T
integral
#1.0
(
T
in
)
=
vdb
:
integral
;
function
<
type
T
>
T
integral_0
#1.1
(
T
in
)
=
vdb
:
integral_0
;
function
<
type
T
>
T
delta
#1.0
(
T
in
)
=
vdb
:
delta
;
function
<
type
T
>
T
undelta
#1.0
(
T
in
)
=
vdb
:
undelta
;
function
<
type
T
>
T
outlier_encode
#1.0
<
T
outlier
>
(
T
in
)
=
vdb
:
outlier_encode
;
function
<
type
T
>
T
outlier_decode
#1.0
<
T
outlier
>
(
T
in
)
=
vdb
:
outlier_decode
;
function
<
type
T
>
T
add_row_id
#1.0
(
T
in
)
=
vdb
:
add_row_id
;
function
<
type
T
>
T
sub_row_id
#1.0
(
T
in
)
=
vdb
:
sub_row_id
;
function
<
type
T
>
T
[
*
]
cut
#1.0
<
U32
idx
,
...
>
(
T
[
*
]
in
)
=
vdb
:
cut
;
function
<
type
T
>
T
[
*
]
paste
#1.0
(
T
[
*
]
in
,
...
)
=
vdb
:
paste
;
function
<
type
T
>
T
vec_sum
#1.0
(
T
[
*
]
in
)
=
vdb
:
vec_sum
;
function
<
type
T
>
T
fixed_vec_sum
#1.0
(
T
[
*
]
in
)
=
vdb
:
fixed_vec_sum
;
function
bool
checksum
#1.0
<
ascii
node
,
ascii
algorithm
>
(
B8
in
)
=
vdb
:
checksum
;
function
bool
md5sum
#1.0
<
ascii
node
>
(
B8
in
)
{
return
checksum
<
node
,
'md5' > ( in );
}
function
B1
[
*
]
pack
#1.0
(
pack_set
in
)
=
vdb
:
pack
;
function
pack_set
unpack
#1.0
(
B1
[
*
]
in
)
=
vdb
:
unpack
;
function
izip_fmt
izip
#2.1
(
izip_set
in
)
=
vdb
:
izip
;
function
izip_set
iunzip
#2.1
(
izip_fmt
in
)
=
vdb
:
iunzip
;
physical
<
type
T
>
T
izip_encoding
#1.0
{
decode
{
return
(
T
)
iunzip
(
@
)
;
}
encode
{
return
izip
(
@
)
;
}
}
;
function
fzip_fmt
fzip
#1.0
<
U32
mantissa
>
(
fzip_set
in
)
=
vdb
:
fzip
;
function
fzip_set
funzip
#1.0
(
fzip_fmt
in
)
=
vdb
:
funzip
;
physical
<
type
T
>
T
fzip_encoding
#1.0
<
U32
mantissa
>
{
decode
{
return
funzip
(
@
)
;
}
encode
{
return
fzip
<
mantissa
>
(
@
)
;
}
}
;
function
rle_fmt
rlencode
#1.0
(
any
in
)
=
vdb
:
rlencode
;
function
any
rldecode
#1.0
(
rle_fmt
in
)
=
vdb
:
rldecode
;
const
I32
Z_FILTERED
=
1
;
const
I32
Z_HUFFMAN_ONLY
=
2
;
const
I32
Z_RLE
=
3
;
const
I32
Z_DEFAULT_STRATEGY
=
0
;
const
I32
Z_NO_COMPRESSION
=
0
;
const
I32
Z_BEST_SPEED
=
1
;
const
I32
Z_BEST_COMPRESSION
=
9
;
const
I32
Z_DEFAULT_COMPRESSION
=
-
1
;
function
zlib_fmt
zip
#1.0
<
*
I32
strategy
,
I32
level
>
(
any
in
)
=
vdb
:
zip
;
function
any
unzip
#1.0
(
zlib_fmt
in
)
=
vdb
:
unzip
;
physical
<
type
T
>
T
zip_encoding
#1.0
<
*
I32
strategy
,
I32
level
>
{
decode
{
return
unzip
(
@
)
;
}
encode
{
return
zip
<
strategy
,
level
>
(
@
)
;
}
}
;
physical
bool
bool_encoding
#1.0
{
decode
{
B1
bit
=
unzip
(
@
)
;
return
(
bool
)
unpack
(
bit
)
;
}
encode
{
U8
lim
=
<
U8
>
clip
<
0
,
1
>
(
@
)
;
B1
bit
=
pack
(
lim
)
;
return
zip
<
Z_RLE
,
Z_BEST_SPEED
>
(
bit
)
;
}
}
physical
<
type
T
>
T
delta_izip_encoding
#1.0
{
decode
{
T
dlt
=
iunzip
(
@
)
;
return
<
T
>
undelta
(
dlt
)
;
}
encode
{
T
dlt
=
<
T
>
delta
(
@
)
;
return
izip
(
dlt
)
;
}
}
physical
<
type
T
>
T
delta_zip_encoding
#1.0
{
decode
{
T
dlt
=
unzip
(
@
)
;
return
<
T
>
undelta
(
dlt
)
;
}
encode
{
T
dlt
=
<
T
>
delta
(
@
)
;
return
zip
<
Z_RLE
,
Z_BEST_SPEED
>
(
dlt
)
;
}
}
physical
<
type
T
>
T
delta_average_zip_encoding
#1.0
{
decode
{
delta_averaged_fmt
t
=
unzip
(
@
)
;
return
undelta_average
(
t
)
;
}
encode
{
delta_averaged_fmt
t
=
delta_average
(
@
)
;
return
zip
<
Z_RLE
,
Z_BEST_SPEED
>
(
t
)
;
}
}
function
bzip2_fmt
bzip
#1.0
<
*
U32
blockSize100k
,
U32
workFactor
>
(
any
in
)
=
vdb
:
bzip
;
function
any
bunzip
#1.0
(
bzip2_fmt
in
)
=
vdb
:
bunzip
;
physical
<
type
T
>
T
bzip_encoding
#1.0
<
*
U32
blockSize100k
,
U32
workFactor
>
{
decode
{
return
bunzip
(
@
)
;
}
encode
{
return
bzip
<
blockSize100k
,
workFactor
>
(
@
)
;
}
}
;
function
<
type
T
>
T
simple_sub_select
#1.0
<
ascii
tbl
,
ascii
col
>
(
I64
row
*
I32
idx
)
=
vdb
:
simple_sub_select_1
;
function
text_set
extract_token
#1.0
<
U32
idx
>
(
text_set
str
,
text
:
token
tok
)
=
vdb
:
extract_token
;
function
numeric_set
strtonum
#1.0
<
*
U32
radix
>
(
text_set
str
)
=
vdb
:
strtonum
;
function
text_set
sprintf
#1.0
<
ascii
fmt
>
(
any
p1
,
...
)
=
vdb
:
sprintf
;
version
1
;
typedef
I64
vdb
:
row_id_range
[
2
]
;
typeset
integer_set
{
I8
,
U8
,
I16
,
U16
,
I32
,
U32
,
I64
,
U64
}
;
typeset
float_set
{
F32
,
F64
}
;
typeset
numeric_set
{
integer_set
,
float_set
}
;
typeset
text_set
{
utf8
,
utf16
,
utf32
,
ascii
}
;
typeset
text8_set
{
utf8
,
ascii
}
;
typeset
transpose_set
{
B8
,
B16
,
B32
,
B64
}
;
fmtdef
merged_fmt
;
fmtdef
transposed_fmt
;
fmtdef
delta_averaged_fmt
;
const
U8
ALIGN_LEFT
=
0
;
const
U8
ALIGN_RIGHT
=
1
;
function
any
cast
#1.0
(
any
in
)
=
vdb
:
cast
;
function
<
type
T
>
T
bit_or
#1
<
U8
align
>
(
T
A
,
T
B
)
=
vdb
:
bit_or
;
function
<
type
T
>
T
trim
#1
<
U8
align
,
T
val
>
(
T
A
)
=
vdb
:
trim
;
function
any
redimension
#1.0
(
any
in
)
=
vdb
:
redimension
;
function
I64
row_id
#1.0
(
)
=
vdb
:
row_id
;
function
U32
row_len
#1.0
(
any
in
)
=
vdb
:
row_len
;
function
U32
fixed_row_len
#1.0
(
any
in
)
=
vdb
:
fixed_row_len
;
validate
function
<
type
T
>
void
compare
#1.0
<
*
U32
sig_bits
>
(
T
src
,
T
cmp
)
=
vdb
:
compare
;
validate
function
<
type
T
>
void
no_compare
#1.0
(
T
src
,
T
cmp
)
=
vdb
:
no_compare
;
function
<
type
T
>
T
range_validate
#1.0
<
T
lower
,
T
upper
>
(
T
in
)
=
vdb
:
range_validate
;
function
<
type
T
>
T
select
#1.0
(
T
first
,
T
second
,
...
)
=
vdb
:
select
;
function
transposed_fmt
transpose
#1
(
transpose_set
in
)
=
vdb
:
transpose
;
function
transpose_set
detranspose
#1
(
transposed_fmt
in
)
=
vdb
:
detranspose
;
function
delta_averaged_fmt
delta_average
#1
(
any
in
)
=
vdb
:
delta_average
;
function
any
undelta_average
#1
(
delta_averaged_fmt
in
)
=
vdb
:
undelta_average
;
function
merged_fmt
merge
#1.0
(
any
in
,
...
)
=
vdb
:
merge
;
function
any
split
#1.0
<
U32
idx
>
(
merged_fmt
in
)
=
vdb
:
split
;
function
<
type
T
>
T
meta
:
read
#1.0
<
ascii
node
,
*
bool
deterministic
>
(
)
;
function
<
type
T
>
T
meta
:
value
#1.0
<
ascii
node
,
*
bool
deterministic
>
(
)
;
function
<
type
T
>
T
meta
:
write
#1.0
<
ascii
node
>
(
T
in
)
;
function
ascii
meta
:
attr
:
read
#1.0
<
ascii
node
,
ascii
attr
,
*
bool
deterministic
>
(
)
;
function
ascii
meta
:
attr
:
write
#1.0
<
ascii
node
,
ascii
attr
>
(
ascii
in
)
;
function
text8_set
parameter
:
read
#1.0
<
ascii
name
,
*
bool
deterministic
>
(
)
;
function
text8_set
environment
:
read
#1.0
<
ascii
name
>
(
)
;
const
U8
CASE_SENSITIVE
=
0
;
const
U8
CASE_INSENSITIVE_LOWER
=
1
;
const
U8
CASE_INSENSITIVE_UPPER
=
2
;
function
text8_set
idx
:
text
:
project
#1.1
<
ascii
index_name
,
*
U8
case_sensitivity
>
(
*
text8_set
substitute
)
;
function
text8_set
idx
:
text
:
insert
#1.1
<
ascii
index_name
,
*
U8
case_sensitivity
>
(
text8_set
key
)
;
function
vdb
:
row_id_range
idx
:
text
:
lookup
#1.1
<
ascii
index_name
,
ascii
query_by_name
,
*
U8
case_sensitivity
>
(
)
;
version
1
;
include
'vdb/vdb.vschema';
include
'insdc/insdc.vschema';
extern
function
INSDC
:
2
na
:
bin
INSDC
:
SEQ
:
rand_4na_2na
#1
(
INSDC
:
4
na
:
bin
rd_bin
)
;
table
INSDC
:
tbl
:
sequence
#1.0.1
{
extern
default
column
INSDC
:
dna
:
text
READ
{
read
=
out_dna_text
;
validate
=
<
INSDC
:
dna
:
text
>
compare
(
in_dna_text
,
out_dna_text
)
;
}
extern
column
INSDC
:
4
na
:
bin
READ
=
out_4na_bin
;
extern
column
INSDC
:
4
na
:
packed
READ
=
out_4na_packed
;
extern
column
INSDC
:
x2na
:
bin
READ
=
out_x2na_bin
;
extern
column
INSDC
:
2
na
:
bin
READ
=
out_2na_bin
;
extern
column
INSDC
:
2
na
:
packed
READ
=
out_2na_packed
;
extern
default
column
INSDC
:
color
:
text
CSREAD
{
read
=
out_color_text
;
validate
=
<
INSDC
:
color
:
text
>
compare
(
in_color_text
,
out_color_text
)
;
}
extern
column
INSDC
:
x2cs
:
bin
CSREAD
=
out_x2cs_bin
;
extern
column
INSDC
:
2
cs
:
bin
CSREAD
=
out_2cs_bin
;
extern
column
INSDC
:
2
cs
:
packed
CSREAD
=
out_2cs_packed
;
readonly
column
bool
CS_NATIVE
=
cs_native
;
extern
column
INSDC
:
dna
:
text
CS_KEY
{
read
=
out_cs_key
;
validate
=
<
INSDC
:
dna
:
text
>
compare
(
in_cs_key
,
out_cs_key
)
;
}
extern
column
U8
COLOR_MATRIX
=
out_color_matrix
;
extern
default
column
INSDC
:
quality
:
phred
QUALITY
=
out_qual_phred
;
extern
column
INSDC
:
quality
:
text
:
phred_33
QUALITY
=
out_qual_text_phred_33
|
(
INSDC
:
quality
:
text
:
phred_33
)
<
B8
>
sum
<
33
>
(
out_qual_phred
)
;
extern
column
INSDC
:
quality
:
text
:
phred_64
QUALITY
=
out_qual_text_phred_64
|
(
INSDC
:
quality
:
text
:
phred_64
)
<
B8
>
sum
<
64
>
(
out_qual_phred
)
;
INSDC
:
coord
:
len
signal_len
=
(
INSDC
:
coord
:
len
)
row_len
(
out_signal
)
|
<
INSDC
:
coord
:
len
>
echo
<
0
>
(
)
;
}
;
table
INSDC
:
tbl
:
protein
#1
{
extern
default
column
INSDC
:
protein
:
text
PROTEIN
{
read
=
out_protein_text
;
validate
=
<
INSDC
:
protein
:
text
>
compare
(
in_protein_text
,
out_protein_text
)
;
}
extern
column
INSDC
:
aa
:
bin
PROTEIN
=
out_aa_bin
;
}
;
version
1
;
typedef
ascii
INSDC
:
dna
:
text
;
typedef
U8
INSDC
:
4
na
:
bin
;
typedef
B1
INSDC
:
4
na
:
packed
[
4
]
;
const
INSDC
:
4
na
:
bin
INSDC
:
4
na
:
map
:
BINSET
=
[
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
,
10
,
11
,
12
,
13
,
14
,
15
]
;
const
INSDC
:
dna
:
text
INSDC
:
4
na
:
map
:
CHARSET
=
".ACMGRSVTWYHKDBN"
;
const
INSDC
:
dna
:
text
INSDC
:
4
na
:
accept
:
CHARSET
=
".ACMGRSVTWYHKDBNacmgrsvtwyhkdbn"
;
typedef
U8
INSDC
:
2
na
:
bin
;
typedef
U8
INSDC
:
x2na
:
bin
;
typedef
B1
INSDC
:
2
na
:
packed
[
2
]
;
const
INSDC
:
2
na
:
bin
INSDC
:
2
na
:
map
:
BINSET
=
[
0
,
1
,
2
,
3
]
;
const
INSDC
:
dna
:
text
INSDC
:
2
na
:
map
:
CHARSET
=
"ACGT"
;
const
INSDC
:
dna
:
text
INSDC
:
2
na
:
accept
:
CHARSET
=
"ACGTacgt"
;
const
INSDC
:
x2na
:
bin
INSDC
:
x2na
:
map
:
BINSET
=
[
0
,
1
,
2
,
3
,
4
]
;
const
INSDC
:
dna
:
text
INSDC
:
x2na
:
map
:
CHARSET
=
"ACGTN"
;
const
INSDC
:
dna
:
text
INSDC
:
x2na
:
accept
:
CHARSET
=
"ACGTNacgtn."
;
typedef
ascii
INSDC
:
color
:
text
;
typedef
U8
INSDC
:
2
cs
:
bin
;
typedef
U8
INSDC
:
x2cs
:
bin
;
typedef
B1
INSDC
:
2
cs
:
packed
[
2
]
;
const
INSDC
:
2
cs
:
bin
INSDC
:
2
cs
:
map
:
BINSET
=
[
0
,
1
,
2
,
3
]
;
const
INSDC
:
color
:
text
INSDC
:
2
cs
:
map
:
CHARSET
=
"0123"
;
const
INSDC
:
color
:
text
INSDC
:
2
cs
:
accept
:
CHARSET
=
"0123"
;
const
INSDC
:
x2cs
:
bin
INSDC
:
x2cs
:
map
:
BINSET
=
[
0
,
1
,
2
,
3
,
4
]
;
const
INSDC
:
color
:
text
INSDC
:
x2cs
:
map
:
CHARSET
=
"0123."
;
const
INSDC
:
color
:
text
INSDC
:
x2cs
:
accept
:
CHARSET
=
"0123."
;
const
U8
INSDC
:
color
:
default_matrix
=
[
0
,
1
,
2
,
3
,
4
,
1
,
0
,
3
,
2
,
4
,
2
,
3
,
0
,
1
,
4
,
3
,
2
,
1
,
0
,
4
,
4
,
4
,
4
,
4
,
4
]
;
typedef
ascii
INSDC
:
protein
:
text
;
typedef
U8
INSDC
:
aa
:
bin
;
const
INSDC
:
aa
:
bin
INSDC
:
aa
:
map
:
BINSET
=
[
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
,
10
,
11
,
12
,
13
,
14
,
15
,
16
,
17
,
18
,
19
,
20
,
21
,
22
,
23
,
24
,
25
,
26
,
27
]
;
const
INSDC
:
protein
:
text
INSDC
:
aa
:
map
:
CHARSET
=
"ABCDEFGHIKLMNPQRSTVWXYZU*OJ"
;
const
INSDC
:
protein
:
text
INSDC
:
aa
:
accept
:
CHARSET
=
"ABCDEFGHIJKLMNOPQRSTVWXYZU*abcdefghijklmnopqrstvwxyzu"
;
typedef
U8
INSDC
:
quality
:
phred
;
typedef
I8
INSDC
:
quality
:
log_odds
;
typedef
ascii
INSDC
:
quality
:
text
:
phred_33
;
typedef
ascii
INSDC
:
quality
:
text
:
phred_64
;
typedef
ascii
INSDC
:
quality
:
text
:
log_odds_64
;
typedef
I32
INSDC
:
coord
:
val
;
typedef
U32
INSDC
:
coord
:
len
;
typedef
INSDC
:
coord
:
val
INSDC
:
coord
:
zero
;
typedef
INSDC
:
coord
:
val
INSDC
:
coord
:
one
;
typedef
INSDC
:
coord
:
zero
INSDC
:
position
:
zero
;
typedef
INSDC
:
coord
:
one
INSDC
:
position
:
one
;
const
INSDC
:
coord
:
one
INSDC
:
coord
:
min
:
one
=
0x80000001
;
const
INSDC
:
coord
:
one
INSDC
:
coord
:
max
:
one
=
0x3FFFFFFF
;
const
INSDC
:
coord
:
zero
INSDC
:
coord
:
min
:
zero
=
0x80000000
;
const
INSDC
:
coord
:
zero
INSDC
:
coord
:
max
:
zero
=
0x3FFFFFFE
;
typedef
U8
INSDC
:
SRA
:
read_filter
;
const
INSDC
:
SRA
:
read_filter
SRA_READ_FILTER_PASS
=
0
;
const
INSDC
:
SRA
:
read_filter
SRA_READ_FILTER_REJECT
=
1
;
const
INSDC
:
SRA
:
read_filter
SRA_READ_FILTER_CRITERIA
=
2
;
const
INSDC
:
SRA
:
read_filter
SRA_READ_FILTER_REDACTED
=
3
;
typedef
U8
INSDC
:
SRA
:
xread_type
;
const
INSDC
:
SRA
:
xread_type
SRA_READ_TYPE_TECHNICAL
=
0
;
const
INSDC
:
SRA
:
xread_type
SRA_READ_TYPE_BIOLOGICAL
=
1
;
const
INSDC
:
SRA
:
xread_type
SRA_READ_TYPE_FORWARD
=
2
;
const
INSDC
:
SRA
:
xread_type
SRA_READ_TYPE_REVERSE
=
4
;
typedef
INSDC
:
SRA
:
xread_type
INSDC
:
SRA
:
read_type
;
version
1
;
include
'insdc/seq.vschema';
typedef
U32
INSDC
:
SRA
:
spotid_t
;
typedef
U64
INSDC
:
SRA
:
spot_ids_found
[
4
]
;
function
ascii
INSDC
:
SRA
:
format_spot_name
#1
(
ascii
name_fmt
,
I32
X
,
I32
Y
*
ascii
spot_name
)
;
function
ascii
INSDC
:
SRA
:
format_spot_name_no_coord
#1
(
ascii
name_fmt
*
ascii
spot_name
)
;
table
INSDC
:
SRA
:
tbl
:
spotcoord
#1
{
extern
default
column
INSDC
:
coord
:
val
X
=
out_x_coord
;
extern
default
column
INSDC
:
coord
:
val
Y
=
out_y_coord
;
extern
readonly
column
U16
X
=
cast
(
x_clip_U16
)
;
extern
readonly
column
U16
Y
=
cast
(
y_clip_U16
)
;
INSDC
:
coord
:
val
x_clip_U16
=
<
INSDC
:
coord
:
val
>
clip
<
0
,
0xFFFF
>
(
out_x_coord
)
;
INSDC
:
coord
:
val
y_clip_U16
=
<
INSDC
:
coord
:
val
>
clip
<
0
,
0xFFFF
>
(
out_y_coord
)
;
}
;
table
INSDC
:
SRA
:
tbl
:
spotname
#1.0.1
=
INSDC
:
SRA
:
tbl
:
spotcoord
#1
{
extern
column
ascii
NAME
=
_out_name
;
readonly
column
INSDC
:
SRA
:
spot_ids_found
SPOT_IDS_FOUND
=
spot_ids_found
;
ascii
_out_name
=
INSDC
:
SRA
:
format_spot_name
(
out_name_fmt
,
out_x_coord
,
out_y_coord
,
out_spot_name
)
|
INSDC
:
SRA
:
format_spot_name
(
out_name_fmt
,
out_x_coord
,
out_y_coord
)
|
INSDC
:
SRA
:
format_spot_name_no_coord
(
out_name_fmt
)
|
out_spot_name
;
}
;
table
INSDC
:
SRA
:
tbl
:
spotdesc
#1.0.2
=
INSDC
:
tbl
:
sequence
#1.0.1
{
extern
column
U8
NREADS
=
out_nreads
;
readonly
column
INSDC
:
coord
:
len
SPOT_LEN
=
spot_len
;
readonly
column
INSDC
:
coord
:
len
FIXED_SPOT_LEN
=
fixed_spot_len
;
readonly
column
INSDC
:
coord
:
zero
TRIM_START
=
trim_start
|
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
readonly
column
INSDC
:
coord
:
one
TRIM_START
=
(
INSDC
:
coord
:
one
)
<
I32
>
sum
<
1
>
(
trim_start
)
|
<
INSDC
:
coord
:
one
>
echo
<
1
>
(
)
;
readonly
column
INSDC
:
coord
:
len
TRIM_LEN
=
trim_len
|
spot_len
;
extern
column
ascii
LABEL
=
out_label
;
extern
column
INSDC
:
coord
:
zero
LABEL_START
=
out_label_start
;
extern
column
INSDC
:
coord
:
len
LABEL_LEN
=
out_label_len
;
readonly
column
U16
LABEL_START
=
cast
(
out_label_start
)
;
readonly
column
U16
LABEL_LEN
=
cast
(
out_label_len
)
;
extern
default
column
INSDC
:
SRA
:
xread_type
READ_TYPE
=
out_read_type
;
INSDC
:
SRA
:
xread_type
in_read_type
=
READ_TYPE
|
_alt_in_read_type
;
readonly
column
INSDC
:
SRA
:
read_type
READ_TYPE
=
out_read_type
|
<
INSDC
:
SRA
:
xread_type
,
INSDC
:
SRA
:
read_type
>
map
<
[
0
,
1
,
2
,
3
,
4
,
5
,
6
,
7
]
,
[
0
,
1
,
0
,
1
,
0
,
1
,
0
,
1
]
>
(
out_read_type
)
;
extern
default
column
INSDC
:
coord
:
zero
READ_START
=
out_read_start
;
extern
column
INSDC
:
coord
:
one
READ_START
=
(
INSDC
:
coord
:
one
)
<
I32
>
sum
<
1
>
(
out_read_start
)
;
extern
column
INSDC
:
coord
:
len
READ_LEN
=
out_read_len
;
readonly
column
U16
READ_START
=
cast
(
out_read_start
)
;
readonly
column
U16
READ_LEN
=
cast
(
out_read_len
)
;
INSDC
:
coord
:
len
in_read_len
=
READ_LEN
|
_alt_in_read_len
;
extern
column
INSDC
:
SRA
:
read_filter
READ_FILTER
=
out_rd_filter
|
<
INSDC
:
SRA
:
read_filter
>
echo
<
SRA_READ_FILTER_PASS
>
(
out_read_start
)
;
extern
readonly
column
INSDC
:
SRA
:
read_filter
RD_FILTER
=
out_rd_filter
;
INSDC
:
coord
:
len
spot_len
=
base_space_spot_len
|
color_space_spot_len
|
align_spot_len
;
INSDC
:
coord
:
len
fixed_spot_len
=
static_fixed_spot_len
|
base_space_fixed_spot_len
|
color_space_fixed_spot_len
;
}
;
table
INSDC
:
SRA
:
tbl
:
stats
#1.1
{
readonly
column
INSDC
:
SRA
:
spotid_t
MIN_SPOT_ID
=
min_spot_id
|
<
INSDC
:
SRA
:
spotid_t
>
echo
<
1
>
(
)
;
readonly
column
INSDC
:
SRA
:
spotid_t
MAX_SPOT_ID
=
max_spot_id
|
cast
(
spot_count
)
;
readonly
column
U64
SPOT_COUNT
=
spot_count
;
readonly
column
U64
BASE_COUNT
=
base_count
;
readonly
column
U64
BIO_BASE_COUNT
=
bio_base_count
;
readonly
column
U64
CMP_BASE_COUNT
=
cmp_base_count
|
base_count
;
U8
stats_dummy
=
in_stats_bin
;
}
;
typedef
U8
INSDC
:
SRA
:
platform_id
;
const
INSDC
:
SRA
:
platform_id
SRA_PLATFORM_UNDEFINED
=
0
;
const
INSDC
:
SRA
:
platform_id
SRA_PLATFORM_454
=
1
;
const
INSDC
:
SRA
:
platform_id
SRA_PLATFORM_ILLUMINA
=
2
;
const
INSDC
:
SRA
:
platform_id
SRA_PLATFORM_ABSOLID
=
3
;
const
INSDC
:
SRA
:
platform_id
SRA_PLATFORM_COMPLETE_GENOMICS
=
4
;
const
INSDC
:
SRA
:
platform_id
SRA_PLATFORM_HELICOS
=
5
;
const
INSDC
:
SRA
:
platform_id
SRA_PLATFORM_PACBIO_SMRT
=
6
;
const
INSDC
:
SRA
:
platform_id
SRA_PLATFORM_ION_TORRENT
=
7
;
const
INSDC
:
SRA
:
platform_id
SRA_PLATFORM_CAPILLARY
=
8
;
const
INSDC
:
SRA
:
platform_id
SRA_PLATFORM_OXFORD_NANOPORE
=
9
;
table
INSDC
:
SRA
:
tbl
:
sra
#1.0.3
=
INSDC
:
tbl
:
sequence
#1.0.1
,
INSDC
:
SRA
:
tbl
:
spotname
#1.0.1
,
INSDC
:
SRA
:
tbl
:
spotdesc
#1.0.2
,
INSDC
:
SRA
:
tbl
:
stats
#1.1.0
{
extern
column
INSDC
:
SRA
:
platform_id
PLATFORM
=
.
PLATFORM
|
out_platform
;
readonly
column
ascii
PLATFORM
=
platform_name
;
physical
column
<
INSDC
:
SRA
:
platform_id
>
zip_encoding
.
PLATFORM
=
PLATFORM
;
extern
column
INSDC
:
SRA
:
spotid_t
SPOT_ID
=
<
INSDC
:
SRA
:
spotid_t
>
add_row_id
(
.
SPOT_ID
)
|
cast
(
rowid_64
)
;
I64
rowid_64
=
row_id
(
)
;
physical
column
<
INSDC
:
SRA
:
spotid_t
>
izip_encoding
.
SPOT_ID
=
<
INSDC
:
SRA
:
spotid_t
>
sub_row_id
(
SPOT_ID
)
;
extern
column
ascii
SPOT_GROUP
=
out_spot_group
|
.
SPOT_GROUP
|
<
ascii
>
echo
<
'' > ();
ascii
in_spot_group
=
SPOT_GROUP
;
physical
column
<
ascii
>
zip_encoding
<
Z_DEFAULT_STRATEGY
,
Z_BEST_SPEED
>
.
SPOT_GROUP
=
in_spot_group
;
}
;
version
1
;
include
'vdb/vdb.vschema';
include
'insdc/insdc.vschema';
include
'csra2/stats.vschema';
table
NCBI
:
csra2
:
tbl
:
read
#1.0
=
NCBI
:
csra2
:
tbl
:
read_stats
#1
{
extern
column
INSDC
:
coord
:
len
CHUNK_SZ
;
extern
default
column
INSDC
:
dna
:
text
READ
{
read
=
out_dna_text
;
validate
=
<
INSDC
:
dna
:
text
>
compare
(
in_dna_text
,
out_dna_text
)
;
}
extern
column
INSDC
:
4
na
:
bin
READ
=
out_4na_bin
;
extern
default
column
INSDC
:
quality
:
phred
QUALITY
=
out_qual_phred
;
extern
column
INSDC
:
quality
:
text
:
phred_33
QUALITY
=
(
INSDC
:
quality
:
text
:
phred_33
)
<
B8
>
sum
<
33
>
(
out_qual_phred
)
;
extern
column
INSDC
:
quality
:
text
:
phred_64
QUALITY
=
(
INSDC
:
quality
:
text
:
phred_64
)
<
B8
>
sum
<
64
>
(
out_qual_phred
)
;
extern
column
I64
RD_ID
;
extern
column
ascii
RD_GROUP
;
extern
column
INSDC
:
SRA
:
read_filter
RD_FILTER
;
INSDC
:
dna
:
text
in_dna_text
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'.acmgrsvtwyhkdbn','NACMGRSVTWYHKDBN' > ( READ )
;
INSDC
:
4
na
:
bin
in_4na_bin
=
<
INSDC
:
4
na
:
bin
>
range_validate
<
0
,
15
>
(
READ
)
|
<
INSDC
:
dna
:
text
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
CHARSET
,
INSDC
:
4
na
:
map
:
BINSET
>
(
in_dna_text
)
;
INSDC
:
2
na
:
bin
in_2na_bin
=
INSDC
:
SEQ
:
rand_4na_2na
(
in_4na_bin
)
;
INSDC
:
4
na
:
bin
in_alt_4na_bin
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
15
,
0
,
0
,
3
,
0
,
5
,
6
,
7
,
0
,
9
,
10
,
11
,
12
,
13
,
14
,
15
]
>
(
in_4na_bin
)
;
INSDC
:
4
na
:
bin
in_stats_seq
=
in_4na_bin
;
INSDC
:
quality
:
text
:
phred_33
in_qual_text_phred_33
=
QUALITY
;
INSDC
:
quality
:
text
:
phred_64
in_qual_text_phred_64
=
QUALITY
;
INSDC
:
quality
:
phred
in_qual_phred
=
QUALITY
|
(
INSDC
:
quality
:
phred
)
<
B8
>
diff
<
33
>
(
in_qual_text_phred_33
)
|
(
INSDC
:
quality
:
phred
)
<
B8
>
diff
<
64
>
(
in_qual_text_phred_64
)
;
INSDC
:
quality
:
phred
in_stats_qual_phred
=
in_qual_phred
;
ascii
in_stats_read_group
=
in_stats_spot_group
|
RD_GROUP
;
physical
column
INSDC
:
2
na
:
packed
.
READ
=
(
INSDC
:
2
na
:
packed
)
pack
(
in_2na_bin
)
;
physical
column
<
INSDC
:
4
na
:
bin
>
zip_encoding
.
ALTREAD
=
<
INSDC
:
4
na
:
bin
>
trim
<
0
,
0
>
(
in_alt_4na_bin
)
;
physical
column
<
INSDC
:
quality
:
phred
>
delta_average_zip_encoding
.
QUALITY
=
in_qual_phred
;
INSDC
:
2
na
:
packed
out_2na_packed
=
.
READ
;
INSDC
:
2
na
:
bin
out_2na_bin
=
(
INSDC
:
2
na
:
bin
)
unpack
(
out_2na_packed
)
;
INSDC
:
4
na
:
bin
out_2na_4na_bin
=
<
INSDC
:
2
na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
2
na
:
map
:
BINSET
,
[
1
,
2
,
4
,
8
]
>
(
out_2na_bin
)
;
INSDC
:
4
na
:
bin
out_4na_bin
=
<
INSDC
:
4
na
:
bin
>
bit_or
<
ALIGN_RIGHT
>
(
out_2na_4na_bin
,
.
ALTREAD
)
|
out_2na_4na_bin
;
INSDC
:
dna
:
text
out_dna_text
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_4na_bin
)
;
INSDC
:
quality
:
phred
out_qual_phred
=
.
QUALITY
|
<
INSDC
:
quality
:
phred
>
echo
<
30
>
(
out_4na_bin
)
;
}
table
NCBI
:
csra2
:
view
:
read
#1.0
=
NCBI
:
csra2
:
tbl
:
read
#1.0
{
readonly
column
INSDC
:
coord
:
len
CHUNK_SIZE
=
.
CHUNK_SZ
|
<
INSDC
:
coord
:
len
>
echo
<
0xFFFFFFFF
>
(
)
;
readonly
column
INSDC
:
4
na
:
packed
READ
=
(
INSDC
:
4
na
:
packed
)
pack
(
out_4na_bin
)
;
readonly
column
INSDC
:
x2na
:
bin
READ
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
4
,
0
,
1
,
4
,
2
,
4
,
4
,
4
,
3
,
4
,
4
,
4
,
4
,
4
,
4
,
4
]
>
(
out_4na_bin
)
;
readonly
column
INSDC
:
2
na
:
bin
READ
=
out_2na_bin
;
readonly
column
INSDC
:
2
na
:
packed
READ
=
out_2na_packed
;
readonly
column
I64
READ_ID
=
.
RD_ID
|
row_id
(
)
;
readonly
column
ascii
READ_GROUP
=
.
RD_GROUP
|
<
ascii
>
echo
<
'' > ()
;
readonly
column
INSDC
:
SRA
:
read_filter
READ_FILTER
=
.
RD_FILTER
|
<
INSDC
:
SRA
:
read_filter
>
echo
<
SRA_READ_FILTER_PASS
>
(
)
;
}
version
1
;
include
'vdb/vdb.vschema';
include
'insdc/insdc.vschema';
include
'insdc/sra.vschema';
extern
function
U8
NCBI
:
csra2
:
stats_trigger
#1
(
B8
read_bin
*
ascii
read_group
)
;
extern
function
U8
NCBI
:
csra2
:
phred_stats_trigger
#1
(
INSDC
:
quality
:
phred
qual_bin
)
=
NCBI
:
SRA
:
phred_stats_trigger
;
table
NCBI
:
csra2
:
tbl
:
read_stats
#1
{
readonly
column
I64
MIN_READ_ID
=
min_read_id
;
readonly
column
I64
MAX_READ_ID
=
max_read_id
;
readonly
column
U64
READ_COUNT
=
read_count
;
readonly
column
U64
BASE_COUNT
=
base_count
;
readonly
column
INSDC
:
SRA
:
spotid_t
MIN_SPOT_ID
=
cast
(
min_read_id
)
;
readonly
column
INSDC
:
SRA
:
spotid_t
MAX_SPOT_ID
=
cast
(
max_read_id
)
;
readonly
column
U64
SPOT_COUNT
=
read_count
;
I64
min_read_id
=
<
I64
>
meta
:
value
<
"STATS/TABLE/READ_MIN"
>
(
)
|
<
I64
>
meta
:
value
<
"STATS/TABLE/SPOT_MIN"
>
(
)
|
<
I64
>
echo
<
1
>
(
)
;
I64
max_read_id
=
<
I64
>
meta
:
value
<
"STATS/TABLE/READ_MAX"
>
(
)
|
<
I64
>
meta
:
value
<
"STATS/TABLE/SPOT_MAX"
>
(
)
|
cast
(
read_count
)
;
U64
read_count
=
<
U64
>
meta
:
value
<
"STATS/TABLE/READ_COUNT"
>
(
)
|
<
U64
>
meta
:
value
<
"STATS/TABLE/SPOT_COUNT"
>
(
)
;
U64
base_count
=
<
U64
>
meta
:
value
<
"STATS/TABLE/BASE_COUNT"
>
(
)
;
trigger
meta_stats
=
NCBI
:
csra2
:
stats_trigger
(
in_stats_seq
,
in_stats_read_group
)
|
NCBI
:
csra2
:
stats_trigger
(
in_stats_seq
)
;
trigger
qual_stats
=
NCBI
:
csra2
:
phred_stats_trigger
#1
(
in_stats_qual_phred
)
;
}
version
1
;
include
'csra2/read.vschema';
include
'csra2/reference.vschema';
database
NCBI
:
csra2
:
db
:
aligned
#1
{
table
NCBI
:
csra2
:
view
:
read
#1.0
UNALIGNED
;
table
NCBI
:
csra2
:
view
:
reference
#1.0
REFERENCE
;
}
version
1
;
include
'vdb/vdb.vschema';
include
'csra2/stats.vschema';
table
NCBI
:
csra2
:
tbl
:
reference
#1.0
=
NCBI
:
csra2
:
tbl
:
read_stats
#1
{
extern
column
INSDC
:
coord
:
len
CHUNK_SIZE
;
extern
column
bool
CIRCULAR
;
extern
column
utf8
CANONICAL_NAME
;
extern
column
utf8
COMMON_NAME
;
extern
default
column
INSDC
:
dna
:
text
LOCAL_SEQUENCE
{
read
=
out_local_dna_text
;
validate
=
<
INSDC
:
dna
:
text
>
compare
(
in_local_dna_text
,
out_local_dna_text
)
;
}
extern
column
INSDC
:
4
na
:
bin
LOCAL_SEQUENCE
=
out_local_4na_bin
;
extern
column
<
I64
>
izip_encoding
PRIMARY_ALIGNMENT_IDS
;
extern
column
<
I64
>
izip_encoding
SECONDARY_ALIGNMENT_IDS
;
extern
column
<
INSDC
:
coord
:
zero
>
izip_encoding
OVERLAP_REF_POS
;
extern
column
<
INSDC
:
coord
:
len
>
izip_encoding
OVERLAP_REF_LEN
;
extern
column
<
U8
>
izip_encoding
CGRAPH_HIGH
;
extern
column
<
U8
>
izip_encoding
CGRAPH_LOW
;
extern
column
<
U32
>
izip_encoding
CGRAPH_MISMATCHES
;
extern
column
<
U32
>
izip_encoding
CGRAPH_INDELS
;
INSDC
:
dna
:
text
in_local_dna_text
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'.acmgrsvtwyhkdbn','NACMGRSVTWYHKDBN' > ( LOCAL_SEQUENCE );
;
INSDC
:
4
na
:
bin
in_local_4na_bin
=
<
INSDC
:
4
na
:
bin
>
range_validate
<
0
,
15
>
(
LOCAL_SEQUENCE
)
|
<
INSDC
:
dna
:
text
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
CHARSET
,
INSDC
:
4
na
:
map
:
BINSET
>
(
in_local_dna_text
)
;
INSDC
:
2
na
:
bin
in_local_2na_bin
=
INSDC
:
SEQ
:
rand_4na_2na
(
in_local_4na_bin
)
;
INSDC
:
4
na
:
bin
in_ambig_4na_bin
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
15
,
0
,
0
,
3
,
0
,
5
,
6
,
7
,
0
,
9
,
10
,
11
,
12
,
13
,
14
,
15
]
>
(
in_local_4na_bin
)
;
;
INSDC
:
4
na
:
bin
in_stats_seq
=
in_local_4na_bin
;
physical
column
INSDC
:
2
na
:
packed
.
LOCAL_SEQUENCE
=
(
INSDC
:
2
na
:
packed
)
pack
(
in_local_2na_bin
)
;
physical
column
<
INSDC
:
4
na
:
bin
>
zip_encoding
.
LOCAL_AMBIGUITY
=
<
INSDC
:
4
na
:
bin
>
trim
<
0
,
0
>
(
in_ambig_4na_bin
)
;
INSDC
:
2
na
:
packed
out_local_2na_packed
=
.
LOCAL_SEQUENCE
;
INSDC
:
2
na
:
bin
out_local_2na_bin
=
(
INSDC
:
2
na
:
bin
)
unpack
(
out_local_2na_packed
)
;
INSDC
:
4
na
:
bin
out_local_2na_4na_bin
=
<
INSDC
:
2
na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
2
na
:
map
:
BINSET
,
[
1
,
2
,
4
,
8
]
>
(
out_local_2na_bin
)
;
;
INSDC
:
4
na
:
bin
out_local_4na_bin
=
<
INSDC
:
4
na
:
bin
>
bit_or
<
ALIGN_RIGHT
>
(
out_local_2na_4na_bin
,
.
LOCAL_AMBIGUITY
)
;
INSDC
:
dna
:
text
out_local_dna_text
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_local_4na_bin
)
;
INSDC
:
coord
:
len
in_local_read_len
=
(
INSDC
:
coord
:
len
)
row_len
(
in_local_2na_bin
)
;
INSDC
:
SRA
:
xread_type
in_local_read_type
=
<
INSDC
:
SRA
:
xread_type
>
echo
<
SRA_READ_TYPE_BIOLOGICAL
>
(
)
;
}
table
NCBI
:
csra2
:
view
:
reference
#1.0
=
NCBI
:
csra2
:
tbl
:
reference
#1.0
{
readonly
column
bool
EXTERNAL
=
<
bool
>
exists
<
false
>
(
.
LOCAL_SEQUENCE
)
|
<
bool
>
echo
<
true
>
(
)
;
default
readonly
column
INSDC
:
dna
:
text
SEQUENCE
=
out_dna_text
;
readonly
column
INSDC
:
4
na
:
bin
SEQUENCE
=
out_4na_bin
;
readonly
column
INSDC
:
4
na
:
packed
SEQUENCE
=
(
INSDC
:
4
na
:
packed
)
pack
(
out_4na_bin
)
;
readonly
column
INSDC
:
x2na
:
bin
SEQUENCE
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
4
,
0
,
1
,
4
,
2
,
4
,
4
,
4
,
3
,
4
,
4
,
4
,
4
,
4
,
4
,
4
]
>
(
out_4na_bin
)
;
readonly
column
INSDC
:
2
na
:
bin
SEQUENCE
=
out_2na_bin
;
readonly
column
INSDC
:
2
na
:
packed
SEQUENCE
=
pack
(
out_2na_bin
)
;
readonly
column
INSDC
:
quality
:
phred
QUALITY
=
out_qual_phred
;
readonly
column
INSDC
:
coord
:
len
MAX_SEQ_LEN
=
.
CHUNK_SIZE
;
readonly
column
ascii
SEQ_ID
=
cast
(
.
CANONICAL_NAME
)
;
INSDC
:
4
na
:
bin
out_4na_bin
=
out_local_4na_bin
;
INSDC
:
dna
:
text
out_dna_text
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_4na_bin
)
;
INSDC
:
2
na
:
bin
out_2na_bin
=
INSDC
:
SEQ
:
rand_4na_2na
(
out_4na_bin
)
;
INSDC
:
quality
:
phred
out_qual_phred
=
<
INSDC
:
quality
:
phred
>
echo
<
30
>
(
SEQUENCE
)
;
INSDC
:
quality
:
phred
in_stats_qual_phred
=
out_qual_phred
;
}
version
1
;
include
'insdc/insdc.vschema';
include
'vdb/vdb.vschema';
include
'insdc/sra.vschema';
table
NCBI
:
align
:
tbl
:
mate_cache
#1.1
{
extern
column
<
U32
>
izip_encoding
SAM_FLAGS_CACHE
;
extern
column
<
INSDC
:
quality
:
text
:
phred_33
>
zip_encoding
SAM_QUALITY_CACHE
;
extern
column
<
I32
>
izip_encoding
TEMPLATE_LEN_CACHE
;
extern
column
<
I64
>
izip_encoding
MATE_ALIGN_ID_CACHE
;
extern
column
<
ascii
>
zip_encoding
MATE_REF_NAME_CACHE
;
extern
column
<
INSDC
:
coord
:
zero
>
izip_encoding
MATE_REF_POS_CACHE
;
extern
column
<
U8
>
izip_encoding
ALIGNMENT_COUNT_CACHE
;
extern
column
<
INSDC
:
SRA
:
read_filter
>
zip_encoding
RD_FILTER_CACHE
;
readonly
column
INSDC
:
SRA
:
read_filter
READ_FILTER_CACHE
=
.
RD_FILTER_CACHE
;
extern
column
<
ascii
>
zip_encoding
SPOT_GROUP_CACHE
;
readonly
column
ascii
SEQ_SPOT_GROUP_CACHE
=
.
SPOT_GROUP_CACHE
;
}
;
database
NCBI
:
align
:
db
:
mate_cache
#1
{
table
NCBI
:
align
:
tbl
:
mate_cache
#1.1
PRIMARY_ALIGNMENT
;
}
;
version
1
;
include
'vdb/vdb.vschema';
include
'ncbi/seq.vschema';
include
'ncbi/sra.vschema';
include
'ncbi/stats.vschema';
include
'align/seq.vschema';
include
'align/qstat.vschema';
include
'sra/abi.vschema';
include
'align/mate-cache.vschema';
typedef
U32
NCBI
:
align
:
ploidy
;
typedef
U8
NCBI
:
align
:
ro_type
;
const
NCBI
:
align
:
ro_type
NCBI
:
align
:
ro_normal
=
0
;
const
NCBI
:
align
:
ro_type
NCBI
:
align
:
ro_soft_clip
=
1
;
const
NCBI
:
align
:
ro_type
NCBI
:
align
:
ro_intron_plus
=
2
;
const
NCBI
:
align
:
ro_type
NCBI
:
align
:
ro_intron_minus
=
3
;
const
NCBI
:
align
:
ro_type
NCBI
:
align
:
ro_intron_unknown
=
4
;
const
NCBI
:
align
:
ro_type
NCBI
:
align
:
ro_complete_genomics
=
5
;
extern
function
ascii
NCBI
:
align
:
cigar
#1
<
U8
ctype
>
(
bool
has_mismatch
,
bool
has_ref_offset
,
I32
ref_offset
,
*
INSDC
:
coord
:
len
ref_len
)
=
ALIGN
:
cigar
;
extern
function
<
type
T
>
T
NCBI
:
align
:
cigar
#2.0
<
U8
ctype
>
(
bool
has_mismatch
,
bool
has_ref_offset
,
I32
ref_offset
,
INSDC
:
coord
:
len
read_len
,
*
INSDC
:
coord
:
len
ref_len
,
NCBI
:
align
:
ro_type
ref_offset_type
)
=
ALIGN
:
cigar_2
;
extern
function
U32
NCBI
:
align
:
edit_distance
#1
(
bool
has_mismatch
,
bool
has_ref_offset
,
I32
ref_offset
)
;
extern
function
U32
NCBI
:
align
:
edit_distance
#2
(
bool
has_mismatch
,
bool
has_ref_offset
,
I32
ref_offset
,
INSDC
:
coord
:
len
ref_len
,
*
INSDC
:
coord
:
len
read_len
)
=
NCBI
:
align
:
edit_distance_2
;
extern
function
U32
NCBI
:
align
:
edit_distance
#3
(
bool
has_mismatch
,
bool
has_ref_offset
,
I32
ref_offset
,
NCBI
:
align
:
ro_type
ref_offset_type
,
INSDC
:
coord
:
len
read_len
)
=
NCBI
:
align
:
edit_distance_3
;
extern
function
ascii
NCBI
:
align
:
rna_orientation
#1
(
NCBI
:
align
:
ro_type
ref_offset_type
)
;
extern
function
<
type
T
>
T
NCBI
:
align
:
project_from_sequence
#1
<
ascii
col
>
(
I64
seq_spot_id
,
INSDC
:
coord
:
one
seq_read_id
)
=
ALIGN
:
project_from_sequence
;
extern
function
INSDC
:
4
na
:
bin
NCBI
:
align
:
align_restore_read
#1
(
INSDC
:
4
na
:
bin
ref_read
,
bool
has_mismatch
,
INSDC
:
4
na
:
bin
mismatch
,
bool
has_ref_offset
,
I32
ref_offset
*
INSDC
:
coord
:
len
read_len
)
=
ALIGN
:
align_restore_read
;
extern
function
INSDC
:
4
na
:
bin
NCBI
:
align
:
raw_restore_read
#1
(
INSDC
:
4
na
:
bin
align_read
,
bool
ref_orientation
)
=
ALIGN
:
raw_restore_read
;
extern
function
INSDC
:
quality
:
phred
NCBI
:
align
:
raw_restore_qual
#1
(
INSDC
:
quality
:
phred
align_qual
,
bool
ref_orientation
)
;
extern
function
INSDC
:
4
na
:
bin
NCBI
:
align
:
ref_sub_select
#1
(
I64
id
,
INSDC
:
coord
:
zero
start
,
INSDC
:
coord
:
len
len
*
U32
ref_ploidy
)
=
ALIGN
:
ref_sub_select
;
extern
function
INSDC
:
4
na
:
bin
NCBI
:
align
:
ref_restore_read
#1
(
INSDC
:
4
na
:
bin
cmp_rd
,
ascii
seq_id
,
INSDC
:
coord
:
one
seq_start
,
INSDC
:
coord
:
len
seq_len
)
=
ALIGN
:
ref_restore_read
;
extern
function
INSDC
:
4
na
:
bin
NCBI
:
align
:
seq_restore_read
#1
(
INSDC
:
4
na
:
bin
cmp_rd
,
I64
align_id
,
INSDC
:
coord
:
len
read_len
,
INSDC
:
SRA
:
xread_type
rd_type
)
=
ALIGN
:
seq_restore_read
;
extern
function
ascii
NCBI
:
align
:
seq_restore_linkage_group
#1
(
ascii
cmp_linkage_group
,
I64
align_id
)
=
ALIGN
:
seq_restore_linkage_group
;
extern
function
bool
NCBI
:
align
:
generate_has_mismatch
#1
(
INSDC
:
4
na
:
bin
reference
,
INSDC
:
4
na
:
bin
subject
,
bool
has_ref_offset
,
I32
ref_offset
)
=
ALIGN
:
generate_has_mismatch
;
extern
function
INSDC
:
4
na
:
bin
NCBI
:
align
:
generate_mismatch
#1
(
INSDC
:
4
na
:
bin
reference
,
INSDC
:
4
na
:
bin
subject
,
bool
has_ref_offset
,
I32
ref_offset
)
=
ALIGN
:
generate_mismatch
;
extern
function
INSDC
:
coord
:
zero
NCBI
:
align
:
ref_pos
#1
(
I64
ref_id
,
INSDC
:
coord
:
zero
ref_start
)
;
extern
function
ascii
NCBI
:
align
:
ref_name
#1
(
I64
ref_id
)
;
extern
function
ascii
NCBI
:
align
:
ref_seq_id
#1
(
I64
ref_id
)
;
extern
function
I64
NCBI
:
align
:
local_ref_id
#1
(
U64
global_ref_start
)
;
extern
function
INSDC
:
coord
:
zero
NCBI
:
align
:
local_ref_start
#1
(
U64
global_ref_start
)
;
extern
function
I64
NCBI
:
align
:
not_my_row
#1
(
I64
list
)
;
extern
function
I32
NCBI
:
align
:
template_len
#1
(
INSDC
:
coord
:
zero
pos
,
INSDC
:
coord
:
zero
mate_pos
,
INSDC
:
coord
:
len
reflen
,
INSDC
:
coord
:
len
mate_reflen
,
ascii
ref_name
,
ascii
mate_ref_name
,
INSDC
:
coord
:
one
read_id
)
;
extern
function
U32
NCBI
:
align
:
get_sam_flags
#1
(
INSDC
:
coord
:
len
read_len
,
INSDC
:
coord
:
one
read_id
,
I32
template_len
,
bool
strand
,
bool
mate_strand
,
bool
is_secondary
,
*
INSDC
:
SRA
:
read_filter
filter
)
;
extern
function
U32
NCBI
:
align
:
get_sam_flags
#2
(
I64
mate_id
,
INSDC
:
coord
:
one
read_id
,
I32
template_len
,
bool
strand
,
bool
mate_strand
,
bool
is_secondary
,
*
INSDC
:
SRA
:
read_filter
filter
)
=
NCBI
:
align
:
get_sam_flags_2
;
extern
function
INSDC
:
coord
:
len
NCBI
:
align
:
get_left_soft_clip
#1
(
bool
has_ref_offset
,
I32
ref_offset
)
;
extern
function
INSDC
:
coord
:
len
NCBI
:
align
:
get_left_soft_clip
#2
(
bool
has_ref_offset
,
I32
ref_offset
,
INSDC
:
coord
:
len
read_len
)
=
NCBI
:
align
:
get_left_soft_clip_2
;
extern
function
INSDC
:
coord
:
len
NCBI
:
align
:
get_right_soft_clip
#1
(
bool
has_mismatch
,
INSDC
:
coord
:
len
left_clip
*
bool
has_ref_offset
)
;
extern
function
INSDC
:
coord
:
len
NCBI
:
align
:
get_right_soft_clip
#2
(
bool
has_mismatch
,
INSDC
:
coord
:
len
left_clip
,
bool
has_ref_offset
,
I32
ref_offset
)
=
NCBI
:
align
:
get_right_soft_clip_2
;
extern
function
INSDC
:
coord
:
len
NCBI
:
align
:
get_right_soft_clip
#3
(
bool
has_ref_offset
,
I32
ref_offset
,
INSDC
:
coord
:
len
ref_len
)
=
NCBI
:
align
:
get_right_soft_clip_3
;
extern
function
INSDC
:
coord
:
len
NCBI
:
align
:
get_right_soft_clip
#4
(
bool
has_ref_offset
,
I32
ref_offset
,
INSDC
:
coord
:
len
read_len
,
INSDC
:
coord
:
len
ref_len
)
=
NCBI
:
align
:
get_right_soft_clip_4
;
extern
function
INSDC
:
coord
:
len
NCBI
:
align
:
get_right_soft_clip
#5
(
bool
has_ref_offset
,
I32
ref_offset
,
NCBI
:
align
:
ro_type
ref_offset_type
,
INSDC
:
coord
:
len
read_len
)
=
NCBI
:
align
:
get_right_soft_clip_5
;
extern
function
ascii
NCBI
:
align
:
get_clipped_cigar
#1
(
ascii
cigar
)
;
extern
function
<
type
T
>
T
NCBI
:
align
:
get_clipped_cigar
#2
(
ascii
cigar
,
INSDC
:
coord
:
len
cigar_len
)
=
NCBI
:
align
:
get_clipped_cigar_2
;
extern
function
I32
NCBI
:
align
:
get_clipped_ref_offset
#1
(
bool
has_ref_offset
,
I32
ref_offset
)
;
extern
function
<
type
T
>
T
NCBI
:
align
:
clip
#1
(
T
object
,
INSDC
:
coord
:
len
left_clip
,
INSDC
:
coord
:
len
right_clip
)
;
extern
function
<
type
T
>
T
NCBI
:
align
:
clip
#2
(
T
object
,
INSDC
:
coord
:
len
read_len
,
INSDC
:
coord
:
len
left_clip
,
INSDC
:
coord
:
len
right_clip
)
=
NCBI
:
align
:
clip_2
;
extern
function
INSDC
:
coord
:
len
NCBI
:
align
:
get_ref_len
#1
(
bool
has_ref_offset
,
I32
ref_offset
,
*
INSDC
:
coord
:
len
right_clip
)
;
extern
function
INSDC
:
coord
:
len
NCBI
:
align
:
get_ref_len_2
#2
(
bool
has_ref_offset
,
I32
ref_offset
)
=
NCBI
:
align
:
get_ref_len_2
;
extern
function
ascii
NCBI
:
align
:
get_mismatch_read
#1
(
bool
has_mismatch
,
INSDC
:
dna
:
text
mismatch
)
;
function
bool
NCBI
:
align
:
get_ref_mismatch
#1
(
bool
has_mismatch
,
bool
has_ref_offset
,
I32
ref_offset
,
INSDC
:
coord
:
len
ref_len
)
;
function
bool
NCBI
:
align
:
get_ref_insert
#1
(
bool
has_mismatch
,
bool
has_ref_offset
,
I32
ref_offset
,
INSDC
:
coord
:
len
ref_len
)
;
function
bool
NCBI
:
align
:
get_ref_delete
#1
(
bool
has_mismatch
,
bool
has_ref_offset
,
I32
ref_offset
,
INSDC
:
coord
:
len
ref_len
)
;
extern
function
INSDC
:
quality
:
phred
NCBI
:
align
:
compress_quality
#1
(
INSDC
:
quality
:
phred
quality
,
bool
preserved
)
;
extern
function
INSDC
:
quality
:
phred
NCBI
:
align
:
decompress_quality
#1
<
INSDC
:
quality
:
phred
restored_qual_value
>
(
INSDC
:
quality
:
phred
cmp_quality
,
bool
preserved
)
;
extern
function
INSDC
:
coord
:
zero
NCBI
:
align
:
make_read_start
#1
(
INSDC
:
coord
:
len
read_len
)
;
extern
function
<
type
T
>
T
NCBI
:
align
:
make_cmp_read_desc
#1
<
bool
invert
>
(
T
operand
,
I64
align_id
)
;
extern
function
<
type
T
>
T
NCBI
:
align
:
seq_construct_read
#1
(
T
aligned
,
INSDC
:
coord
:
len
aligned_read_len
,
T
unaligned
,
INSDC
:
coord
:
len
unaligned_read_len
)
;
extern
function
I64
NCBI
:
align
:
get_mate_align_id
#1
(
I64
spot_id
)
;
table
NCBI
:
align
:
tbl
:
ref_block_cmn
#1.0.0
{
readonly
column
ascii
REF_TABLE
=
<
ascii
>
meta
:
read
<
"CONFIG/REF_TABLE"
>
(
)
|
<
ascii
>
echo
<
'REFERENCE' > ();
extern
column
I64
REF_ID
=
out_ref_id
;
extern
column
INSDC
:
coord
:
zero
REF_START
=
out_ref_start
;
extern
column
U64
GLOBAL_REF_START
=
out_global_ref_start
;
INSDC
:
coord
:
len
out_ref_len_internal
=
NCBI
:
align
:
get_ref_len_2
(
out_has_ref_offset
,
out_ref_offset
)
|
NCBI
:
align
:
get_ref_len
(
out_has_ref_offset
,
out_ref_offset
)
;
INSDC
:
coord
:
len
out_ref_len
=
.
REF_LEN
|
out_ref_len_internal
;
physical
column
<
INSDC
:
coord
:
len
>
izip_encoding
.
REF_LEN
=
REF_LEN
;
extern
column
INSDC
:
coord
:
len
REF_LEN
=
out_ref_len
;
extern
column
bool_encoding
REF_ORIENTATION
;
extern
column
<
U32
>
izip_encoding
REF_PLOIDY
;
readonly
column
INSDC
:
coord
:
zero
REF_POS
=
NCBI
:
align
:
ref_pos
(
out_ref_id
,
out_ref_start
)
;
readonly
column
ascii
REF_NAME
=
NCBI
:
align
:
ref_name
(
out_ref_id
)
;
readonly
column
ascii
REF_SEQ_ID
=
NCBI
:
align
:
ref_seq_id
(
out_ref_id
)
|
<
ascii
>
echo
<
'' > ();
}
;
table
NCBI
:
align
:
tbl
:
global_ref_block
#1.0.0
=
NCBI
:
align
:
tbl
:
ref_block_cmn
#1.0.0
{
U64
out_global_ref_start
=
.
GLOBAL_REF_START
;
physical
<
U64
>
izip_encoding
.
GLOBAL_REF_START
=
GLOBAL_REF_START
;
I64
out_ref_id
=
NCBI
:
align
:
local_ref_id
(
.
GLOBAL_REF_START
)
;
INSDC
:
coord
:
zero
out_ref_start
=
NCBI
:
align
:
local_ref_start
(
.
GLOBAL_REF_START
)
;
}
;
table
NCBI
:
align
:
tbl
:
local_ref_block
#1.0.0
=
NCBI
:
align
:
tbl
:
ref_block_cmn
#1.0.0
{
I64
out_ref_id
=
.
REF_ID
;
physical
<
I64
>
izip_encoding
.
REF_ID
=
REF_ID
;
INSDC
:
coord
:
zero
out_ref_start
=
.
REF_START
;
physical
<
INSDC
:
coord
:
zero
>
izip_encoding
.
REF_START
=
REF_START
;
}
;
table
NCBI
:
align
:
tbl
:
align_cmn
#2.1
=
NCBI
:
tbl
:
base_space_common
#1.0.3
,
NCBI
:
SRA
:
tbl
:
stats
#1.2.0
,
NCBI
:
align
:
tbl
:
ref_block_cmn
#1.0.0
{
bool
is_secondary
=
out_is_secondary
;
extern
column
<
U32
>
izip_encoding
TMP_KEY_ID
;
extern
column
<
ascii
>
zip_encoding
LINKAGE_GROUP
;
extern
column
<
I64
>
izip_encoding
SEQ_SPOT_ID
;
extern
column
<
INSDC
:
coord
:
one
>
izip_encoding
SEQ_READ_ID
;
readonly
column
INSDC
:
coord
:
len
LEFT_SOFT_CLIP
=
NCBI
:
align
:
get_left_soft_clip
(
HAS_REF_OFFSET
,
REF_OFFSET
,
out_read_len
)
;
INSDC
:
coord
:
len
out_right_clip
=
NCBI
:
align
:
get_right_soft_clip
#5
(
out_has_ref_offset
,
out_ref_offset
,
out_ro_type
,
out_read_len
)
|
NCBI
:
align
:
get_right_soft_clip
#4
(
out_has_ref_offset
,
out_ref_offset
,
out_read_len
,
out_ref_len
)
|
NCBI
:
align
:
get_right_soft_clip
#3
(
out_has_ref_offset
,
out_ref_offset
,
out_ref_len
)
|
NCBI
:
align
:
get_right_soft_clip
#2
(
out_has_mismatch
,
LEFT_SOFT_CLIP
,
out_has_ref_offset
,
out_ref_offset
)
;
readonly
column
INSDC
:
coord
:
len
RIGHT_SOFT_CLIP
=
out_right_clip
;
readonly
column
ascii
CLIPPED_CIGAR_LONG
=
<
ascii
>
NCBI
:
align
:
get_clipped_cigar
(
CIGAR_LONG
,
CIGAR_LONG_LEN
)
;
readonly
column
INSDC
:
coord
:
len
CLIPPED_CIGAR_LONG_LEN
=
<
INSDC
:
coord
:
len
>
NCBI
:
align
:
get_clipped_cigar
(
CIGAR_LONG
,
CIGAR_LONG_LEN
)
;
readonly
column
ascii
CLIPPED_CIGAR_SHORT
=
<
ascii
>
NCBI
:
align
:
get_clipped_cigar
(
CIGAR_SHORT
,
CIGAR_SHORT_LEN
)
;
readonly
column
INSDC
:
coord
:
len
CLIPPED_CIGAR_SHORT_LEN
=
<
INSDC
:
coord
:
len
>
NCBI
:
align
:
get_clipped_cigar
(
CIGAR_SHORT
,
CIGAR_SHORT_LEN
)
;
bool
out_clipped_has_mismatch
=
<
bool
>
NCBI
:
align
:
clip
(
out_has_mismatch
,
out_read_len
,
LEFT_SOFT_CLIP
,
RIGHT_SOFT_CLIP
)
;
readonly
column
ascii
CLIPPED_HAS_MISMATCH
=
<
U8
,
ascii
>
map
<
[
0
,
1
]
,
'01'  > ( out_clipped_has_mismatch );
readonly
column
bool
CLIPPED_HAS_MISMATCH
=
out_clipped_has_mismatch
;
bool
out_clipped_has_ref_offset
=
<
bool
>
NCBI
:
align
:
clip
(
HAS_REF_OFFSET
,
out_read_len
,
LEFT_SOFT_CLIP
,
RIGHT_SOFT_CLIP
)
;
readonly
column
ascii
CLIPPED_HAS_REF_OFFSET
=
<
U8
,
ascii
>
map
<
[
0
,
1
]
,
'01'  > ( out_clipped_has_ref_offset );
readonly
column
bool
CLIPPED_HAS_REF_OFFSET
=
out_clipped_has_ref_offset
;
readonly
column
INSDC
:
dna
:
text
CLIPPED_MISMATCH
=
<
INSDC
:
dna
:
text
>
NCBI
:
align
:
clip
#1
(
out_mismatch_dna_text
,
LEFT_SOFT_CLIP
,
RIGHT_SOFT_CLIP
)
;
readonly
column
I32
CLIPPED_REF_OFFSET
=
NCBI
:
align
:
get_clipped_ref_offset
(
HAS_REF_OFFSET
,
REF_OFFSET
)
;
readonly
column
INSDC
:
quality
:
phred
CLIPPED_QUALITY
=
<
INSDC
:
quality
:
phred
>
NCBI
:
align
:
clip
(
out_qual_phred
,
out_read_len
,
LEFT_SOFT_CLIP
,
RIGHT_SOFT_CLIP
)
;
readonly
column
INSDC
:
dna
:
text
CLIPPED_READ
=
<
INSDC
:
dna
:
text
>
NCBI
:
align
:
clip
(
READ
,
out_read_len
,
LEFT_SOFT_CLIP
,
RIGHT_SOFT_CLIP
)
;
extern
column
<
NCBI
:
align
:
ploidy
>
izip_encoding
PLOIDY
;
U32
out_nreads
=
.
PLOIDY
|
<
U32
>
echo
<
1
>
(
)
;
physical
<
INSDC
:
coord
:
zero
>
izip_encoding
.
READ_START
=
READ_START
;
INSDC
:
coord
:
zero
out_read_start
=
.
READ_START
|
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
physical
<
INSDC
:
coord
:
len
>
izip_encoding
.
READ_LEN
=
READ_LEN
;
INSDC
:
coord
:
len
align_spot_len
=
(
INSDC
:
coord
:
len
)
row_len
(
out_has_ref_offset
)
;
INSDC
:
coord
:
len
out_read_len
=
.
READ_LEN
|
align_spot_len
;
extern
column
INSDC
:
quality
:
phred
CMP_QUALITY
=
.
CMP_QUALITY
|
out_cmp_quality
;
physical
column
<
INSDC
:
quality
:
phred
>
zip_encoding
.
CMP_QUALITY
=
CMP_QUALITY
;
INSDC
:
quality
:
phred
out_raw_qual
=
<
INSDC
:
quality
:
phred
>
NCBI
:
align
:
project_from_sequence
<
'( INSDC:quality:phred ) QUALITY'> ( .SEQ_SPOT_ID, .SEQ_READ_ID );
INSDC
:
quality
:
phred
out_qual_phred
=
NCBI
:
align
:
raw_restore_qual
(
out_raw_qual
,
.
REF_ORIENTATION
)
|
<
INSDC
:
quality
:
phred
>
echo
<
30
>
(
out_4na_bin
)
;
readonly
column
INSDC
:
quality
:
text
:
phred_33
SAM_QUALITY
=
QUALITY
;
ascii
out_spot_group
=
<
ascii
>
simple_sub_select
<
'SEQUENCE','SPOT_GROUP'> (.SEQ_SPOT_ID);
INSDC
:
SRA
:
spotid_t
tmp_seq_spot_id
=
cast
(
.
SEQ_SPOT_ID
)
;
physical
<
ascii
>
zip_encoding
.
SEQ_NAME
=
SEQ_NAME
;
extern
column
ascii
SEQ_NAME
=
.
SEQ_NAME
|
<
ascii
>
simple_sub_select
<
'SEQUENCE','NAME'> (.SEQ_SPOT_ID)
|
sprintf
<
"%u"
>
(
tmp_seq_spot_id
)
;
INSDC
:
coord
:
len
projected_read_len
=
<
INSDC
:
coord
:
len
>
simple_sub_select
<
'SEQUENCE', 'READ_LEN' > ( .SEQ_SPOT_ID );
readonly
column
U32
SAM_FLAGS
=
NCBI
:
align
:
get_sam_flags
#1
(
projected_read_len
,
.
SEQ_READ_ID
,
out_template_len
,
REF_ORIENTATION
,
out_mate_ref_orientation
,
is_secondary
,
out_rd_filter
)
|
NCBI
:
align
:
get_sam_flags
#2
(
out_mate_align_id
,
.
SEQ_READ_ID
,
out_template_len
,
REF_ORIENTATION
,
out_mate_ref_orientation
,
is_secondary
,
out_rd_filter
)
;
ascii
out_name_fmt
=
<
ascii
>
echo
<
'$R' > ();
INSDC
:
coord
:
zero
trim_start
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
coord
:
len
trim_len
=
align_spot_len
;
ascii
out_label
=
.
LABEL
|
<
ascii
>
echo
<
"ploidy1"
>
(
)
;
INSDC
:
coord
:
zero
out_label_start
=
.
LABEL_START
|
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
coord
:
len
out_label_len
=
.
LABEL_LEN
|
<
INSDC
:
coord
:
len
>
echo
<
7
>
(
)
;
physical
<
INSDC
:
SRA
:
read_filter
>
zip_encoding
.
RD_FILTER
=
READ_FILTER
;
INSDC
:
SRA
:
read_filter
out_rd_filter
=
.
RD_FILTER
|
<
INSDC
:
SRA
:
read_filter
>
NCBI
:
align
:
project_from_sequence
<
'READ_FILTER' > ( .SEQ_SPOT_ID, .SEQ_READ_ID )
|
<
INSDC
:
SRA
:
read_filter
>
echo
<
SRA_READ_FILTER_PASS
>
(
out_read_len
)
;
INSDC
:
SRA
:
platform_id
out_platform
=
.
PLATFORM
|
<
INSDC
:
SRA
:
platform_id
>
simple_sub_select
<
'SEQUENCE','PLATFORM'> (.SEQ_SPOT_ID)
|
<
INSDC
:
SRA
:
platform_id
>
echo
<
SRA_PLATFORM_UNDEFINED
>
(
)
;
U8
out_alignment_count
=
<
U8
>
NCBI
:
align
:
project_from_sequence
<
'ALIGNMENT_COUNT' > ( .SEQ_SPOT_ID, .SEQ_READ_ID );
INSDC
:
SRA
:
xread_type
out_read_type
=
<
INSDC
:
SRA
:
xread_type
>
echo
<
3
>
(
out_read_len
)
;
bool
in_stats_bin
=
HAS_REF_OFFSET
;
INSDC
:
coord
:
len
_alt_in_read_len
=
READ_LEN
|
(
INSDC
:
coord
:
len
)
row_len
#1
(
HAS_REF_OFFSET
)
;
INSDC
:
SRA
:
xread_type
_alt_in_read_type
=
READ_TYPE
|
<
INSDC
:
SRA
:
xread_type
>
echo
<
SRA_READ_TYPE_BIOLOGICAL
>
(
_alt_in_read_len
)
;
readonly
column
ascii
MISMATCH_READ
=
NCBI
:
align
:
get_mismatch_read
(
out_has_mismatch
,
out_mismatch_dna_text
)
;
extern
column
<
I32
>
izip_encoding
MAPQ
;
extern
column
INSDC
:
coord
:
zero
MATE_REF_POS
=
out_mate_ref_pos
;
extern
column
INSDC
:
coord
:
len
MATE_REF_LEN
=
out_mate_ref_len
;
extern
column
I64
MATE_REF_ID
=
out_mate_ref_id
;
extern
column
I32
TEMPLATE_LEN
=
out_template_len
;
extern
column
bool
MATE_REF_ORIENTATION
=
out_mate_ref_orientation
;
readonly
column
ascii
MATE_REF_NAME
=
NCBI
:
align
:
ref_name
(
out_mate_ref_id
)
;
readonly
column
ascii
MATE_REF_SEQ_ID
=
NCBI
:
align
:
ref_seq_id
(
out_mate_ref_id
)
;
readonly
column
U8
ALIGNMENT_COUNT
=
out_alignment_count
;
readonly
column
ascii
HAS_REF_OFFSET
=
<
U8
,
ascii
>
map
<
[
0
,
1
]
,
'01'  > ( out_has_ref_offset );
extern
column
bool_encoding
HAS_REF_OFFSET
;
bool
out_has_ref_offset
=
.
HAS_REF_OFFSET
;
extern
column
<
I32
>
izip_encoding
REF_OFFSET
;
I32
out_ref_offset
=
.
REF_OFFSET
;
extern
column
<
NCBI
:
align
:
ro_type
>
izip_encoding
REF_OFFSET_TYPE
;
NCBI
:
align
:
ro_type
out_ro_type
=
.
REF_OFFSET_TYPE
;
readonly
column
I64
ALIGN_ID
=
row_id
(
)
;
readonly
column
INSDC
:
dna
:
text
REF_READ
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
REF_READ
)
;
readonly
column
INSDC
:
4
na
:
bin
REF_READ
=
NCBI
:
align
:
ref_sub_select
(
out_ref_id
,
out_ref_start
,
out_ref_len
,
.
REF_PLOIDY
)
|
NCBI
:
align
:
ref_sub_select
(
out_ref_id
,
out_ref_start
,
out_ref_len
)
;
INSDC
:
4
na
:
bin
ref_read_internal
=
NCBI
:
align
:
ref_sub_select
(
out_ref_id
,
out_ref_start
,
out_ref_len_internal
,
.
REF_PLOIDY
)
|
NCBI
:
align
:
ref_sub_select
(
out_ref_id
,
out_ref_start
,
out_ref_len_internal
)
;
INSDC
:
dna
:
text
out_dna_text
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_4na_bin
)
;
readonly
column
INSDC
:
dna
:
text
RAW_READ
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_raw_read
)
;
readonly
column
INSDC
:
4
na
:
bin
RAW_READ
=
out_raw_read
;
readonly
column
ascii
CIGAR_LONG
=
<
ascii
>
NCBI
:
align
:
cigar
#2
<
1
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
,
out_ref_len
,
out_ro_type
)
|
<
ascii
>
NCBI
:
align
:
cigar
#2
<
1
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
,
out_ref_len
)
|
<
ascii
>
NCBI
:
align
:
cigar
#2
<
1
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
)
;
readonly
column
INSDC
:
coord
:
len
CIGAR_LONG_LEN
=
<
INSDC
:
coord
:
len
>
NCBI
:
align
:
cigar
#2
<
1
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
,
out_ref_len
,
out_ro_type
)
|
<
INSDC
:
coord
:
len
>
NCBI
:
align
:
cigar
#2
<
1
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
,
out_ref_len
)
|
<
INSDC
:
coord
:
len
>
NCBI
:
align
:
cigar
#2
<
1
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
)
;
readonly
column
ascii
CIGAR_SHORT
=
<
ascii
>
NCBI
:
align
:
cigar
#2
<
0
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
,
out_ref_len
,
out_ro_type
)
|
<
ascii
>
NCBI
:
align
:
cigar
#2
<
0
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
,
out_ref_len
)
|
<
ascii
>
NCBI
:
align
:
cigar
#2
<
0
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
)
;
readonly
column
INSDC
:
coord
:
len
CIGAR_SHORT_LEN
=
<
INSDC
:
coord
:
len
>
NCBI
:
align
:
cigar
#2
<
0
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
,
out_ref_len
,
out_ro_type
)
|
<
INSDC
:
coord
:
len
>
NCBI
:
align
:
cigar
#2
<
0
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
,
out_ref_len
)
|
<
INSDC
:
coord
:
len
>
NCBI
:
align
:
cigar
#2
<
0
>
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_read_len
)
;
readonly
column
ascii
RNA_ORIENTATION
=
NCBI
:
align
:
rna_orientation
(
out_ro_type
)
;
readonly
column
U32
EDIT_DISTANCE
=
NCBI
:
align
:
edit_distance
#3
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_ro_type
,
out_read_len
)
|
NCBI
:
align
:
edit_distance
#2
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_ref_len
,
out_read_len
)
|
NCBI
:
align
:
edit_distance
#2
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_ref_len
)
|
NCBI
:
align
:
edit_distance
#1
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
)
;
readonly
column
ascii
HAS_MISMATCH
=
<
U8
,
ascii
>
map
<
[
0
,
1
]
,
'01'  > ( out_has_mismatch );
readonly
column
ascii
SEQ_SPOT_GROUP
=
out_spot_group
;
bool
out_ref_mismatch
=
NCBI
:
align
:
get_ref_mismatch
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_ref_len
)
;
readonly
column
ascii
REF_MISMATCH
=
<
U8
,
ascii
>
map
<
[
0
,
1
]
,
'01'  > ( out_ref_mismatch );
readonly
column
bool
REF_MISMATCH
=
out_ref_mismatch
;
bool
out_ref_insert
=
NCBI
:
align
:
get_ref_insert
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_ref_len
)
;
readonly
column
ascii
REF_INSERT
=
<
U8
,
ascii
>
map
<
[
0
,
1
]
,
'01'  > ( out_ref_insert );
readonly
column
bool
REF_INSERT
=
out_ref_insert
;
bool
out_ref_delete
=
NCBI
:
align
:
get_ref_delete
(
out_has_mismatch
,
out_has_ref_offset
,
out_ref_offset
,
out_ref_len
)
;
readonly
column
ascii
REF_DELETE
=
<
U8
,
ascii
>
map
<
[
0
,
1
]
,
'01'  > ( out_ref_delete );
readonly
column
bool
REF_DELETE
=
out_ref_delete
;
}
;
table
NCBI
:
align
:
tbl
:
align_full
#1.1
=
NCBI
:
align
:
tbl
:
align_cmn
#2.1
{
bool
out_is_secondary
=
<
bool
>
echo
<
true
>
(
)
;
INSDC
:
4
na
:
bin
out_raw_read
=
<
INSDC
:
4
na
:
bin
>
simple_sub_select
<
'PRIMARY_ALIGNMENT', '( INSDC:4na:bin ) RAW_READ' > (.PRIMARY_ALIGNMENT_ID)
|
<
INSDC
:
4
na
:
bin
>
NCBI
:
align
:
project_from_sequence
<
'( INSDC:4na:bin ) READ'> ( .SEQ_SPOT_ID, .SEQ_READ_ID );
INSDC
:
4
na
:
bin
out_4na_bin
=
NCBI
:
align
:
align_restore_read
(
ref_read_internal
,
out_has_mismatch
,
tmp_out_mismatch_4na_bin
,
out_has_ref_offset
,
out_ref_offset
,
.
READ_LEN
)
|
NCBI
:
align
:
align_restore_read
(
ref_read_internal
,
out_has_mismatch
,
tmp_out_mismatch_4na_bin
,
out_has_ref_offset
,
out_ref_offset
)
|
NCBI
:
align
:
raw_restore_read
(
out_raw_read
,
.
REF_ORIENTATION
)
;
column
bool_encoding
TMP_HAS_MISMATCH
;
bool
out_has_mismatch
=
.
TMP_HAS_MISMATCH
|
NCBI
:
align
:
generate_has_mismatch
(
REF_READ
,
READ
,
out_has_ref_offset
,
out_ref_offset
)
;
readonly
column
bool
HAS_MISMATCH
=
out_has_mismatch
;
INSDC
:
4
na
:
bin
out_mismatch_4na_bin
=
NCBI
:
align
:
generate_mismatch
(
REF_READ
,
READ
,
out_has_ref_offset
,
out_ref_offset
)
;
INSDC
:
4
na
:
bin
tmp_out_mismatch_4na_bin
=
<
INSDC
:
dna
:
text
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
CHARSET
,
INSDC
:
4
na
:
map
:
BINSET
>
(
.
TMP_MISMATCH
)
;
column
<
INSDC
:
dna
:
text
>
zip_encoding
TMP_MISMATCH
;
INSDC
:
dna
:
text
out_mismatch_dna_text
=
.
TMP_MISMATCH
|
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_mismatch_4na_bin
)
;
readonly
column
INSDC
:
dna
:
text
MISMATCH
=
out_mismatch_dna_text
;
readonly
column
INSDC
:
4
na
:
bin
MISMATCH
=
out_mismatch_4na_bin
;
physical
column
<
INSDC
:
coord
:
zero
>
izip_encoding
.
MATE_REF_POS
=
MATE_REF_POS
;
INSDC
:
coord
:
zero
out_mate_ref_pos
=
.
MATE_REF_POS
|
<
INSDC
:
coord
:
zero
>
simple_sub_select
<
'','REF_POS'> (MATE_ALIGN_ID);
physical
column
<
I64
>
izip_encoding
.
MATE_REF_ID
=
MATE_REF_ID
;
I64
out_mate_ref_id
=
.
MATE_REF_ID
|
<
I64
>
simple_sub_select
<
'','REF_ID'> (MATE_ALIGN_ID);
INSDC
:
coord
:
len
out_mate_ref_len
=
<
INSDC
:
coord
:
len
>
simple_sub_select
<
'','REF_LEN'> (MATE_ALIGN_ID);
physical
column
<
I32
>
izip_encoding
.
TEMPLATE_LEN
=
TEMPLATE_LEN
;
I32
out_template_len
=
.
TEMPLATE_LEN
|
NCBI
:
align
:
template_len
(
REF_POS
,
out_mate_ref_pos
,
out_ref_len
,
out_mate_ref_len
,
REF_NAME
,
MATE_REF_NAME
,
SEQ_READ_ID
)
;
physical
column
<
bool
>
izip_encoding
.
MATE_REF_ORIENTATION
=
MATE_REF_ORIENTATION
;
bool
out_mate_ref_orientation
=
.
MATE_REF_ORIENTATION
|
<
bool
>
simple_sub_select
<
'','REF_ORIENTATION'> (MATE_ALIGN_ID);
I64
out_mate_align_id
=
.
MATE_ALIGN_ID
;
physical
column
<
I64
>
izip_encoding
.
MATE_ALIGN_ID
=
MATE_ALIGN_ID
;
extern
column
I64
MATE_ALIGN_ID
=
out_mate_align_id
;
physical
column
<
I64
>
izip_encoding
.
PRIMARY_ALIGNMENT_ID
=
PRIMARY_ALIGNMENT_ID
;
I32
read_idx
=
<
I32
>
cast
(
.
SEQ_READ_ID
)
;
extern
column
I64
PRIMARY_ALIGNMENT_ID
=
.
PRIMARY_ALIGNMENT_ID
|
<
I64
>
simple_sub_select
<
'SEQUENCE','PRIMARY_ALIGNMENT_ID' > (.SEQ_SPOT_ID,.SEQ_READ_ID);
}
;
table
NCBI
:
align
:
tbl
:
compressed_by_reference
#1.2
=
NCBI
:
align
:
tbl
:
align_cmn
#2.1
{
bool
out_is_secondary
=
<
bool
>
echo
<
false
>
(
)
;
extern
default
column
bool_encoding
HAS_MISMATCH
;
bool
out_has_mismatch
=
.
HAS_MISMATCH
;
extern
column
INSDC
:
dna
:
text
MISMATCH
{
read
=
out_mismatch_dna_text
;
validate
=
<
INSDC
:
dna
:
text
>
compare
(
in_mismatch_dna_text
,
out_mismatch_dna_text
)
;
}
INSDC
:
dna
:
text
in_mismatch_dna_text
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'.acmgrsvtwyhkdbn','NACMGRSVTWYHKDBN' > ( MISMATCH );
INSDC
:
4
na
:
bin
in_mismatch_4na_bin
=
<
INSDC
:
dna
:
text
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
CHARSET
,
INSDC
:
4
na
:
map
:
BINSET
>
(
in_mismatch_dna_text
)
;
extern
column
<
ascii
>
zip_encoding
ALIGN_GROUP
;
physical
column
<
INSDC
:
4
na
:
bin
>
zip_encoding
.
MISMATCH
=
in_mismatch_4na_bin
;
INSDC
:
4
na
:
bin
out_mismatch_4na_bin
=
.
MISMATCH
;
INSDC
:
dna
:
text
out_mismatch_dna_text
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_mismatch_4na_bin
)
;
I64
out_mate_align_id
=
.
MATE_ALIGN_ID
|
NCBI
:
align
:
get_mate_align_id
(
.
SEQ_SPOT_ID
)
;
physical
column
<
I64
>
izip_encoding
.
MATE_ALIGN_ID
=
MATE_ALIGN_ID
;
extern
column
I64
MATE_ALIGN_ID
=
out_mate_align_id
;
INSDC
:
4
na
:
bin
out_4na_bin
=
NCBI
:
align
:
align_restore_read
(
ref_read_internal
,
out_has_mismatch
,
.
MISMATCH
,
out_has_ref_offset
,
out_ref_offset
,
.
READ_LEN
)
|
NCBI
:
align
:
align_restore_read
(
ref_read_internal
,
out_has_mismatch
,
.
MISMATCH
,
out_has_ref_offset
,
out_ref_offset
)
;
INSDC
:
4
na
:
bin
out_raw_read
=
NCBI
:
align
:
raw_restore_read
(
out_4na_bin
,
.
REF_ORIENTATION
)
;
I64
primary_align_pair
=
<
I64
>
simple_sub_select
<
'SEQUENCE','PRIMARY_ALIGNMENT_ID'> (.SEQ_SPOT_ID);
I64
out_mate_ref_id
=
<
I64
>
simple_sub_select
<
'','REF_ID'> (MATE_ALIGN_ID);
bool
out_mate_ref_orientation
=
<
bool
>
simple_sub_select
<
'','REF_ORIENTATION'> (MATE_ALIGN_ID);
INSDC
:
coord
:
zero
out_mate_ref_pos
=
<
INSDC
:
coord
:
zero
>
simple_sub_select
<
'','REF_POS'> (MATE_ALIGN_ID);
INSDC
:
coord
:
len
out_mate_ref_len
=
<
INSDC
:
coord
:
len
>
simple_sub_select
<
'','REF_LEN'> (MATE_ALIGN_ID);
readonly
column
U32
MATE_EDIT_DISTANCE
=
<
U32
>
simple_sub_select
<
'','EDIT_DISTANCE'> (MATE_ALIGN_ID);
readonly
column
ascii
MATE_CIGAR_LONG
=
<
ascii
>
simple_sub_select
<
'','CIGAR_LONG'> (MATE_ALIGN_ID);
readonly
column
ascii
MATE_CIGAR_SHORT
=
<
ascii
>
simple_sub_select
<
'','CIGAR_SHORT'> (MATE_ALIGN_ID);
readonly
column
INSDC
:
coord
:
len
MATE_CIGAR_LONG_LEN
=
<
INSDC
:
coord
:
len
>
simple_sub_select
<
'','CIGAR_LONG_LEN'> (MATE_ALIGN_ID);
readonly
column
INSDC
:
coord
:
len
MATE_CIGAR_SHORT_LEN
=
<
INSDC
:
coord
:
len
>
simple_sub_select
<
'','CIGAR_SHORT_LEN'> (MATE_ALIGN_ID);
I32
out_template_len
=
NCBI
:
align
:
template_len
(
REF_POS
,
out_mate_ref_pos
,
out_ref_len
,
out_mate_ref_len
,
REF_NAME
,
MATE_REF_NAME
,
SEQ_READ_ID
)
;
}
;
table
NCBI
:
align
:
tbl
:
align_sorted
#1.2
=
NCBI
:
align
:
tbl
:
compressed_by_reference
#1.2
,
NCBI
:
align
:
tbl
:
global_ref_block
#1.0.0
{
column
default
limit
=
131072
;
}
;
table
NCBI
:
align
:
tbl
:
align_unsorted
#1.2
=
NCBI
:
align
:
tbl
:
compressed_by_reference
#1.2
,
NCBI
:
align
:
tbl
:
local_ref_block
#1.0.0
{
column
default
limit
=
131072
;
}
;
table
NCBI
:
align
:
tbl
:
align_mate_sorted
#1.1
=
NCBI
:
align
:
tbl
:
align_full
#1.1
,
NCBI
:
align
:
tbl
:
global_ref_block
#1.0.0
{
column
default
limit
=
131072
;
}
;
table
NCBI
:
align
:
tbl
:
align_mate_unsorted
#1.1
=
NCBI
:
align
:
tbl
:
align_full
#1.1
,
NCBI
:
align
:
tbl
:
local_ref_block
#1.0.0
{
column
default
limit
=
131072
;
}
;
table
NCBI
:
align
:
tbl
:
align_allele
#1.2
=
NCBI
:
align
:
tbl
:
align_unsorted
#1.2
{
extern
column
<
I64
>
izip_encoding
EVIDENCE_ALIGNMENT_IDS
;
}
;
physical
I64
NCBI
:
align
:
sorted
:
alignment_id_encoding
#1.0
{
decode
{
I64
outliers_removed
=
iunzip
(
@
)
;
return
<
I64
>
outlier_decode
<
0
>
(
outliers_removed
)
;
}
encode
{
I64
outliers_removed
=
<
I64
>
outlier_encode
<
0
>
(
@
)
;
return
izip
(
outliers_removed
)
;
}
}
table
NCBI
:
align
:
tbl
:
seq
#1.1
=
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
phred_quality
#2.0.4
,
NCBI
:
align
:
tbl
:
cmp_base_space
#1
,
NCBI
:
SRA
:
tbl
:
spotdesc
#1.0.2
,
NCBI
:
SRA
:
tbl
:
stats
#1.2.0
{
column
default
limit
=
131072
;
extern
column
<
I64
>
izip_encoding
PRIMARY_ALIGNMENT_ID
;
INSDC
:
coord
:
zero
trim_start
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
coord
:
len
trim_len
=
_spot_len
;
extern
column
<
U8
>
zip_encoding
ALIGNMENT_COUNT
;
ascii
out_name_fmt
=
<
ascii
>
echo
<
'$R' > ();
extern
column
<
U64
>
izip_encoding
TMP_KEY_ID
;
INSDC
:
4
na
:
bin
out_dcmp_4na_bin
=
NCBI
:
align
:
seq_restore_read
(
out_cmp_4na_bin
,
.
PRIMARY_ALIGNMENT_ID
,
.
READ_LEN
,
.
READ_TYPE
)
;
extern
column
<
U64
>
izip_encoding
TI
;
extern
column
<
ascii
>
zip_encoding
CMP_LINKAGE_GROUP
;
readonly
column
ascii
LINKAGE_GROUP
=
NCBI
:
align
:
seq_restore_linkage_group
(
.
CMP_LINKAGE_GROUP
,
.
PRIMARY_ALIGNMENT_ID
)
|
.
CMP_LINKAGE_GROUP
;
}
;
table
NCBI
:
align
:
tbl
:
cs_seq
#1.2
{
extern
column
INSDC
:
color
:
text
CMP_CSREAD
=
out_cmp_color_text
;
extern
column
<
INSDC
:
dna
:
text
>
zip_encoding
CS_KEY
;
extern
default
column
<
INSDC
:
quality
:
phred
>
zip_encoding
QUALITY
;
extern
column
<
I64
>
izip_encoding
PRIMARY_ALIGNMENT_ID
;
extern
column
<
U8
>
zip_encoding
ALIGNMENT_COUNT
;
extern
column
<
INSDC
:
SRA
:
platform_id
>
zip_encoding
PLATFORM
;
extern
column
<
ascii
>
zip_encoding
LABEL
;
extern
column
<
INSDC
:
coord
:
zero
>
izip_encoding
LABEL_START
;
extern
column
<
INSDC
:
coord
:
len
>
izip_encoding
LABEL_LEN
;
extern
column
<
INSDC
:
SRA
:
xread_type
>
zip_encoding
READ_TYPE
;
extern
column
<
INSDC
:
coord
:
zero
>
izip_encoding
READ_START
;
extern
column
<
INSDC
:
coord
:
len
>
izip_encoding
READ_LEN
;
extern
column
<
INSDC
:
SRA
:
read_filter
>
zip_encoding
READ_FILTER
;
extern
column
<
U64
>
izip_encoding
TMP_KEY_ID
;
extern
column
<
ascii
>
zip_encoding
SPOT_GROUP
;
extern
column
<
U64
>
izip_encoding
TI
;
INSDC
:
x2cs
:
bin
in_cmp_x2cs_bin
=
<
INSDC
:
color
:
text
,
INSDC
:
x2cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
CHARSET
,
INSDC
:
x2cs
:
map
:
BINSET
>
(
CMP_CSREAD
)
;
INSDC
:
2
cs
:
bin
in_cmp_2cs_bin
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
2
cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
[
0
,
1
,
2
,
3
,
0
]
>
(
in_cmp_x2cs_bin
)
;
INSDC
:
x2cs
:
bin
in_cmp_alt_x2cs_bin
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
x2cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
[
0
,
0
,
0
,
0
,
4
]
>
(
in_cmp_x2cs_bin
)
;
physical
column
INSDC
:
2
cs
:
packed
.
CMP_CSREAD
=
(
INSDC
:
2
cs
:
packed
)
pack
(
in_cmp_2cs_bin
)
;
physical
column
<
INSDC
:
x2cs
:
bin
>
zip_encoding
.
CMP_ALTCSREAD
=
<
INSDC
:
x2cs
:
bin
>
trim
<
ALIGN_LEFT
,
0
>
(
in_cmp_alt_x2cs_bin
)
;
INSDC
:
2
cs
:
packed
phys_cmp_2cs_packed
=
.
CMP_CSREAD
;
INSDC
:
x2cs
:
bin
phys_cmp_alt_x2cs_bin
=
.
CMP_ALTCSREAD
;
INSDC
:
2
cs
:
packed
phys_2cs_packed
=
.
CSREAD
;
INSDC
:
x2cs
:
bin
phys_alt_x2cs_bin
=
.
ALTCSREAD
;
INSDC
:
2
cs
:
bin
out_cmp_2cs_bin
=
(
INSDC
:
2
cs
:
bin
)
unpack
(
phys_cmp_2cs_packed
)
;
INSDC
:
2
cs
:
bin
out_2cs_bin
=
(
INSDC
:
2
cs
:
bin
)
unpack
(
phys_2cs_packed
)
;
INSDC
:
x2cs
:
bin
out_cmp_x2cs_bin
=
(
INSDC
:
x2cs
:
bin
)
<
U8
>
bit_or
<
ALIGN_RIGHT
>
(
out_cmp_2cs_bin
,
phys_cmp_alt_x2cs_bin
)
|
(
INSDC
:
x2cs
:
bin
)
out_cmp_2cs_bin
;
INSDC
:
x2cs
:
bin
out_x2cs_bin
=
(
INSDC
:
x2cs
:
bin
)
<
U8
>
bit_or
<
ALIGN_RIGHT
>
(
out_2cs_bin
,
phys_alt_x2cs_bin
)
|
(
INSDC
:
x2cs
:
bin
)
out_2cs_bin
;
INSDC
:
color
:
text
out_cmp_color_text
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
color
:
text
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
INSDC
:
x2cs
:
map
:
CHARSET
>
(
out_cmp_x2cs_bin
)
;
INSDC
:
color
:
text
out_color_text
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
color
:
text
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
INSDC
:
x2cs
:
map
:
CHARSET
>
(
out_x2cs_bin
)
;
INSDC
:
quality
:
phred
in_qual_phred
=
QUALITY
;
INSDC
:
coord
:
len
in_read_len
=
READ_LEN
;
INSDC
:
SRA
:
xread_type
in_read_type
=
READ_TYPE
;
ascii
in_spot_group
=
SPOT_GROUP
;
trigger
meta_stats
=
NCBI
:
SRA
:
cmp_stats_trigger
(
in_cmp_x2cs_bin
,
in_qual_phred
,
in_read_len
,
in_read_type
,
in_spot_group
)
|
NCBI
:
SRA
:
cmp_stats_trigger
(
in_cmp_x2cs_bin
,
in_qual_phred
,
in_read_len
,
in_read_type
)
;
trigger
qual_stats
=
NCBI
:
SRA
:
phred_stats_trigger
#1
(
in_qual_phred
)
;
extern
column
<
ascii
>
zip_encoding
CMP_LINKAGE_GROUP
;
readonly
column
ascii
LINKAGE_GROUP
=
NCBI
:
align
:
seq_restore_linkage_group
(
.
CMP_LINKAGE_GROUP
,
.
PRIMARY_ALIGNMENT_ID
)
|
.
CMP_LINKAGE_GROUP
;
}
;
table
NCBI
:
align
:
view
:
cs_seq
#1.1
=
NCBI
:
align
:
tbl
:
cs_seq
#1.2
{
default
readonly
column
INSDC
:
dna
:
text
READ
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_dcmp_4na_bin
)
|
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_4na_bin
)
;
readonly
column
INSDC
:
4
na
:
bin
READ
=
out_dcmp_4na_bin
|
out_4na_bin
;
readonly
column
INSDC
:
4
na
:
packed
READ
=
pack
(
out_dcmp_4na_bin
)
|
pack
(
out_4na_bin
)
;
readonly
column
INSDC
:
x2na
:
bin
READ
=
out_dcmp_x2na_bin
|
out_x2na_bin
;
readonly
column
INSDC
:
2
na
:
bin
READ
=
out_dcmp_2na_bin
|
out_2na_bin
;
INSDC
:
2
na
:
bin
out_dcmp_2na_bin
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
2
na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
[
0
,
1
,
2
,
3
,
0
]
>
(
out_dcmp_x2na_bin
)
;
INSDC
:
2
na
:
bin
out_2na_bin
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
2
na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
[
0
,
1
,
2
,
3
,
0
]
>
(
out_x2na_bin
)
;
readonly
column
INSDC
:
2
na
:
packed
READ
=
pack
(
out_dcmp_2na_bin
)
|
pack
(
out_2na_bin
)
;
INSDC
:
coord
:
len
cmp_read_len
=
<
INSDC
:
coord
:
len
>
NCBI
:
align
:
make_cmp_read_desc
#1
<
true
>
(
.
READ_LEN
,
.
PRIMARY_ALIGNMENT_ID
)
;
INSDC
:
coord
:
zero
cmp_read_start
=
NCBI
:
align
:
make_read_start
#1
(
cmp_read_len
)
;
INSDC
:
x2na
:
bin
out_cmp_x2na_bin
=
NCBI
:
dna_from_color
#1
(
out_cmp_x2cs_bin
,
cmp_read_start
,
cmp_read_len
,
.
CS_KEY
,
color_matrix
)
;
INSDC
:
x2na
:
bin
out_x2na_bin
=
NCBI
:
dna_from_color
#1
(
out_x2cs_bin
,
.
READ_START
,
.
READ_LEN
,
.
CS_KEY
,
color_matrix
)
;
INSDC
:
4
na
:
bin
out_cmp_4na_bin
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
[
1
,
2
,
4
,
8
,
15
]
>
(
out_cmp_x2na_bin
)
;
INSDC
:
4
na
:
bin
out_4na_bin
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
[
1
,
2
,
4
,
8
,
15
]
>
(
out_x2na_bin
)
;
INSDC
:
4
na
:
bin
out_dcmp_4na_bin
=
NCBI
:
align
:
seq_restore_read
(
out_cmp_4na_bin
,
.
PRIMARY_ALIGNMENT_ID
,
.
READ_LEN
,
.
READ_TYPE
)
;
default
readonly
column
INSDC
:
color
:
text
CSREAD
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
color
:
text
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
INSDC
:
x2cs
:
map
:
CHARSET
>
(
out_dcmp_x2cs_bin
)
|
out_color_text
;
readonly
column
INSDC
:
x2cs
:
bin
CSREAD
=
out_dcmp_x2cs_bin
|
out_x2cs_bin
;
readonly
column
INSDC
:
2
cs
:
bin
CSREAD
=
out_dcmp_2cs_bin
|
out_2cs_bin
;
INSDC
:
2
cs
:
bin
out_dcmp_2cs_bin
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
2
cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
[
0
,
1
,
2
,
3
,
0
]
>
(
out_dcmp_x2cs_bin
)
;
readonly
column
INSDC
:
2
cs
:
packed
CSREAD
=
pack
(
out_dcmp_2cs_bin
)
|
out_2cs_bin
;
INSDC
:
x2na
:
bin
out_dcmp_x2na_bin
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
4
,
0
,
1
,
4
,
2
,
4
,
4
,
4
,
3
,
4
,
4
,
4
,
4
,
4
,
4
,
4
]
>
(
out_dcmp_4na_bin
)
;
INSDC
:
x2cs
:
bin
out_dcmp_x2na_x2cs_bin
=
NCBI
:
color_from_dna
#1
(
out_dcmp_x2na_bin
,
.
READ_START
,
.
READ_LEN
,
.
CS_KEY
,
color_matrix
)
;
INSDC
:
coord
:
len
aligned_read_len
=
<
INSDC
:
coord
:
len
>
NCBI
:
align
:
make_cmp_read_desc
#1
<
false
>
(
.
READ_LEN
,
.
PRIMARY_ALIGNMENT_ID
)
;
INSDC
:
x2cs
:
bin
out_dcmp_x2cs_bin
=
<
INSDC
:
x2cs
:
bin
>
NCBI
:
align
:
seq_construct_read
#1
(
out_dcmp_x2na_x2cs_bin
,
.
READ_LEN
,
out_cmp_x2cs_bin
,
cmp_read_len
)
;
U32
cmp_csread_row_len
=
row_len
#1
(
phys_cmp_2cs_packed
)
;
U32
cmp_csread_not_zero
=
<
U32
>
clip
<
0
,
1
>
(
cmp_csread_row_len
)
;
readonly
column
bool
CS_NATIVE
=
<
U32
,
bool
>
map
<
[
0
,
1
]
,
[
false
,
true
]
>
(
cmp_cs_read_not_zero
)
;
readonly
column
U8
COLOR_MATRIX
=
color_matrix
;
U8
color_matrix
=
<
U8
>
echo
<
INSDC
:
color
:
default_matrix
>
(
)
;
readonly
column
INSDC
:
quality
:
text
:
phred_33
QUALITY
=
out_qual_text_phred_33
|
(
INSDC
:
quality
:
text
:
phred_33
)
<
B8
>
sum
<
33
>
(
.
QUALITY
)
;
readonly
column
INSDC
:
quality
:
text
:
phred_64
QUALITY
=
out_qual_text_phred_64
|
(
INSDC
:
quality
:
text
:
phred_64
)
<
B8
>
sum
<
64
>
(
.
QUALITY
)
;
INSDC
:
coord
:
len
spot_len
=
(
INSDC
:
coord
:
len
)
row_len
(
out_dcmp_4na_bin
)
|
(
INSDC
:
coord
:
len
)
row_len
(
out_4na_bin
)
;
readonly
column
INSDC
:
coord
:
len
SPOT_LEN
=
spot_len
;
readonly
column
INSDC
:
coord
:
zero
TRIM_START
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
readonly
column
INSDC
:
coord
:
one
TRIM_START
=
<
INSDC
:
coord
:
one
>
echo
<
1
>
(
)
;
readonly
column
INSDC
:
coord
:
len
TRIM_LEN
=
spot_len
;
readonly
column
INSDC
:
SRA
:
spotid_t
MIN_SPOT_ID
=
<
INSDC
:
SRA
:
spotid_t
>
meta
:
value
<
"STATS/TABLE/SPOT_MIN"
>
(
)
;
readonly
column
INSDC
:
SRA
:
spotid_t
MAX_SPOT_ID
=
<
INSDC
:
SRA
:
spotid_t
>
meta
:
value
<
"STATS/TABLE/SPOT_MAX"
>
(
)
;
readonly
column
U64
SPOT_COUNT
=
<
U64
>
meta
:
value
<
"STATS/TABLE/SPOT_COUNT"
>
(
)
;
U64
base_count
=
<
U64
>
meta
:
value
<
"STATS/TABLE/BASE_COUNT"
>
(
)
;
readonly
column
U64
BASE_COUNT
=
base_count
;
readonly
column
U64
BIO_BASE_COUNT
=
<
U64
>
meta
:
value
<
"STATS/TABLE/BIO_BASE_COUNT"
>
(
)
;
readonly
column
U64
CMP_BASE_COUNT
=
<
U64
>
meta
:
value
<
"STATS/TABLE/CMP_BASE_COUNT"
>
(
)
|
base_count
;
I64
rowid_64
=
row_id
(
)
;
readonly
column
INSDC
:
SRA
:
spotid_t
SPOT_ID
=
cast
(
rowid_64
)
;
readonly
column
ascii
NAME
=
sprintf
<
"%u"
>
(
SPOT_ID
)
;
}
;
table
NCBI
:
align
:
tbl
:
reference
#2
=
NCBI
:
align
:
tbl
:
cmp_base_space
#1
,
NCBI
:
tbl
:
base_space
#2.0.3
,
NCBI
:
tbl
:
seqloc
#1
,
NCBI
:
SRA
:
tbl
:
stats
#1.2.0
{
INSDC
:
quality
:
phred
out_qual_phred
=
<
INSDC
:
quality
:
phred
>
echo
<
30
>
(
out_dcmp_4na_bin
)
;
extern
column
<
U32
>
izip_encoding
MAX_SEQ_LEN
;
extern
column
bool_encoding
CIRCULAR
;
INSDC
:
dna
:
text
in_cs_key
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'acgtn', 'ACGTN' > ( CS_KEY );
physical
column
<
INSDC
:
dna
:
text
>
zip_encoding
.
CS_KEY
=
in_cs_key
;
U32
in_spot_len
=
SEQ_LEN
;
INSDC
:
coord
:
len
_alt_in_read_len
=
READ_LEN
|
SEQ_LEN
;
INSDC
:
SRA
:
xread_type
_alt_in_read_type
=
READ_TYPE
|
<
INSDC
:
SRA
:
xread_type
>
echo
<
SRA_READ_TYPE_BIOLOGICAL
>
(
)
;
INSDC
:
coord
:
zero
out_read_start
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
coord
:
len
out_read_len
=
.
SEQ_LEN
;
extern
column
utf8
NAME
=
out_spot_name_utf8
;
physical
utf8
.
NAME
=
idx
:
text
:
insert
#1.0
<
'i_name' > ( NAME );
utf8
out_spot_name_utf8
=
idx
:
text
:
project
#1.0
<
'i_name' > (.NAME );
ascii
out_spot_name
=
cast
(
out_spot_name_utf8
)
;
INSDC
:
coord
:
zero
trim_start
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
coord
:
len
trim_len
=
base_space_spot_len
;
ascii
out_label
=
<
ascii
>
echo
<
"reference"
>
(
)
;
INSDC
:
coord
:
zero
out_label_start
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
coord
:
len
out_label_len
=
<
INSDC
:
coord
:
len
>
echo
<
9
>
(
)
;
U32
out_nreads
=
<
U32
>
echo
<
1
>
(
)
;
INSDC
:
SRA
:
xread_type
out_read_type
=
<
INSDC
:
SRA
:
xread_type
>
echo
<
3
>
(
)
;
INSDC
:
SRA
:
read_filter
out_rd_filter
=
<
INSDC
:
SRA
:
read_filter
>
echo
<
SRA_READ_FILTER_PASS
>
(
)
;
extern
column
<
U8
>
izip_encoding
CGRAPH_HIGH
;
extern
column
<
U8
>
izip_encoding
CGRAPH_LOW
;
extern
column
<
U32
>
izip_encoding
CGRAPH_MISMATCHES
;
extern
column
<
U32
>
izip_encoding
CGRAPH_INDELS
;
extern
column
<
I64
>
izip_encoding
PRIMARY_ALIGNMENT_IDS
;
extern
column
<
I64
>
izip_encoding
SECONDARY_ALIGNMENT_IDS
;
extern
column
<
I64
>
izip_encoding
EVIDENCE_INTERVAL_IDS
;
extern
column
<
INSDC
:
coord
:
zero
>
izip_encoding
OVERLAP_REF_POS
;
extern
column
<
INSDC
:
coord
:
len
>
izip_encoding
OVERLAP_REF_LEN
;
readonly
column
vdb
:
row_id_range
NAME_RANGE
=
idx
:
text
:
lookup
#1.0
<
'i_name', 'QUERY_SEQ_NAME' > ();
INSDC
:
4
na
:
bin
out_dcmp_4na_bin
=
NCBI
:
align
:
ref_restore_read
(
out_cmp_4na_bin
,
.
SEQ_ID
,
.
SEQ_START
,
.
SEQ_LEN
)
;
}
database
NCBI
:
align
:
db
:
alignment_sorted
#1.3
{
table
NCBI
:
align
:
tbl
:
reference
#2
REFERENCE
;
table
NCBI
:
align
:
tbl
:
align_sorted
#1.2
PRIMARY_ALIGNMENT
;
table
NCBI
:
align
:
tbl
:
align_mate_sorted
#1.1
SECONDARY_ALIGNMENT
;
table
NCBI
:
align
:
tbl
:
seq
#1.1
SEQUENCE
;
table
NCBI
:
align
:
view
:
cs_seq
#1.1
CS_SEQUENCE
;
table
NCBI
:
align
:
tbl
:
qstat
#1.0
QUAL_STAT
;
}
;
database
NCBI
:
align
:
db
:
alignment_unsorted
#1.3
{
table
NCBI
:
align
:
tbl
:
reference
#2
REFERENCE
;
table
NCBI
:
align
:
tbl
:
align_unsorted
#1.2
PRIMARY_ALIGNMENT
;
table
NCBI
:
align
:
tbl
:
align_mate_unsorted
#1.1
SECONDARY_ALIGNMENT
;
table
NCBI
:
align
:
tbl
:
seq
#1.1
SEQUENCE
;
table
NCBI
:
align
:
view
:
cs_seq
#1.1
CS_SEQUENCE
;
table
NCBI
:
align
:
tbl
:
qstat
#1.0
QUAL_STAT
;
}
;
database
NCBI
:
align
:
db
:
alignment_evidence
#1.3
{
table
NCBI
:
align
:
tbl
:
reference
#2
REFERENCE
;
table
NCBI
:
align
:
tbl
:
align_unsorted
#1.2
PRIMARY_ALIGNMENT
;
table
NCBI
:
align
:
tbl
:
align_mate_unsorted
#1.1
SECONDARY_ALIGNMENT
;
table
NCBI
:
align
:
tbl
:
align_allele
#1.2
EVIDENCE_INTERVAL
;
table
NCBI
:
align
:
tbl
:
align_mate_unsorted
#1.1
EVIDENCE_ALIGNMENT
;
table
NCBI
:
align
:
tbl
:
seq
#1.1
SEQUENCE
;
table
NCBI
:
align
:
view
:
cs_seq
#1.1
CS_SEQUENCE
;
table
NCBI
:
align
:
tbl
:
qstat
#1.0
QUAL_STAT
;
}
;
database
NCBI
:
align
:
db
:
alignment_evidence_sorted
#1.2
{
table
NCBI
:
align
:
tbl
:
reference
#2
REFERENCE
;
table
NCBI
:
align
:
tbl
:
align_sorted
#1.2
PRIMARY_ALIGNMENT
;
table
NCBI
:
align
:
tbl
:
align_mate_sorted
#1.1
SECONDARY_ALIGNMENT
;
table
NCBI
:
align
:
tbl
:
align_allele
#1.2
EVIDENCE_INTERVAL
;
table
NCBI
:
align
:
tbl
:
align_mate_unsorted
#1.1
EVIDENCE_ALIGNMENT
;
table
NCBI
:
align
:
tbl
:
seq
#1.1
SEQUENCE
;
table
NCBI
:
align
:
view
:
cs_seq
#1.1
CS_SEQUENCE
;
table
NCBI
:
align
:
tbl
:
qstat
#1.0
QUAL_STAT
;
}
;
database
NCBI
:
align
:
db
:
unaligned
#1
{
table
NCBI
:
align
:
tbl
:
seq
#1.1
SEQUENCE
;
table
NCBI
:
SRA
:
ABI
:
tbl
:
v2
#1.0.4
CS_SEQUENCE
;
table
NCBI
:
align
:
tbl
:
qstat
#1.0
QUAL_STAT
;
}
;
version
1
;
include
'vdb/vdb.vschema';
include
'ncbi/seq.vschema';
include
'ncbi/sra.vschema';
include
'ncbi/stats.vschema';
extern
function
U8
NCBI
:
refseq
:
stats
#2
(
INSDC
:
4
na
:
bin
seq
,
INSDC
:
coord
:
len
len
)
=
NCBI
:
refSeq
:
stats
;
table
NCBI
:
refseq
:
tbl
:
reference
#1.0.2
=
NCBI
:
tbl
:
base_space
#2.0.2
,
NCBI
:
tbl
:
phred_quality
#2.0.3
,
NCBI
:
tbl
:
seqloc
#1.0
,
NCBI
:
SRA
:
tbl
:
stats
#1.1.2
{
column
default
limit
=
131072
;
extern
column
U32
MAX_SEQ_LEN
;
extern
column
<
ascii
>
izip_encoding
DEF_LINE
;
trigger
table_stats
=
NCBI
:
refseq
:
stats
(
in_4na_bin
,
_alt_in_read_len
)
;
readonly
column
U64
TOTAL_SEQ_LEN
=
<
U64
>
meta
:
value
<
'STATS/TOTAL_SEQ_LEN', true >();
readonly
column
U8
[
16
]
MD5
=
<
U8
[
16
]
>
meta
:
read
<
'STATS/MD5', true >();
extern
column
bool_encoding
CIRCULAR
;
INSDC
:
dna
:
text
in_cs_key
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'acgtn', 'ACGTN' > ( CS_KEY );
physical
column
<
INSDC
:
dna
:
text
>
zip_encoding
.
CS_KEY
=
in_cs_key
;
INSDC
:
coord
:
zero
out_read_start
=
<
INSDC
:
coord
:
zero
>
echo
<
0
>
(
)
;
INSDC
:
coord
:
len
out_read_len
=
.
SEQ_LEN
;
INSDC
:
coord
:
len
_alt_in_read_len
=
READ_LEN
|
SEQ_LEN
;
INSDC
:
SRA
:
xread_type
_alt_in_read_type
=
READ_TYPE
|
<
INSDC
:
SRA
:
xread_type
>
echo
<
SRA_READ_TYPE_BIOLOGICAL
>
(
)
;
INSDC
:
SRA
:
xread_type
out_read_type
=
.
READ_TYPE
|
<
INSDC
:
SRA
:
xread_type
>
echo
<
SRA_READ_TYPE_BIOLOGICAL
>
(
)
;
}
;
alias
NCBI
:
refseq
:
tbl
:
reference
NCBI
:
refSeq
:
tbl
:
reference
;
version
1
;
include
'vdb/vdb.vschema';
include
'ncbi/seq.vschema';
table
NCBI
:
align
:
tbl
:
cmp_base_space
#1
=
INSDC
:
tbl
:
sequence
#1.0.1
,
NCBI
:
tbl
:
dcmp_base_space
#1
{
extern
default
column
INSDC
:
dna
:
text
CMP_READ
{
read
=
out_cmp_dna_text
;
validate
=
<
INSDC
:
dna
:
text
>
compare
(
in_cmp_dna_text
,
out_cmp_dna_text
)
;
}
extern
column
INSDC
:
4
na
:
bin
CMP_READ
=
out_cmp_4na_bin
;
extern
column
INSDC
:
4
na
:
packed
CMP_READ
=
out_cmp_4na_packed
;
extern
column
INSDC
:
x2na
:
bin
CMP_READ
=
out_cmp_x2na_bin
;
extern
column
INSDC
:
2
na
:
bin
CMP_READ
=
out_cmp_2na_bin
;
extern
column
INSDC
:
2
na
:
packed
CMP_READ
=
out_cmp_2na_packed
;
INSDC
:
dna
:
text
in_cmp_dna_text
=
<
INSDC
:
dna
:
text
,
INSDC
:
dna
:
text
>
map
<
'.acmgrsvtwyhkdbn','NACMGRSVTWYHKDBN' > ( CMP_READ );
INSDC
:
4
na
:
bin
in_cmp_4na_bin
=
<
INSDC
:
4
na
:
bin
>
range_validate
<
0
,
15
>
(
CMP_READ
)
|
(
INSDC
:
4
na
:
bin
)
unpack
(
in_cmp_4na_packed
)
|
<
INSDC
:
dna
:
text
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
CHARSET
,
INSDC
:
4
na
:
map
:
BINSET
>
(
in_cmp_dna_text
)
|
<
INSDC
:
x2na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
x2na
:
map
:
BINSET
,
[
1
,
2
,
4
,
8
,
15
]
>
(
in_cmp_x2na_bin
)
;
INSDC
:
4
na
:
packed
in_cmp_4na_packed
=
CMP_READ
;
INSDC
:
x2na
:
bin
in_cmp_x2na_bin
=
<
INSDC
:
x2na
:
bin
>
range_validate
<
0
,
4
>
(
CMP_READ
)
|
<
INSDC
:
4
na
:
bin
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
4
,
0
,
1
,
4
,
2
,
4
,
4
,
4
,
3
,
4
,
4
,
4
,
4
,
4
,
4
,
4
]
>
(
in_cmp_4na_bin
)
;
INSDC
:
2
na
:
bin
in_cmp_2na_bin
=
<
INSDC
:
2
na
:
bin
>
range_validate
<
0
,
3
>
(
CMP_READ
)
|
(
INSDC
:
2
na
:
bin
)
unpack
(
in_cmp_2na_packed
)
|
INSDC
:
SEQ
:
rand_4na_2na
(
in_cmp_4na_bin
)
;
INSDC
:
2
na
:
packed
in_cmp_2na_packed
=
CMP_READ
;
INSDC
:
4
na
:
bin
in_cmp_alt_4na_bin
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
15
,
0
,
0
,
3
,
0
,
5
,
6
,
7
,
0
,
9
,
10
,
11
,
12
,
13
,
14
,
15
]
>
(
in_cmp_4na_bin
)
;
U8
in_cmp_stats_bin
=
in_cmp_2na_bin
;
physical
column
INSDC
:
2
na
:
packed
.
CMP_READ
=
in_cmp_2na_packed
|
(
INSDC
:
2
na
:
packed
)
pack
(
in_cmp_2na_bin
)
;
physical
column
<
INSDC
:
4
na
:
bin
>
zip_encoding
.
CMP_ALTREAD
=
<
INSDC
:
4
na
:
bin
>
trim
<
0
,
0
>
(
in_cmp_alt_4na_bin
)
;
INSDC
:
2
na
:
packed
out_cmp_2na_packed
=
.
CMP_READ
;
INSDC
:
2
na
:
bin
out_cmp_2na_bin
=
(
INSDC
:
2
na
:
bin
)
unpack
(
out_cmp_2na_packed
)
;
INSDC
:
x2na
:
bin
out_cmp_x2na_bin
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
4
,
0
,
1
,
4
,
2
,
4
,
4
,
4
,
3
,
4
,
4
,
4
,
4
,
4
,
4
,
4
]
>
(
out_cmp_4na_bin
)
;
INSDC
:
4
na
:
bin
out_cmp_2na_4na_bin
=
<
INSDC
:
2
na
:
bin
,
INSDC
:
4
na
:
bin
>
map
<
INSDC
:
2
na
:
map
:
BINSET
,
[
1
,
2
,
4
,
8
]
>
(
out_cmp_2na_bin
)
;
INSDC
:
4
na
:
bin
out_cmp_4na_bin
=
<
INSDC
:
4
na
:
bin
>
bit_or
<
ALIGN_RIGHT
>
(
out_cmp_2na_4na_bin
,
.
CMP_ALTREAD
)
|
out_cmp_2na_4na_bin
;
INSDC
:
4
na
:
packed
out_cmp_4na_packed
=
(
INSDC
:
4
na
:
packed
)
pack
(
out_cmp_4na_bin
)
;
INSDC
:
dna
:
text
out_cmp_dna_text
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
dna
:
text
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
INSDC
:
4
na
:
map
:
CHARSET
>
(
out_cmp_4na_bin
)
;
INSDC
:
x2na
:
bin
out_dcmp_x2na_bin
=
<
INSDC
:
4
na
:
bin
,
INSDC
:
x2na
:
bin
>
map
<
INSDC
:
4
na
:
map
:
BINSET
,
[
4
,
0
,
1
,
4
,
2
,
4
,
4
,
4
,
3
,
4
,
4
,
4
,
4
,
4
,
4
,
4
]
>
(
out_dcmp_4na_bin
)
;
INSDC
:
2
na
:
bin
out_dcmp_2na_bin
=
<
INSDC
:
x2na
:
bin
,
INSDC
:
2
na
:
bin
>
map
<
[
0
,
1
,
2
,
3
,
4
]
,
[
0
,
1
,
2
,
3
,
0
]
>
(
out_dcmp_x2na_bin
)
;
INSDC
:
2
na
:
packed
out_dcmp_2na_packed
=
(
INSDC
:
2
na
:
packed
)
pack
(
out_dcmp_2na_bin
)
;
}
table
NCBI
:
align
:
tbl
:
cmp_color_space
#1
=
INSDC
:
tbl
:
sequence
#1.0.1
,
NCBI
:
tbl
:
dcmp_color_space
#1
{
extern
default
column
INSDC
:
color
:
text
CMP_CSREAD
=
out_cmp_color_text
;
extern
column
INSDC
:
x2cs
:
bin
CMP_CSREAD
=
out_cmp_x2cs_bin
;
extern
column
INSDC
:
2
cs
:
bin
CMP_CSREAD
=
out_cmp_2cs_bin
;
extern
column
INSDC
:
2
cs
:
packed
CMP_CSREAD
=
out_cmp_2cs_packed
;
INSDC
:
color
:
text
in_cmp_color_text
=
CMP_CSREAD
;
INSDC
:
x2cs
:
bin
in_cmp_x2cs_bin
=
<
INSDC
:
x2cs
:
bin
>
range_validate
<
0
,
4
>
(
CMP_CSREAD
)
|
<
INSDC
:
color
:
text
,
INSDC
:
x2cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
CHARSET
,
INSDC
:
x2cs
:
map
:
BINSET
>
(
in_cmp_color_text
)
;
INSDC
:
2
cs
:
bin
in_cmp_2cs_bin
=
<
INSDC
:
2
cs
:
bin
>
range_validate
<
0
,
3
>
(
CMP_CSREAD
)
|
(
INSDC
:
2
cs
:
bin
)
unpack
(
in_cmp_2cs_packed
)
|
<
INSDC
:
x2cs
:
bin
,
INSDC
:
2
cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
[
0
,
1
,
2
,
3
,
0
]
>
(
in_cmp_x2cs_bin
)
;
INSDC
:
2
cs
:
packed
in_cmp_2cs_packed
=
CMP_CSREAD
;
INSDC
:
x2cs
:
bin
in_cmp_alt_x2cs_bin
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
x2cs
:
bin
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
[
0
,
0
,
0
,
0
,
4
]
>
(
in_cmp_x2cs_bin
)
;
U8
in_cmp_stats_bin
=
in_cmp_2cs_bin
;
physical
column
INSDC
:
2
cs
:
packed
.
CMP_CSREAD
=
in_cmp_2cs_packed
|
(
INSDC
:
2
cs
:
packed
)
pack
(
in_cmp_2cs_bin
)
;
physical
column
<
INSDC
:
x2cs
:
bin
>
zip_encoding
.
CMP_ALTCSREAD
=
<
INSDC
:
x2cs
:
bin
>
trim
<
0
,
0
>
(
in_cmp_alt_x2cs_bin
)
;
INSDC
:
2
cs
:
packed
out_cmp_2cs_packed
=
.
CMP_CSREAD
;
INSDC
:
2
cs
:
bin
out_cmp_2cs_bin
=
(
INSDC
:
2
cs
:
bin
)
unpack
(
out_cmp_2cs_packed
)
;
INSDC
:
x2cs
:
bin
out_cmp_x2cs_bin
=
(
INSDC
:
x2cs
:
bin
)
<
U8
>
bit_or
<
ALIGN_RIGHT
>
(
out_cmp_2cs_bin
,
.
CMP_ALTCSREAD
)
|
(
INSDC
:
x2cs
:
bin
)
out_cmp_2cs_bin
;
INSDC
:
color
:
text
out_cmp_color_text
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
color
:
text
>
map
<
INSDC
:
x2cs
:
map
:
BINSET
,
INSDC
:
x2cs
:
map
:
CHARSET
>
(
out_cmp_x2cs_bin
)
;
INSDC
:
2
cs
:
bin
out_dcmp_2cs_bin
=
<
INSDC
:
x2cs
:
bin
,
INSDC
:
2
cs
:
bin
>
map
<
[
0
,
1
,
2
,
3
,
4
]
,
[
0
,
1
,
2
,
3
,
0
]
>
(
out_dcmp_x2cs_bin
)
;
INSDC
:
2
cs
:
packed
out_dcmp_2cs_packed
=
(
INSDC
:
2
cs
:
packed
)
pack
(
out_dcmp_2cs_bin
)
;
}
version
1
;
include
'vdb/vdb.vschema';
include
'ncbi/ncbi.vschema';
table
NCBI
:
align
:
tbl
:
qstat
#1.0
{
extern
column
<
ascii
>
zip_encoding
SPOT_GROUP
;
extern
column
<
U32
>
izip_encoding
CYCLE
;
extern
column
INSDC
:
dna
:
text
KMER
;
extern
column
<
INSDC
:
coord
:
len
>
izip_encoding
HPRUN
;
extern
column
<
U32
>
izip_encoding
GC_CONTENT
;
extern
column
<
INSDC
:
quality
:
phred
>
zip_encoding
ORIG_QUAL
;
extern
column
<
INSDC
:
quality
:
phred
>
zip_encoding
MAX_QUAL
;
extern
column
<
U8
>
zip_encoding
NREAD
;
extern
column
<
U32
>
izip_encoding
TOTAL_COUNT
;
extern
column
<
U32
>
izip_encoding
MISMATCH_COUNT
;
}
;
version
1
;
include
'vdb/built-in.vschema';
include
'vdb/vdb.vschema';
include
'insdc/insdc.vschema';
table
NCBI
:
pileup
:
tbl
:
pileup_stats
#1
{
extern
column
ascii
RUN_NAME
;
extern
column
ascii
REFERENCE_SPEC
=
out_reference_spec
;
physical
<
ascii
>
zip_encoding
.
REFERENCE_SPEC
=
idx
:
text
:
insert
#1.0
<
'ref_spec' > ( REFERENCE_SPEC );
ascii
out_reference_spec
=
idx
:
text
:
project
#1.0
<
'ref_spec' > ( .REFERENCE_SPEC );
extern
column
I64
REF_POS
=
out_ref_pos
;
physical
<
I64
>
izip_encoding
.
REF_POS
=
in_ref_pos
;
I64
in_ref_pos
=
<
I64
>
sub_row_id
(
REF_POS
)
;
I64
out_ref_pos
=
<
I64
>
add_row_id
(
.
REF_POS
)
|
<
I64
>
add_row_id
(
.
REF_POS_TRANS
)
;
extern
column
I64
REF_POS_TRANS
=
out_ref_pos_trans
;
physical
<
I64
>
izip_encoding
.
REF_POS_TRANS
=
in_ref_pos_trans
;
I64
in_ref_pos_trans
=
REF_POS_TRANS
;
I64
out_ref_pos_trans
=
.
REF_POS_TRANS
|
<
I64
>
sub_row_id
(
.
REF_POS
)
;
extern
column
<
INSDC
:
dna
:
text
>
zip_encoding
REF_BASE
;
extern
column
<
U32
>
izip_encoding
DEPTH
;
extern
column
<
U32
>
izip_encoding
MISMATCH_COUNTS
;
extern
column
<
U32
>
izip_encoding
INSERTION_COUNTS
;
extern
column
<
U32
>
izip_encoding
DELETION_COUNT
;
}
database
NCBI
:
pileup
:
db
:
pileup_stats
#1
{
table
NCBI
:
pileup
:
tbl
:
pileup_stats
#1
STATS
;
}
