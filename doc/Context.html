<html>

  <head>

    <title>NCBI VDB-2: Context</title>
    <link href="vdb-2.css" rel="stylesheet" type="text/css"/>

  </head>

  <body>

    <!-- Document Header -->

    <h1>VDB-2 - Context</h1>

    <p class="toc">
    <span class="hdr">Type:</span><br/>
      <span class="entry">runtime interface</span>
    </p>

    <p class="toc">
      <span class="hdr">Header:</span><br/>
      <span class="entry"><a href="../interfaces/klib/ctx.h">&lt;klib/ctx.h&gt;</a></span>
    </p>

    <p class="toc">
    <span class="hdr">Revision History:</span><br/>
      <table class="entry">
        <tr><td>2013-Jun-29</td><td>&bull;</td><td>rodarmer</td></tr>
      </table>
    </p>

    <p class="toc">
    <span class="hdr">Contents:</span><br/>
    <ul class="toc-outer">
        <li><a href="#abstract">Abstract</a></li>
        <li><a href="#purpose">Purpose</a></li>
        <li><a href="#description">Description</a></li>
        <li><a href="#requirements">Requirements</a></li>
        <li><a href="#implementation">Implementation</a></li>
    </ul>
    </p>

    <hr/>

    <!-- Abstract -->

    <a name="abstract">

    <h2>Abstract</h2>

    <div class="section">

      <p>
		This document describes a mechanism for establishing a functional
		context for computation within a C runtime thread.
	  </p>

	  <p>
		The traditional C/C++/Unix environment relies heavily upon global
		functions using static data that combine to make global objects. These
		cause several difficulties in terms of control, testing, extensibility,
		etc.
	  </p>

	  <p>
		As a consequence of the design, we also remove the need for using
		functional return codes to indicate error state.
	  </p>

    </div>
	
    </a>

    <!-- Purpose -->

    <a name="purpose">

    <h2>Purpose</h2>

    <div class="section">

	  <p>
		The most important function of a context is to provide
		<strong>manager</strong> objects to the executing function. An obvious
		example of this is for memory operations. In current VDB-2 and earlier
		sources that make more use of standard C libraries, we freely invoke
		<strong>malloc</strong> and other memory manager functions. These
		functions are process-global in scope, they give no contextual control
		over behavior, etc. By contrast, use of a local memory manager
		<strong>object</strong> makes it possible to apply <em>quotas</em>,
		<em>timeouts</em>, <em>tracking</em>, <em>heaps</em>, etc.
	  </p>

	  <p>
		Another function of context is to allow modification and update by a
		function with a supervisory role for use by worker functions. Again
		using the example of the memory system, this may imply creating a
		<em>secondary-manager</em> with a quota and its own heap to replace the
		one currently in use, before creating a task that has specific
		limitations. This is a different approach than either simply running out
		of resource for the entire process, or perhaps worse allowing a lying
		host OS to go into a swap death-spiral while trying to maintain the
		illusion of infinite resources.
	  </p>

	  <p>
		The implications of being able to update the manager block are that
		either the master block itself is modifiable, or it can be cloned into a
		modifiable copy.
	  </p>

	  <p>
		The context also establishes location of current execution to the level
		of the function. It provides name strings for the current
		<strong>module</strong>, the root <strong>source-file</strong> name, its
		<strong>extension</strong>, and finally the <strong>function</strong>
		name. Any manager having use for this information can use it, for
		example logging functions. Many APIs will also request that the caller
		pass in the current line number, as given by the preprocessor symbol
		<span class="code">__LINE__</span>.
	  </p>

	  <p>
		The implication of providing contextual identification is that each
		stack frame must re-establish context with new information while
		preserving the received manager block.
	  </p>

	  <p>
		Since each stack frame will be creating its own local context, the
		call-chain can be connected by means of back-pointers to the previous
		caller, and this establishes a highly localized context of execution.
	  </p>

	  <p>
		And finally, since we now have a local context for each stack frame,
		there is a new vehicle for communicating error conditions to the caller,
		which is to update its local context object with an error state. This
		can completely replace the use of <strong>return-codes</strong> that
		have formed the basis of VDB-2.
	  </p>

    </div>

    </a>

    <!-- Description -->

    <a name="description">

    <h2>Description</h2>

    <div class="section">

      <p>
		<strong>[ This design borrows heavily from VDB-3. ]</strong>
		Context is established by starting with the <strong>KContext</strong>
		block, an open structure containing object <strong>references</strong>
		plus <strong>constant values</strong>. The intention is to route all
		execution through these objects or their progeny. The master block is
		initialized within <strong>KMane</strong> on the main thread, updated as
		desired by <strong>KMain</strong>, and is cloned within the
		<strong>kproc</strong> library when creating a new thread. At any point
		in the call chain a	function may decide to clone the input
		<em>KContext</em> and use it to	establish a new context for called
		functions.
	  </p>

	  <p>
		To establish location, two structures are used: the
		<strong>KSourceLoc</strong> that records module, filename and extension,
		and the <strong>KFuncLoc</strong> that combines source file with
		function name. The former structure is automatically declared as a
		static variable for each source file, while the latter is manually
		introduced into each function by the programmer as a static block. The
		only overhead associated with these structures is in storage, but no
		additional CPU cycles are involved.
	  </p>

	  <p>
		To tie everything together, a <strong>ctx_t</strong> structure is used
		that designates the current <em>KContext</em> block, the function's
		<em>KFuncLoc</em> block, and the previous caller's <em>ctx_t</em>. The
		function's context is completely represented by a pointer to this
		structure. To pinpoint an exact line, the programmer must manually
		supply <span class="code">__LINE__</span> where requested by APIs.
	  </p>

	  <p>
		Upon entry to a function, the parameter list will contain a
		<span class="code">const</span> pointer to the caller's <em>ctx_t</em>.
		The programmer uses a <span class="code">FUNC_ENTRY()</span> macro to
		perform all necessary steps:
	  </p>

	  <ol>
		<li>declare and initialize static KFuncLoc</li>
		<li>declare local ctx_t</li>
		<li>copy pointer to KContext from caller's ctx_t</li>
		<li>assign pointer to local KFuncLoc</li>
		<li>link local ctx_t to caller</li>
		<li>initialize error state to <q>no error</q></li>
		<li>reassign <q>ctx</q> parameter to designate local ctx_t</li>
	  </ol>

	  <p>
		Error handling is shifted away from creation, return and testing of
		<span class="code">RC()</span> values, and has been replaced by
		recording error or warning events on the <strong>thread</strong>, an
		object reference within the <em>KContext</em>. To indicate that an error
		has occurred, a <span class="code">bool</span> value within the local
		<em>ctx_t</em> is set at the same time as the event is recorded on the
		thread. Callers test this Boolean value to discover an error condition.
		<strong>It is important that the stack frame reporting the error
		should not return without the state being recorded.</strong> We have
		always had this and other variant conditions in VDB-2, e.g. failing to
		indicate an error on return, or returning some garbage/uninitialized
		<em>rc_t</em> code by accident, or perhaps returning the wrong code.
	  </p>

	  <p>
		The <em>rc_t</em> mechanism requires that all stack frames test and
		handle <em>( and especially return )</em> the values properly. If we
		were to follow the same paradigm, each caller would need to propagate
		error state from its local <em>ctx_t</em> to the caller's, which would
		in turn require catching it at every return statement. This would be
		error prone, wasteful and unnecessary. Now that we have a linked list of
		<em>ctx_t</em> blocks, the code that sets an error state in one can
		propagate this state back up the stack. This ensures that the error
		cannot be masked/lost.
	  </p>

	  <p>
		Most of our code does <strong>not</strong> catch and handle error
		conditions, probably because the majority of our functions are not
		expected to fail. But sometimes we do, so a facility must exist for
		examining the nature of an error or warning, and taking some action in
		response. So we provide first the ability to <strong>clear</strong> all
		errors and warnings, as well as the ability to <strong>convert</strong>
		an error to a warning. A new functionality that becomes available to us
		<em>( and of which we should make good use )</em> is the ability to
		<strong>annotate</strong> events with additional information. In some
		cases we may want to <strong>transform</strong> an event into a
		different one. Currently the plan is to do this with the two primitives
		of <em>clearing</em> the existing event and <em>creating</em> a new
		event. It may be found necessary to formalize these into a single
		operation.
	  </p>

	  <p>
		The requirement of propagating error state up the call chain means that
		the event reporting code must walk the singly-linked list until it
		reaches a stopping point, perhaps the thread main. We may initially
		presume that upon an error event we can expect the state of all
		<em>ctx_t</em> blocks above us to be free of errors, but that would be
		incorrect. It must be recognized that a function may continue to
		execute, especially in cleanup mode, after discovering an error
		condition. The error propagation code should stop when it encounters a
		stack frame that already has an error.
	  </p>

	  <p>
		The ability to clear an event means reversing the effect of setting one.
		This means that the clear function should walk the singly-linked list of
		<em>ctx_t</em> blocks, clearing the error state for each, until it
		reaches a frame where propagation code stopped. Otherwise, clearing a
		single event would risk clearing a previous event.
	  </p>

    </div>

    </a>

    <!-- Requirements -->

    <a name="requirements">

    <h2>Requirements</h2>

    <ol class="requirements">
        <li>must be wonderful</li>
    </ol>

    </a>

    <!-- Content -->

    <a name="implementation">

    <h2>Implementation</h2>

    <div class="box">

	  <h3 class="box">KContext</h3>

	  <p class="box">
		block of manager references, current thread, contextual data constants
	  </p>

<span class="code"><pre>
struct KContext
{
    const char * app_name;              /* name of running application             */
    const char * app_path;              /* path to running application             */
    struct KMemMgr * mem;               /* all memory operations are exposed here  */
    struct KTextMgr const * text;       /* text operations                         */
    struct KProcMgr * proc;             /* scheduling and synchronization          */
    struct KContMgr const * cont;       /* container manager                       */
    struct KThreadState * thread;       /* represents the currently running thread */
    struct KLogMgr const * log;         /* logging functionality                   */
    struct KDbgMgr const * dbg;         /* debugging functionality                 */
    struct KAdaptMgr const * adapt;     /* adapter manager                         */
    struct Krypto const * krypto;       /* cryptographic functions                 */
    struct KCmpMgr const * cmp;         /* compression functions                   */
    struct KFSMgr * kfs;                /* host filesystem manager                 */
    struct KDirectory * wd;             /* current working directory               */
    struct KConfig * kfg;               /* configuration                           */
    struct KNSMgr * kns;                /* host networking manager                 */
    struct KArcMgr * ar;                /* archive manager ( kar, tar, zip, ar )   */
    struct VFSMgr * vfs;                /* virtual ( unifying ) file system        */
    struct KRepoMgr * repmgr;           /* repository manager ( name TBD )         */
    struct KRepository * repo;          /* current repository ( name TBD )         */
    struct KUserAgent * ua;             /* interface with user                     */
    struct KDBMgr * kdb;                /* physical database manager               */
    struct VDBMgr * vdb;                /* virtual database manager                */
};
</pre></span>

	  <p class="box-discussion">
		The definition of this structure may change over time. It is initially
		described as an example.
	  </p>
 
	  <p class="box-discussion">
		The simple approach to <em>KContext</em> is to have
		<strong>KMane</strong> create the initial, master copy and populate it
		with standard managers. These managers in turn can interpret parameters
		in the command line during initialization. Since each called function
		has the opportunity to modify the set of managers,
		<strong>KMain</strong> will typically apply some modifications.
	  </p>
 
	  <p class="box-discussion">
		If VDB were used only by our own tools, <em>KContext</em> could be
		managed in this way. But to handle the case where we are called by code
		beyond our control <em>( e.g., the C++ Toolkit, Java, etc. )</em>, we
		are going to have to apply a total hack approach. On Linux and Mac, we
		will use <strong>pthread_key_create</strong> to associate an allocated
		<em>KContext</em> block with each thread, and thus acquire the ability
		to recover this block with each call. On Windows, sigh, we can pursue a
		couple of approaches: using their <q>Thread-Local Storage</q> that does
		not allow for registration of a cleanup function, or by using process
		global data and building an associative array of these blocks, keyed by
		current thread id, with cleanup via <span class="code">atexit()</span>.
	  </p>

	  <p>
		And so it is that, for legacy support and ease of non-VDB clients, we
		will provide the <strong>global facility</strong> of creating/recovering
		a <em>KContext</em> block for the current thread. <em>KMane</em> will
		also have the ability to <strong>register</strong> its initially built
		block, which will make the global functions work, but will also ease the
		transition toward its use in VDB-2, making it possible to pick up on
		this block farther down the call-chain.
	  </p>

	</div>

    <div class="box">

	  <h3 class="box">KSourceLoc</h3>

	  <p class="box">
		static block containing description of source file
	  </p>

<span class="code"><pre>
struct KSourceLoc
{
    const char * mod;                   /* simple module name              */
    const char * file;                  /* simple file name - no extension */
    const char * ext;                   /* file name extension             */
};
</pre></span>

	  <p class="box-discussion">
		This structure is statically allocated one per source file, to gather
		information that is useful in tracking code execution and reporting or
		recording events.
	  </p>

	  <p class="box-discussion">
		A source-global static instance is declared by virtue of including its
		header file.
	  </p>
 
	</div>

    <div class="box">

	  <h3 class="box">KFuncLoc</h3>

	  <p class="box">
		static block containing function name and its source file context
	  </p>

<span class="code"><pre>
struct KFuncLoc
{
    const KSourceLoc * sloc;            /* source file context */
    const char * func;                  /* function name       */
};
</pre></span>

	  <p class="box-discussion">
		This structure is statically allocated one per function. It would be
		possible to have the structure include all of the data within the
		<em>KSourceLoc</em>, but this storage arrangement is more economical.
	  </p>

	  <p class="box-discussion">
		A static instance is declared as part of context initialization.
	  </p>
 
	</div>

    <div class="box">

	  <h3 class="box">ctx_t</h3>

	  <p class="box">
		local block for aggregating all context information within stack frame
	  </p>

<span class="code"><pre>
struct ctx_t
{
    const KContext * mgrs;              /* managers and current objects              */
    const KFuncLoc * info;              /* function id and location                  */
    const ctx_t * caller;               /* calling stack frame                       */
    bool err;                           /* error state                               */
    bool stop;                          /* marker for state propagation and clearing */
};
</pre></span>

	  <p class="box-discussion">
		This structure is allocated and initialized <strong>manually</strong> by
		the programmer.
	  </p>

	  <p class="box-discussion">
		As stated above, context is established upon function entry <em>( or
		as appropriate when needed )</em> through a macro:
	  </p>

<span class="code"><pre>
int MyFunction ( const ctx_t *ctx )
{
    FUNC_ENTRY ( ctx );

    /* code here */
}
</pre></span>

	  <p class="box-discussion">
		The macro is defined to perform all of the required steps as efficiently
		as possible, and also to act as a <strong>declaration</strong> such that
		it can happen before, after or in the middle of variable declarations:
	  </p>

<span class="code"><pre>
int MyFunction ( const ctx_t * ctx )
{
    FUNC_ENTRY ( ctx );
    int ret_value = SomeOtherFunc ( ctx, 10 );

    /* code here */
}
</pre></span>

	  <p class="box-discussion">
		This is accomplished with the help of smart compilers and inline
		functions, perhaps as follows:
	  </p>

<span class="code"><pre>
__inline__
ctx_t FuncEntry ( ctx_t * local_ctx, const ctx_t ** entry_ctx, const KFuncLoc * info )
{
    local_ctx -> mgrs = ( * entry_ctx ) -> mgrs;
    local_ctx -> info = info;
    local_ctx -> caller = * entry_ctx;
    local_ctx -> err = false;
    local_ctx -> stop = false;
    * entry_ctx = local_ctx;
    return * local_ctx;
}

#define FUNC_ENTRY( ctx )                                            \
    static KFuncLoc s_info = { & s_sloc, __func__ };                 \
    ctx_t local_ctx = FuncEntry ( & local_ctx, & ( ctx ), & s_info )
</pre></span>

	  <p class="box-discussion">
		There are variations on how this is accomplished that can be tweaked for
		the compiler in question. GCC does a reasonable job of recognizing that
		returning <q>*local_ctx</q> is an assignment into itself, and generates
		no code. It does a more questionable job of initializing the two Boolean
		values, depending upon the optimization level requested. In VC++ we have
		lost the ability to drop into assembly language, so that's appreciated.
	  </p>

	  <p class="box-discussion">
		Setting an error involves propagation of the state up the call chain:
	  </p>

<span class="code"><pre>
void MarkError ( const ctx_t * ctx )
{
    for ( ; ctx != NULL && ! ctx -> stop; ctx = ctx -> caller )
    {
        if ( ctx -> err )
        {
            ( ( ctx_t* ) ctx ) -> stop = true;
            break;
        }

        ( ( ctx_t* ) ctx ) -> err = true;
    }
}
</pre></span>

	  <p class="box-discussion">
		Clearning an error is similar:
	  </p>

<span class="code"><pre>
void ClearError ( const ctx_t * ctx )
{
    if ( ctx != NULL )
    {
        ( ( ctx_t* ) ctx ) -> err = false;
        ( ( ctx_t* ) stop ) -> err = false;

        for ( ctx = ctx -> caller; ctx != NULL && ! ctx -> stop; ctx = ctx -> caller )
        {
            ( ( ctx_t* ) ctx ) -> err = false;
        }
    }
}
</pre></span>

	  <p class="box-discussion">
		The caller will test for an error by looking at the <strong>err</strong>
		member of its local structure. To follow traditional paradigms in error
		handling, we can define some more lame macros:
	  </p>

<span class="code"><pre>
#define TRY( x )        \
    x;                  \
    if ( ! ctx -> err )

#define CATCH( xc )               \
    else if ( blah blah blah xc )

#define CATCH_ALL() \
    else

int MyFunction ( const ctx_t * ctx )
{
    FUNC_ENTRY ( ctx );
    int ret_value;

    TRY ( ret_value = SomeOtherFunc ( ctx, 10 ) )
    {
        KLogMsg ( "success!" );
    }
    CATCH_ALL ()
    {
        KLogMsg ( "failure..." );
    }

    return ret_value;
}
</pre></span>

	  <p class="box-discussion">
		The example above shows use of <strong>KLogMsg</strong> without a
		context parameter, but this is to avoid complicating the issue. In
		reality, we would pass in a context pointer and <em>could</em> detect an
		error while indicating success. We would then either consider this
		significant and pass it back, or we would routinely clear it
		afterward. In the failure case, any further error would
		<strong>not</strong> reset the previous error.
	  </p>
 
	</div>

	</a>

    <!-- Document Footer -->

    <hr/>
    <center>
        <span class="footer">NCBI VDB-2 Documentation</span>
    </center>

    </body>

</html>
