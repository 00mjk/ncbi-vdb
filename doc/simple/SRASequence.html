<html>

  <head>

    <title>NCBI VDB-2: SRASequence</title>
    <link href="simple.css" rel="stylesheet" type="text/css"/>

  </head>

  <body>

    <!-- Document Header -->

    <h1>VDB-2 - Simple API: SRASequence</h1>

    <p class="toc">
    <span class="hdr">Type:</span><br/>
      <span class="entry">interface</span>
    </p>

    <p class="toc">
    <span class="hdr">Revision History:</span><br/>
      <table class="entry">
        <tr><td>2013-Jun-30</td><td>&bull;</td><td>rodarmer</td></tr>
      </table>
    </p>

    <p class="toc">
      <span class="hdr">Header:</span><br/>
      <span class="entry"><a href="../../interfaces/simple/sra.hpp">&lt;simple/sra.hpp&gt;</a></span>
    </p>

    <p class="toc">
      <span class="hdr">Package:</span><br/>
      <span class="entry">gov.nih.nlm.ncbi.sra</span>
    </p>

    <p class="toc">
    <span class="hdr">Contents:</span><br/>
    <ul class="toc-outer">
        <li><a href="#description">Description</a></li>
		<li><a href="#SRASequence">SRASequence</a></li>
		<ul class="toc-inner">
		  <li><a href="#SRASequence.name">name</a> - sequence name or id string</li>
		  <li><a href="#SRASequence.isTechnical">isTechnical</a> - test for SRA
			technical read</li>
		  <li><a href="#SRASequence.isReverse">isReverse</a> - question is really
			about strand...</li>
		  <li><a href="#SRASequence.getLength">getLength</a> - get sequence length</li>
		  <li><a href="#SRASequence.getBases">getBases</a> - get bases in IUPAC
			character set</li>
		  <li><a href="#SRASequence.isColorSpaceNative">isColorSpaceNative</a> -
			were original machine reads in colorspace</li>
		  <li><a href="#SRASequence.hasColorSpace">hasColorSpace</a> - can serve colorspace</li>
		  <li><a href="#SRASequence.getColorSpace">getColorSpace</a> - get sequence
			in ASCII colorspace</li>
		  <li><a href="#SRASequence.hasQualities">hasQualities</a> - are there
			qualities associated with sequence</li>
		  <li><a href="#SRASequence.getQualities">getQualities</a> - get qualities
			as binary PHRED scores</li>
		  <li><a href="#SRASequence.getAsciiQualities">getAsciiQualities</a> - get
			qualities as ASCII-encoded PHRED scores</li>
		</ul>
		<li><a href="#SRASequenceIterator">SRASequenceIterator</a></li>
		<ul class="toc-inner">
		  <li><a href="#SRASequenceIterator.next">next</a> - advance to next sequence</li>
		</ul>
    </ul>
    </p>

    <hr/>

    <!-- Description -->

    <a name="description">

    <h2>Description</h2>

    <div class="section">

      <p>
		This is an abstract interface to many sequence types we deal with in SRA
		and VDB. The list currently given ( wee hours of 7/1/2013 ) is missing
		some functionality; the ability to get from a sequence to an alignment.
	  </p>

	  <p>
		In cSRA it is possible to get from a read to its spot and then to the
		read's primary alignment due to cross-mounted indexing. For BAM, the
		read and the alignment are never separate, so that's possible. The
		unaligned sequences can just say they don't have a primary ( or any )
		alignment to offer.
	  </p>

	  <p>
		The concern comes over the memory management issues. We don't have a
		good story regarding automatic garbage collection between C and the AGC
		languages. We're fine with C++, but that's about it. The model of
		seeking related records works well when performed on an iterator that
		can refocus on the related record, but for <strong>different</strong>
		record types, following the link from sequence to alignment requires new
		and potentially expensive allocations, that will litter the C heap until
		Java decides to run its garbage collector.
	  </p>

	  <p>
		The alternative to allowing a transition from sequence to alignment is
		to force the user to walk aligned sequences with the alignment iterator,
		which will extend sequence, and give the ability to go from alignment to
		sequence, and thus establish the relationship.
	  </p>

    </div>

    </a>

    <!-- SRASequence -->
    <hr/>
    <a name="SRASequence">

    <h2>SRASequence</h2>

	<div class="section">

	  <p>
		<span class="hdr">extends</span><br/>
		<span class="entry">n/a</span>
	  </p>

	  <p>
		The <strong>SRASequence</strong> interface is used for several types of
		sequences, including WGS <strong>contigs</strong> at the moment.
	  </p>

	</div>

    <h3>messages</h3>

	<ul class="toc-outer">
	  <li><a href="#SRASequence.name">name</a> - sequence name or id string</li>
	  <li><a href="#SRASequence.isTechnical">isTechnical</a> - test for SRA
		technical read</li>
	  <li><a href="#SRASequence.isReverse">isReverse</a> - question is really
		about strand...</li>
	  <li><a href="#SRASequence.getLength">getLength</a> - get sequence length</li>
	  <li><a href="#SRASequence.getBases">getBases</a> - get bases in IUPAC
		character set</li>
	  <li><a href="#SRASequence.isColorSpaceNative">isColorSpaceNative</a> -
		were original machine reads in colorspace</li>
	  <li><a href="#SRASequence.hasColorSpace">hasColorSpace</a> - can serve colorspace</li>
	  <li><a href="#SRASequence.getColorSpaceKey">getColorSpaceKey</a> - get
		leading key base</li>
	  <li><a href="#SRASequence.getColorSpace">getColorSpace</a> - get sequence
		in ASCII colorspace</li>
	  <li><a href="#SRASequence.hasQualities">hasQualities</a> - are there
		qualities associated with sequence</li>
	  <li><a href="#SRASequence.getQualities">getQualities</a> - get qualities
		as binary PHRED scores</li>
	  <li><a href="#SRASequence.getAsciiQualities">getAsciiQualities</a> - get
		qualities as ASCII encoded PHRED scores</li>
	</ul>

    <!-- name -->
	<a name="SRASequence.name">

    <div class="box">

	  <h3 class="box">name</h3>

	  <p class="box">
		returns a textual identification string.
	  </p>

<span class="code"><pre>
    // C++
    String name () const
        throw ( SRAException );

    // Java
    public final String name ()
        throws SRAException { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">a textual sequence id</span>
      </p>

      <p>
        <span class="hdr">errors</span><br/>
        <span class="entry"><a href="SRAException.html">SRAException</a></span>
      </p>

	  <p class="box-discussion">
		Names are very expensive to store and their exact value is not as
		relevant as the ability to identify the read by <strong>some</strong>
		means. A name will be returned, but it may not be the same as the
		original one given by the submitter, in the case of SRA.
	  </p>

	  <p class="box-discussion">
		In the case of WGS, the name for a sequence will be the contig
		accession.
	  </p>

    </div>

	</a>

    <!-- isTechnical -->
	<a name="SRASequence.isTechnical">

    <div class="box">

	  <h3 class="box">isTechnical</h3>

	  <p class="box">
		query an SRA read for being technical<br/>
		( as opposed to biological )
	  </p>

<span class="code"><pre>
    // C++
    bool isTechnical () const
        throw ( SRAException );

    // Java
    public final boolean isTechnical ()
        throws SRAException { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">true if the read is technical</span>
      </p>

      <p>
        <span class="hdr">errors</span><br/>
        <span class="entry"><a href="SRAException.html">SRAException</a></span>
      </p>

	  <p class="box-discussion">
		It seems backward to ask this question, but asking if a read is
		<q>biological</q> poses more difficulties for non-SRA reads, e.g. WGS
		contigs.
	  </p>

    </div>

	</a>

    <!-- isReverse -->
	<a name="SRASequence.isReverse">

    <div class="box">

	  <h3 class="box">isReverse</h3>

	  <p class="box">
		asks if a sequence is known to be on a reverse strand
	  </p>

<span class="code"><pre>
    // C++
    bool isReverse () const
        throw ( SRAException );

    // Java
    public final boolean isReverse ()
        throws SRAException { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">true if the read is known to be on a reverse strand</span>
      </p>

      <p>
        <span class="hdr">errors</span><br/>
        <span class="entry"><a href="SRAException.html">SRAException</a></span>
      </p>

	  <p class="box-discussion">
		This message is questionable, since the answer is really tri-state: yes,
		no, dunno.
	  </p>

    </div>

	</a>

    <!-- getLength -->
	<a name="SRASequence.getLength">

    <div class="box">

	  <h3 class="box">getLength</h3>

	  <p class="box">
		returns the sequence length in bases.<br/>
		applies to base and color space<br/>
		also applies to qualities if present
	  </p>

<span class="code"><pre>
    // C++
    uint64_t getLength () const
        throw ( SRAException );

    // Java
    public final long getLength ()
        throws SRAException { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">the sequence length in elements</span>
      </p>

      <p>
        <span class="hdr">errors</span><br/>
        <span class="entry"><a href="SRAException.html">SRAException</a></span>
      </p>

	  <p class="box-discussion">
		It was already stated above, but the unit of measurement is in sequence
		elements, whether they be bases, colors or qualities.
	  </p>

    </div>

	</a>

    <!-- getBases -->
	<a name="SRASequence.getBases">

    <div class="box">

	  <h3 class="box">getBases</h3>

	  <p class="box">
		returns sequence in IUPAC character set
	  </p>

<span class="code"><pre>
    // C++
    String getBases () const
        throw ( SRAException );

    // Java
    public final String getBases ()
        throws SRAException { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">textual sequence of bases</span>
      </p>

      <p>
        <span class="hdr">errors</span><br/>
        <span class="entry"><a href="SRAException.html">SRAException</a></span>
      </p>

	  <p class="box-discussion">
		The object returned will have a <strong>copy</strong> of the data taken
		from the iterator. The potential performance impact of doing this
		frequently should be taken into account. There is no alternative offered
		in the simple API - to avoid it you should use VDB directly. However,
		make the best use possible of this copy once obtained.
	  </p>

    </div>

	</a>

    <!-- isColorSpaceNative -->
	<a name="SRASequence.isColorSpaceNative">

    <div class="box">

	  <h3 class="box">isColorSpaceNative</h3>

	  <p class="box">
		asks if a sequence is known to have originated in color space
	  </p>

<span class="code"><pre>
    // C++
    bool isColorSpaceNative () const
        throw ();

    // Java
    public final boolean isColorSpaceNative () { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">true if originally called in color space</span>
      </p>

	  <p class="box-discussion">
		Most programmers are tempted to phrase this question in terms of
		original platform, and would instead ask if the read belongs to a spot
		from an <q>ABSOLID</q> machine. While the two questions should be
		equivalent, we can't assume <em>ABSOLID</em> to be the only platform
		ever to generate colorspace.
	  </p>

    </div>

	</a>

    <!-- hasColorSpace -->
	<a name="SRASequence.hasColorSpace">

    <div class="box">

	  <h3 class="box">hasColorSpace</h3>

	  <p class="box">
		asks if a sequence can be obtained in colorspace
	  </p>

<span class="code"><pre>
    // C++
    bool hasColorSpace () const
        throw ();

    // Java
    public final boolean hasColorSpace () { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">true if sequence can supply colorspace</span>
      </p>

	  <p class="box-discussion">
		This question is <strong>very</strong> different from
		<a href="#SRASequence.isColorSpaceNative">isColorSpaceNative</a> in that
		even native basespace can be requested as colors.
	  </p>

    </div>

	</a>

    <!-- getColorSpaceKey -->
	<a name="SRASequence.getColorSpaceKey">

    <div class="box">

	  <h3 class="box">getColorSpaceKey</h3>

	  <p class="box">
		returns colorspace <q>key</q> base
	  </p>

<span class="code"><pre>
    // C++
    char getColorSpaceKey () const
        throw ( SRAException );

    // Java
    public final char getColorSpaceKey ()
        throws SRAException { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">colorspace key base character</span>
      </p>

      <p>
        <span class="hdr">errors</span><br/>
        <span class="entry"><a href="SRAException.html">SRAException</a></span>
      </p>

	  <p class="box-discussion">
		Colorspace employs a type of first derivative system that requires an
		original base to begin. This message obtains the base.
	  </p>

    </div>

	</a>

	</a>

    <!-- getColorSpace -->
	<a name="SRASequence.getColorSpace">

    <div class="box">

	  <h3 class="box">getColorSpace</h3>

	  <p class="box">
		returns sequence in ABI colorspace format<br/>
		NB - does <strong>not</strong> contain leading key base<br/>
		see <a href="#SRASequence.getColorSpaceKey">getColorSpaceKey</a>
	  </p>

<span class="code"><pre>
    // C++
    String getColorSpace () const
        throw ( SRAException );

    // Java
    public final String getColorSpace ()
        throws SRAException { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">textual sequence of colors</span>
      </p>

      <p>
        <span class="hdr">errors</span><br/>
        <span class="entry"><a href="SRAException.html">SRAException</a></span>
      </p>

	  <p class="box-discussion">
		The object returned will have a <strong>copy</strong> of the data taken
		from the iterator. The potential performance impact of doing this
		frequently should be taken into account. There is no alternative offered
		in the simple API - to avoid it you should use VDB directly. However,
		make the best use possible of this copy once obtained.
	  </p>

    </div>

	</a>

    <!-- hasQualities -->
	<a name="SRASequence.hasQualities">

    <div class="box">

	  <h3 class="box">hasQualities</h3>

	  <p class="box">
		asks if a sequence has accompanying quality values
	  </p>

<span class="code"><pre>
    // C++
    bool hasQualities () const
        throw ();

    // Java
    public final boolean hasQualities () { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">true if sequence can supply qualities</span>
      </p>

	  <p class="box-discussion">
		Quality values are generally assigned by base callers, but can be
		recalibrated by other processes. Not all sequences have qualities. This
		message asks the question.
	  </p>

    </div>

	</a>

    <!-- getQualities -->
	<a name="SRASequence.getQualities">

    <div class="box">

	  <h3 class="box">getQualities</h3>

	  <p class="box">
		returns array of binary PHRED quality values
	  </p>

<span class="code"><pre>
    // C++
    std :: vector &lt; uint8_t &gt; getQualities () const
        throw ( SRAException );

    // Java
    public final byte [] getQualities ()
        throws SRAException { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">array of quality values</span>
      </p>

      <p>
        <span class="hdr">errors</span><br/>
        <span class="entry"><a href="SRAException.html">SRAException</a></span>
      </p>

	  <p class="box-discussion">
		The object returned will have a <strong>copy</strong> of the data taken
		from the iterator. The potential performance impact of doing this
		frequently should be taken into account. There is no alternative offered
		in the simple API - to avoid it you should use VDB directly. However,
		make the best use possible of this copy once obtained.
	  </p>

    </div>

	</a>

    <!-- getAsciiQualities -->
	<a name="SRASequence.getAsciiQualities">

    <div class="box">

	  <h3 class="box">getAsciiQualities</h3>

	  <p class="box">
		returns array of ASCII-encoded PHRED quality values
	  </p>

<span class="code"><pre>
    // C++
    String getAsciiQualities ( uint8_t offset ) const
        throw ( SRAException );

    // Java
    public final String getAsciiQualities ( int offset )
        throws SRAException { ... }
</pre></span>

      <p>
        <span class="hdr">offset</span><br/>
        <span class="entry">offset of ASCII encoding</span><br/>
        <span class="entry">standard values are 33 and 64</span>
      </p>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">String of ASCII-encoded quality values</span>
      </p>

      <p>
        <span class="hdr">errors</span><br/>
        <span class="entry"><a href="SRAException.html">SRAException</a></span>
      </p>

	  <p class="box-discussion">
		The standard offset for ASCII-encoding of PHRED quality scores is
		33. Other encodings have been used, particularly 64 for log-odds scores
		since they can go negative.
	  </p>

	  <p class="box-discussion">
		The object returned will have a <strong>copy</strong> of the data taken
		from the iterator. The potential performance impact of doing this
		frequently should be taken into account. There is no alternative offered
		in the simple API - to avoid it you should use VDB directly. However,
		make the best use possible of this copy once obtained.
	  </p>

    </div>

	</a>

	<!-- end of SRASequence -->
    </a>

	<!-- SRASequenceIterator -->
    <hr/>
    <a name="SRASequenceIterator">

    <h2>SRASequenceIterator</h2>

	<div class="section">

	  <p>
		<span class="hdr">extends</span><br/>
		<span class="entry"><a href="#SRASequence">SRASequence</a></span>
	  </p>

	  <p>
		The <strong>SRASequenceIterator</strong> adds standard iteration
		functionality to the <em>SRASequence</em> interface.
	  </p>

	</div>

    <h3>messages</h3>

	<ul class="toc-outer">
	  <li><a href="#SRASequenceIterator.next">next</a> - advance to next sequence</li>
	</ul>

    <!-- next -->
	<a name="SRASequenceIterator.next">

    <div class="box">

	  <h3 class="box">next</h3>

	  <p class="box">
		advance to first or next sequence
	  </p>

<span class="code"><pre>
    // C++
    bool next ()
        throw ( SRAException );

    // Java
    public final boolean next ()
        throws SRAException { ... }
</pre></span>

      <p>
        <span class="hdr">return value</span><br/>
        <span class="entry">true if iterator moved to first or next item</span><br/>
        <span class="entry">false if no more rows available</span>
      </p>

      <p>
        <span class="hdr">errors</span><br/>
        <span class="entry"><a href="SRAException.html">SRAException</a></span>
      </p>

	  <p class="box-discussion">
		When the iterator is created, it is technically not yet focused on the
		first row, so the caller should first send this message and receive
		affirmation that the row is available.
	  </p>

	  <p class="box-discussion">
		As with all iterators, and in the interest of removing gratuitous error
		conditions, the iterator will automatically focus on the first row if
		accessed before sending this message.
	  </p>

    </div>

	</a>

	<!-- end of SRASequenceIterator -->
    </a>

    <!-- Document Footer -->

    <hr/>
    <center>
      <span class="footer">NCBI VDB-2 Documentation</span>
    </center>

  </body>

</html>
