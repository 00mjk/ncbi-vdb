
The idea is to make access to encrypted objects transparent to the user (thus eliminating the need for explicit decoding which leads to keeping unencrypted files on disk), and make the objects unusable if transferred to a different user's environment. 

The implementation is based on a new format of encrypted files. The object will consist of two parts. One is a data file that contains two parts:
- unencrypted header which will expose the file's object id
- encrypted data portion. The keys necessary for decrypting all the blocks of the body are detached into a key file. The blocks are encrypted once and for all users, and can be held in public storage if so decided. Without the key file, the data portion is unusable.

The key file contains all the "key schedule" necessary for decrypting all blocks of the corresponding data portion. If the key file applies to a dbGaP object, it must contain a reference to the dbGaP project this object belongs to. 

The key file will be created when client requests the object download. It will contain the expiration date, client request date and server download date. The key file will be encrypted with a user-specific encryption key (called hereafter "user key") before being offered for download to this particular user. The user key is created by the dbGaP server when the user is granted access to the project. It will be transferred to the user's environment through the ngc file. There will be one user key per user per project. On a client, it will be stored in the file named in the project's KConfig entry.

If the user loses a user key, he can reset it using NCBI's web site, essentially generating a new .ngc file to download and import. This will make all previously downloaded encrypted key files unusable. The SRA tools, upon encountering such an object locally, will request a new download of the key file and if it succeeds, replace the outdated key file with the new one.

(Note to ourselves: the ngc file is a fragility that will not hold up much longer. It is essentially an obfuscated but otherwise cleartext delivery of secret keys through the Internet. We should insist that the download happen across at least https, but we still have the problem that the file hits disk and cache somewhere along the line. We probably need to provide a tool to manage the user's request for accessâ€¦)

We need to be able to detect the following cases of mismatch between key file and user key:
- missing key file: download a new key file
- missing user key: alert user to download a new ngc file
- out of date local key file (user has downloaded a new ngc): download a new version of the key file, verify the new user key, replace the key file
- corrupted user key (fails to decrypt a freshly downloaded key file): alert user to download a new ngc file
- expired key file: 
    - a hard expiration date has been reached: advise the user to contact dbGaP to request further access. Leave the key file in place.
    - a refresh date has been reached: try to download the new key file to refresh. if NCBI cannot be reached, warn the user and honor the old file, keep trying to refresh on subsequent accesses. If NCBI says "revoke", consider is a hard expiration
    
Always verify that user key works on key file once one of them has been downloaded.

VResolver will now support looking for key files. VPath may add a new scheme for that.

VFSManager will now support opening archives encrypted in the new format. On recognizing the new format, it will retrieve the object id from the header of the file and ask Resolver for location of the key file corresponding to this object. The name of the key file will be made from the object id extracted from the archive file (say <object-id>.kf).

The Resolver will search for the key file locally using the currently loaded configuration. The scope of the search may involve one or more dbGaP projects. For each dbGaP project, the Resolver will look for the correctly named file in the project cache specified by the project's entry in KConfig. 

We may be moving to the mode of operation where the user designates the project (or even a set of projects) he wants to work with. We want to support both that and the "free-for-all" approach. 
In the free-for-all case, VFSManager (Resolver?) will scan the current configuration for all protected projects and look for key files that match the object in question. If restricted, only the project(s) specified from the outside of VFS will be looked at.

If the key file is not found locally, VFSManager will requested it via http. The third component needed to open the archive is the user key which is required to decrypt the key file. 

A new implementation of KFile interface will combine the plain text key file and the data file.

BTW: KConfig path "krypto/pwfile" and environment variable VDB_PWFILE need to be deprecated.

==================================================

Pseudocode for the VFSManager's Open operation on the new encrypted file format.

if context is not known // context (= proj-id and possibly dl-key and/or user-key)
    advise user to enter a project context 
    
elif user-key for this project is not available (no dbGaP/proj-id/enc-key entry in the current konfig; file does not exist; file is not readable)
    advise user to obtain and import an ngc file for this project
        
elif key file is not available (file name <obj-id>.kf, in the cache directory of the project)
    if DownloadKeyFile()
        proceed to open the file
        
else // have context, user key, key file
    decrypt key file using user-key
    if readable (the result of decryption is a valid key schedule structure containing proj-id and expiration dates)
        match the key file's project id to the current project id
        if does not match
            advise user to switch the project context (of key file's project)
            
        elif key file has expired (hard expiration)
            advise user to obtain/renew access to this project
            
        elif key file needs a refresh (soft expiration)
            if RefreshKeyFile()
                proceed to open the file
        else
            proceed to open the file
            
    elif DownloadKeyFile()
        proceed to open the file
        
    else
        advise user to obtain and import an ngc file for this project

DownloadKeyFile(): bool
// We cannot decrypt the key file (which is possibly missing) with the existing user key.
// Must re-download the key file and attempt to apply the user key to it.
//
// returns true if decryption can proceed.
//
    if project's download-key is not available
        advise user to obtain and import an ngc file for this project
        return false
        
    elif Internet connection is present
    
        if NCBI refuses to authorize the download
            advise user to obtain/renew access to this project
            return false
        else
            use download-key to download key file to memory
            decrypt key file using user-key
            if readable (the result of decryption is a valid key schedule structure containing proj-id and expiration dates)
                write key file to disk (replace if exists)
                return true
            else // user-key must be bad
                advise user to obtain and import an ngc file for this project
                return false
                
    else // no connection
        error "could not contact NCBI"
        return false
        
RefreshKeyFile(): bool
// Try to refresh the key file and if unable to, we will proceed with the existing key file / user key combination
//
// returns true if decryption can proceed.
//
    if project's download-key is not available
        return true
        
    elif Internet connection is present
        // this branch is the same as in DownloadKeyFile()
        if NCBI refuses to authorize the download
            advise user to obtain/renew access to this project
            return false
        else
            use download-key to download the latest key file to memory
            decrypt key file using user-key
            if readable (the result of decryption is a valid key schedule structure containing proj-id and expiration dates)
                write key file to disk (replace if exists)
                return true
            else // user-key must be bad
                advise user to obtain and import an ngc file for this project
                return false
                
    else // no connection
        return true

==================================================             

Tasks:

- libs/krypto: implement EncFile v3

    - encryption (for NCBI side):
        - Inputs: data file, key schedule, project id, hard and soft expiration times 
        - Outputs: 
            - encrypted data file (unusable without key file)
            - unencrypted key file containing proj-id and expirations (relative to user's system clock), to be kept in a protected area on the server and encrypted with user key before being offered to the user
            
    - decryption (client side): 
        Inputs: encrypted data file, encrypted key file, user key
        Output: an implementation of KFile 

- libs/vfs: add support for v3-encypted file to VFSManager (per pseudo code above)

- a key creation tool that generates a plain text (PT) key file:
    key-gen(oid) -> PT key file
        Note. Here, the key file contains the object id of the accession it is used for. Alternatively, we may disassociate key files from their accessions, then obj-id would have to be supplied to the encryption tool (below)
    
- an encryption tool (vdb-encrypt or a new one)
    encrypt(PT key file, PT data file) -> encrypted data file. Contains obj-id in the header block; all other blocks are encrypted using the key file.
    
- a tool that creates a ready-to-download encrypted key file for the given user
    key-download 
        - Inputs:
            - PT key file
            - proj-id 
            - user key
            - user system's host time
            - expiration date 
            - refresh date
        - Output:
            a key file encrypted for this user+project, with expiration dates based on the user's system time

- decrypt function for the new format (only accessible through a KFile object or FUSE)
    decrypt
        - Inputs:
            - encrypted key file
            - user key
            - encrypted data file
        - Output:
            - decrypted data
 
                
=============
Workflow:

Pipeline calls key-gen(obj-id) to create a plain text key schedule, then invokes encrypt(key schedule, data file) to create an accession.
Saves accession, key schedule and their association in a database.
            
User applies for access to a project on an NCBI web site. The site creates a user key for this user and this project, and communicates it to the user in an ngc file. The .ngc file also contains project id and download key.

VFS on a client's system sends an http request for the accession to NCBI's CGI. The request contains object id, host date, download key.
Using accession id, CGI retrieves the key schedule.
Using object-id, CGI retrieves corresponding project id and the key schedule. 
Using download key, it retrieves the project id. 
Using project id (+user's identity?), it retrieves user key and expiration policy. 
Combines the key schedule with project-id, object-id, expiration dates (base on host-date), download time-stamp.
Encrypts the resulting key file with the user key, producing an encrypted key file for download. 



