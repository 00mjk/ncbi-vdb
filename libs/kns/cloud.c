/*=====================================================================================
*
*                            PUBLIC DOMAIN NOTICE
*               National Center for Biotechnology Information
*
*  This software/database is a "United States Government Work" under the
*  terms of the United States Copyright Act.  It was written as part of
*  the author's official duties as a United States Government employee and
*  thus cannot be copyrighted.  This software/database is freely available
*  to the public for use. The National Library of Medicine and the U.S.
*  Government have not placed any restriction on its use or reproduction.
*
*  Although all reasonable efforts have been taken to ensure the accuracy
*  and reliability of the software and data, the NLM and the U.S.
*  Government do not and cannot warrant the performance or results that
*  may be obtained by using this software or data. The NLM and the U.S.
*  Government disclaim all warranties, express or implied, including
*  warranties of performance, merchantability or fitness for any particular
*  purpose.
*
*  Please cite the author in any work or product based on this material.
*
* ================================================================================== */

#include <klib/printf.h> /* string_printf */
#include <klib/rc.h> /* RC */
#include <klib/text.h> /* string_measure */

#include <kns/cloud.h> /* KNSManagerMakeAwsAuthenticationHeader */

#include <ext/mbedtls/base64.h> /* vdb_mbedtls_base64_encode */
#include <ext/mbedtls/md.h> /* mbedtls_md_context_t */

/* compare HMAC_SHA1 generated by Digest::HMAC_SHA1 and vdb_mbedtls_md_hmac;
   turn on debugging messages
#define DEBUGGING 1 */

#if DEBUGGING
#include <stdio.h> /* popen */
#endif

/* https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html
#ConstructingTheAuthenticationHeader */

#if DEBUGGING
static unsigned char2byte(char c) {
    return c <= '9' ? c - '0' : c - 'a' + 10;
}

static rc_t pHMAC_SHA1(
    const char * YourSecretAccessKeyID,
    const char * StringToSign,
    unsigned char *dst, size_t dsize, size_t *olen)
{
    size_t i = 0;
    char bytes[64] = "";

    FILE * fp = NULL;

    char cmd[4096] = "";
    rc_t rc = string_printf(cmd, sizeof cmd, NULL,
        "perl -e 'use Digest::HMAC_SHA1 qw(hmac_sha1 hmac_sha1_hex);"
        "$data=\"%s\"; $key=\"%s\"; $digest = hmac_sha1($data, $key); "
        "print hmac_sha1_hex($data, $key)'", StringToSign, YourSecretAccessKeyID);
    if (rc != 0)
        return rc;

#if DEBUGGING
    puts(cmd);
#endif

    fp = popen(cmd, "r");
    if (fp == NULL)
        return 1;
    if (fgets(bytes, sizeof bytes - 1, fp) == NULL)
        rc = 2;
    pclose(fp);

#if DEBUGGING
    printf("as str: %s\n", bytes);
#endif

    assert(olen);
    *olen = 0;
    for (i = 0; ; i += 2) {
        if (bytes[i] == '\0')
            break;
        assert(bytes[i] && bytes[i + 1]);
        dst[(*olen)++] = (char2byte(bytes[i]) << 4) + char2byte(bytes[i + 1]);
    }

#if DEBUGGING
    printf("as hex: ");
    for (i = 0; i < *olen; ++i)
        printf("%x", dst[i]);
    puts("");
#endif

    return rc;
}
#endif

/* use mbedtls to generate HMAC_SHA1 */
static rc_t HMAC_SHA1(
    const char *key,
    const char *input,
    unsigned char *output)
{
    int ret = 0;

    const mbedtls_md_info_t *md_info = vdb_mbedtls_md_info_from_type(MBEDTLS_MD_SHA1);

    size_t keylen = string_measure(key, NULL);
    size_t ilen = string_measure(input, NULL);

    ret = vdb_mbedtls_md_hmac(md_info, (unsigned char *)key, keylen,
        (unsigned char *)input, ilen, output);

    return ret == 0 ? 0 : RC(rcVFS, rcUri, rcInitializing, rcEncryption, rcFailed);
}

/* Encode a buffer into base64 format */
static rc_t Base64(
    const unsigned char *src, size_t slen,
    char *dst, size_t dlen)
{
    rc_t rc = 0;

    size_t olen = 0;

#if DEBUGGING
    puts("vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv");
    printf("SRC   : ");
    size_t i = 0;
    for (i = 0; i < slen; ++i)
        printf("%x", src[i]);
    puts("");
#endif

    if (vdb_mbedtls_base64_encode((unsigned char *)dst, dlen, &olen, src, slen) != 0)
        rc = RC(rcVFS, rcUri, rcEncoding, rcString, rcInsufficient);

#if DEBUGGING
    olen = strlen((char*)dst);
    printf("DST   : ");
    for (i = 0; i < olen; ++i)
        printf("%c", dst[i]);
    puts("");
    printf("base64: %s\n", dst);
    puts("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^");
#endif

    return rc;
}

/* Compute AWS authenticating Signature:
Signature
= Base64( HMAC-SHA1( YourSecretAccessKeyID, UTF-8-Encoding-Of( StringToSign ) ) ); */
static rc_t Signature(const char * YourSecretAccessKeyID,
    const char * StringToSign,
    char *dst, size_t dlen)
{
    unsigned char src[64] = "";

#if DEBUGGING
    int i = 0;
    unsigned char pbuf[64] = "";
#endif

    size_t slen = 20;
    rc_t rc = HMAC_SHA1(YourSecretAccessKeyID, StringToSign, src);

#if DEBUGGING
    rc_t r = pHMAC_SHA1(YourSecretAccessKeyID, StringToSign, pbuf, sizeof pbuf, &slen);

    assert(rc == r);
    assert(slen == 20);
    for (i = 0; i < slen; ++i) {
        assert(src[i] == pbuf[i]);
    }
#endif

    if (rc == 0)
        rc = Base64(src, slen, dst, dlen);

    return rc;
}

/* MakeAwsAuthenticationHeader
*  constructs the Authorization request header value
*  ( https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html )
*
*  AWSAccessKeyId [ IN ] - AWS access key ID
*  YourSecretAccessKeyID [ IN ] - AWS secret access key
*  StringToSign [ IN ] - String To Sign
*  dst [ OUT ] - destination buffer, NULL-terminated
*  dlen [ IN ] - size of the destination buffer
*/
LIB_EXPORT rc_t CC KNSManagerMakeAwsAuthenticationHeader(
    const struct KNSManager *self,
    const char *AWSAccessKeyId,
    const char *YourSecretAccessKeyID,
    const char *StringToSign,
    char *dst, size_t dlen)
{
    size_t num_writ = 0;

    rc_t rc = string_printf(dst, dlen, &num_writ, "AWS %s:", AWSAccessKeyId);

    if (rc == 0) {
        if (num_writ >= dlen)
            return RC(rcVFS, rcUri, rcIdentifying, rcString, rcInsufficient);

        rc = Signature(YourSecretAccessKeyID, StringToSign,
            dst + num_writ, dlen - num_writ);
    }

    return rc;
}

/*************************************************************************************/
